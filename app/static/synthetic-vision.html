<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synthetic Vision - SkyEye</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-card: rgba(255, 255, 255, 0.03);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-tertiary: rgba(255, 255, 255, 0.4);
            --border-color: rgba(255, 255, 255, 0.08);
            --accent: #6b7280;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;

            /* SVS-specific colors */
            --terrain-safe: #22c55e;
            --terrain-caution: #f59e0b;
            --terrain-warning: #ef4444;
            --traffic-color: #3b82f6;
            --hazard-color: #a855f7;
            --sky-color: #1a365d;
            --ground-color: #78350f;
        }

        /* Light Mode */
        :root.light-mode {
            --bg-primary: #f5f5f5;
            --bg-secondary: #e8e8e8;
            --bg-card: rgba(0, 0, 0, 0.04);
            --text-primary: #1a1a1a;
            --text-secondary: rgba(0, 0, 0, 0.65);
            --text-tertiary: rgba(0, 0, 0, 0.45);
            --border-color: rgba(0, 0, 0, 0.12);
            --sky-color: #bfdbfe;
            --ground-color: #fcd34d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* Main SVS Canvas Container */
        #svs-container {
            position: fixed;
            inset: 0;
            z-index: 1;
        }

        #svs-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Floating brand/logo - top left */
        .floating-brand {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 18px;
            color: var(--text-primary);
            text-decoration: none;
            padding: 10px 16px;
            background: transparent;
            border: none;
            transition: all 0.2s ease;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.5));
        }

        .floating-brand:hover {
            transform: scale(1.05);
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.6));
        }

        .floating-brand svg.orca-logo {
            width: auto;
            height: 22px;
            color: #ffffff;
        }

        .light-mode .floating-brand {
            background: transparent;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
        }

        .light-mode .floating-brand:hover {
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.3));
        }

        .light-mode .floating-brand svg.orca-logo {
            color: #1a1a1a;
        }

        /* Floating theme toggle - top right */
        .floating-theme-toggle {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-primary);
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.5));
        }

        .floating-theme-toggle:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.6));
        }

        .floating-theme-toggle svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
        }

        .floating-theme-toggle .sun-icon {
            display: none;
        }

        .floating-theme-toggle .moon-icon {
            display: block;
        }

        .light-mode .floating-theme-toggle .sun-icon {
            display: block;
        }

        .light-mode .floating-theme-toggle .moon-icon {
            display: none;
        }

        .light-mode .floating-theme-toggle {
            background: transparent;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
        }

        .light-mode .floating-theme-toggle:hover {
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.3));
        }

        /* X-Plane Connection Status Indicator */
        .xplane-status {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            pointer-events: auto;
            backdrop-filter: blur(8px);
        }

        .xplane-status:hover {
            background: rgba(0, 0, 0, 0.85);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateX(-50%) scale(1.02);
        }

        .xplane-status.connected {
            border-color: #22c55e;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.3);
        }

        .xplane-status.receiving {
            border-color: #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        .xplane-status.receiving .xplane-icon {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            15% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }

        .xplane-icon {
            width: 20px;
            height: 20px;
            color: rgba(255, 255, 255, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .xplane-status.connected .xplane-icon,
        .xplane-status.receiving .xplane-icon {
            color: #22c55e;
        }

        .xplane-text {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        #xplane-status-label {
            font-weight: 600;
            font-size: 12px;
            color: #fff;
            letter-spacing: 0.5px;
        }

        #xplane-status-detail {
            color: rgba(255, 255, 255, 0.6);
            font-size: 10px;
        }

        .xplane-status.receiving #xplane-status-label {
            color: #3b82f6;
        }

        /* Autopilot Assist Panel */
        .autopilot-assist-panel {
            position: fixed;
            bottom: 70px;
            left: 16px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            min-width: 200px;
            backdrop-filter: blur(8px);
        }

        .ap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ap-header span {
            font-weight: 600;
            font-size: 11px;
            color: #22c55e;
            letter-spacing: 1px;
        }

        .ap-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 18px;
            cursor: pointer;
            padding: 0 4px;
        }

        .ap-close:hover {
            color: #fff;
        }

        .ap-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .ap-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ap-row label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            width: 70px;
            font-weight: 500;
        }

        .ap-row button {
            padding: 4px 12px;
            font-size: 11px;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            transition: all 0.2s;
        }

        .ap-row button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .ap-row button.active {
            background: #22c55e;
            border-color: #22c55e;
            color: #000;
        }

        .ap-row input {
            width: 70px;
            padding: 4px 8px;
            font-size: 11px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
        }

        .ap-row input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .ap-note {
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 9px;
            color: rgba(255, 255, 255, 0.4);
            line-height: 1.4;
        }

        /* Light mode adjustments for X-Plane UI */
        .light-mode .xplane-status {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .light-mode #xplane-status-label {
            color: #333;
        }

        .light-mode #xplane-status-detail {
            color: rgba(0, 0, 0, 0.5);
        }

        .light-mode .xplane-icon {
            color: rgba(0, 0, 0, 0.5);
        }

        .light-mode .autopilot-assist-panel {
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .light-mode .ap-header span {
            color: #16a34a;
        }

        .light-mode .ap-row label {
            color: rgba(0, 0, 0, 0.7);
        }

        .light-mode .ap-row button {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.2);
            color: #333;
        }

        .light-mode .ap-row input {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.2);
            color: #333;
        }

        .light-mode .ap-note {
            color: rgba(0, 0, 0, 0.4);
        }

        /* X-Plane Debug Panel */
        .xplane-debug-panel {
            position: fixed;
            top: 350px;
            right: 16px;
            z-index: 1002;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #22c55e;
            border-radius: 8px;
            padding: 10px;
            min-width: 220px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            backdrop-filter: blur(8px);
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
        }

        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #22c55e;
        }

        .debug-header span {
            font-weight: bold;
            color: #22c55e;
            letter-spacing: 1px;
        }

        .debug-close {
            background: none;
            border: none;
            color: #22c55e;
            font-size: 16px;
            cursor: pointer;
            padding: 0 4px;
        }

        .debug-close:hover {
            color: #fff;
        }

        .debug-content {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .debug-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .debug-row span:first-child {
            color: #888;
        }

        .debug-row span:last-child {
            color: #0f0;
            text-align: right;
        }

        .debug-separator {
            height: 1px;
            background: rgba(34, 197, 94, 0.3);
            margin: 4px 0;
        }

        /* HUD Overlay */
        .hud-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }

        /* Attitude Indicator - Center */
        .attitude-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 300px;
        }

        /* Flight Path Marker - Hidden */
        /* Flight Path Vector - Hidden (autopilot mode, no manual attitude reference needed) */
        .flight-path-vector {
            display: none;
        }

        .fpv-symbol,
        .fpv-circle,
        .fpv-wings,
        .fpv-wing,
        .fpv-tail {
            display: none;
        }

        /* Flight path guide line */
        .fpv-guide-line {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 0;
            background: linear-gradient(to top, rgba(0, 255, 255, 0.9), rgba(0, 255, 255, 0.6), rgba(0, 255, 255, 0));
            transform-origin: bottom center;
            pointer-events: none;
            z-index: 99;
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5), 0 0 30px rgba(0, 255, 255, 0.2);
        }

        .light-mode .fpv-guide-line {
            background: linear-gradient(to top, rgba(30, 58, 138, 0.9), rgba(30, 58, 138, 0.6), rgba(30, 58, 138, 0));
            box-shadow: 0 0 15px rgba(30, 58, 138, 0.5), 0 0 30px rgba(30, 58, 138, 0.2);
        }

        .flight-path-marker,
        .fpm-wing,
        .fpm-center,
        .fpm-tail {
            display: none;
        }

        /* Pitch Ladder - Hidden */
        .pitch-ladder,
        .pitch-line,
        .pitch-line-bar {
            display: none;
        }

        /* Attitude Indicator - Hidden */
        .attitude-indicator {
            display: none;
        }

        /* Bank Indicator - Hidden */
        .bank-indicator {
            display: none;
        }

        .bank-arc,
        .bank-pointer,
        .bank-tick {
            display: none;
        }

        /* Altitude Tape - Right */
        .altitude-tape {
            position: fixed;
            top: 28%;
            right: 100px;
            transform: translateY(-50%);
            width: 180px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }

        .tape-scale {
            display: none;
        }

        .tape-mark {
            display: none;
        }

        .tape-current {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 69px;
            font-weight: 600;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: #ffffff;
            text-shadow: 0 2px 8px rgba(0,0,0,0.8);
        }

        .tape-label {
            font-size: 14px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.5);
            margin-bottom: 5px;
        }

        .tape-secondary {
            font-size: 22px;
            font-weight: 500;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: #7dd3fc;
            margin-top: 5px;
        }

        .tape-secondary.positive {
            color: #4ade80;
        }

        .tape-secondary.negative {
            color: #f87171;
        }

        .tape-trend {
            display: none;
        }

        /* Speed Tape - Left */
        .speed-tape {
            position: fixed;
            top: 28%;
            left: 100px;
            transform: translateY(-50%);
            width: 180px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }

        /* Heading Indicator - Hidden (replaced by compass) */
        .heading-indicator {
            display: none;
        }

        .compass-tape,
        .compass-mark,
        .heading-pointer,
        .heading-current {
            display: none;
        }

        /* Circular Compass - Bottom Center */
        .compass-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            height: 280px;
            z-index: 100;
            pointer-events: none;
        }

        .compass-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(10, 10, 10, 0.85);
            border: none;
            box-shadow:
                0 8px 16px rgba(0, 0, 0, 0.6),
                0 -2px 6px rgba(255, 255, 255, 0.02),
                inset 0 1px 2px rgba(255, 255, 255, 0.03);
        }

        .compass-dial {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.15s ease-out;
        }

        .compass-tick {
            position: absolute;
            left: 50%;
            top: 12px;
            width: 1px;
            height: 8px;
            background: rgba(255, 255, 255, 0.5);
            transform-origin: center 128px;
        }

        .compass-tick.major {
            height: 12px;
            width: 1.5px;
            background: rgba(255, 255, 255, 0.8);
        }

        .compass-label {
            position: absolute;
            left: 50%;
            top: 35px;
            font-size: 16px;
            font-weight: 500;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: #ffffff;
            transform-origin: center 105px;
        }

        .compass-label.cardinal {
            font-size: 22px;
            font-weight: 600;
            top: 30px;
            transform-origin: center 110px;
        }

        .compass-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(10, 10, 10, 0.95);
            border: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .compass-heading-value {
            font-size: 42px;
            font-weight: 600;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: #ffffff;
            line-height: 1;
        }

        .compass-heading-value::after {
            content: '°';
            font-size: 28px;
        }

        .compass-track-value {
            font-size: 18px;
            font-weight: 500;
            color: #7dd3fc;
            margin-top: 4px;
        }

        .compass-track-value::after {
            content: '°';
            font-size: 14px;
        }

        .compass-pointer {
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 16px;
            background: #7dd3fc;
            border-radius: 50%;
            z-index: 10;
        }

        .compass-pointer::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 3px;
            height: 20px;
            background: #7dd3fc;
        }

        /* Wind Dial - Bottom Right of Compass */
        .wind-dial-container {
            position: fixed;
            bottom: 140px;
            left: calc(50% + 170px);
            width: 140px;
            height: 140px;
            z-index: 100;
            pointer-events: none;
        }

        .wind-dial-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(10, 10, 10, 0.85);
            border: none;
            box-shadow:
                0 8px 16px rgba(0, 0, 0, 0.6),
                0 -2px 6px rgba(255, 255, 255, 0.02),
                inset 0 1px 2px rgba(255, 255, 255, 0.03);
        }

        .wind-dial-pointer {
            display: none;
        }

        .wind-dial-rotator {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.3s ease-out;
        }

        .wind-sock {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .wind-sock-segment {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 2px;
            margin-bottom: 2px;
            transition: width 0.5s ease-out, height 0.5s ease-out, opacity 0.5s ease-out;
        }

        .wind-sock-segment:nth-child(1) {
            width: 12px;
            height: 8px;
            border-radius: 4px 4px 2px 2px;
        }

        .wind-sock-segment:nth-child(2) {
            width: 11px;
            height: 7px;
        }

        .wind-sock-segment:nth-child(3) {
            width: 9px;
            height: 7px;
        }

        .wind-sock-segment:nth-child(4) {
            width: 7px;
            height: 6px;
        }

        .wind-sock-segment:nth-child(5) {
            width: 5px;
            height: 5px;
            border-radius: 2px 2px 3px 3px;
        }

        .wind-dial-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .wind-speed-value {
            font-size: 36px;
            font-weight: 600;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: #ffffff;
            line-height: 1;
        }

        .wind-speed-unit {
            font-size: 14px;
            font-weight: 500;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 4px;
        }

        /* Traffic Mini Map - Bottom Left of Compass */
        .traffic-map-container {
            position: fixed;
            bottom: 140px;
            right: calc(50% + 170px);
            width: 140px;
            height: 140px;
            z-index: 100;
            pointer-events: none;
        }

        .traffic-map-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(10, 10, 10, 0.85);
            border: none;
            box-shadow:
                0 8px 16px rgba(0, 0, 0, 0.6),
                0 -2px 6px rgba(255, 255, 255, 0.02),
                inset 0 1px 2px rgba(255, 255, 255, 0.03);
        }

        .traffic-map-rotator {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.15s ease-out;
        }

        .traffic-map-aircraft {
            position: absolute;
            width: 0;
            height: 0;
            transform-origin: center center;
            transition: all 0.3s ease-out;
        }

        .traffic-map-aircraft::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(var(--ac-scale, 1));
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 10px solid #3b82f6;
        }

        .traffic-map-aircraft.above::before {
            border-bottom-color: #22c55e;
        }

        .traffic-map-aircraft.below::before {
            border-bottom-color: #f59e0b;
        }

        .traffic-map-ownship {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 12px solid #ffffff;
            z-index: 10;
        }

        .traffic-map-range {
            position: absolute;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .traffic-map-range.inner {
            width: 46px;
            height: 46px;
        }

        .traffic-map-range.outer {
            width: 92px;
            height: 92px;
        }

        .traffic-map-center {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            font-weight: 500;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Vertical Speed Indicator - Hidden (integrated into altitude tape) */
        .vsi-indicator {
            display: none;
        }

        .vsi-value,
        .vsi-label {
            display: none;
        }

        /* Controls Panel - Bottom Left */
        .svs-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1001;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 16px;
            width: 280px;
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        .svs-controls.minimized {
            width: 220px;
            padding: 12px;
        }

        .svs-controls.minimized .expandable-group {
            display: none;
        }

        .svs-controls.minimized .route-row {
            display: none;
        }

        .svs-controls.minimized .control-group.route-group label {
            display: none;
        }

        .svs-controls.fully-minimized {
            width: auto;
            min-width: 180px;
            padding: 10px;
        }

        .svs-controls.fully-minimized .control-group {
            display: none;
        }

        .svs-controls.fully-minimized .sim-progress-panel {
            display: none;
        }

        .svs-controls.expanded {
            width: 320px;
        }

        .debug-minimize {
            background: none;
            border: none;
            color: #22c55e;
            font-size: 18px;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
        }

        .debug-minimize:hover {
            color: #4ade80;
        }

        .svs-controls.expanded .sim-progress-panel {
            display: block;
        }

        .svs-controls.expanded .expandable-group {
            display: block;
        }

        .light-mode .svs-controls {
            background: rgba(245, 245, 245, 0.9);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .panel-title {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-primary);
        }

        .panel-buttons {
            display: flex;
            gap: 6px;
        }

        .panel-btn {
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .panel-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .panel-btn svg {
            width: 14px;
            height: 14px;
        }

        .sim-progress-panel {
            display: none;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .progress-route {
            font-weight: 600;
            color: var(--text-primary);
        }

        .progress-distance {
            color: var(--text-tertiary);
        }

        .progress-bar-large {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-bar-large .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent), #60a5fa);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .flight-rules {
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
        }

        .flight-rules.vfr {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .flight-rules.mvfr {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .flight-rules.ifr {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: 6px;
        }

        .control-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .control-group input[type="text"] {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 13px;
            color: var(--text-primary);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            text-transform: uppercase;
        }

        .specs-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .spec-item {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
        }

        .spec-label {
            color: var(--text-tertiary);
        }

        .spec-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        .control-group input[type="text"]::placeholder {
            color: var(--text-tertiary);
            text-transform: none;
        }

        .light-mode .control-group input[type="text"] {
            background: rgba(0, 0, 0, 0.05);
        }

        .control-group input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: var(--border-color);
            border-radius: 3px;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .control-value {
            min-width: 70px;
            text-align: right;
            font-size: 16px;
            font-weight: 600;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: var(--text-primary);
        }

        .icon-btn {
            width: 48px;
            height: 48px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .icon-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Overlay Toggles - Bottom Right */
        .overlay-toolbar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1001;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            padding: 8px;
            display: flex;
            gap: 6px;
            pointer-events: auto;
        }

        .light-mode .overlay-toolbar {
            background: rgba(245, 245, 245, 0.9);
        }

        .overlay-btn {
            width: 48px;
            height: 48px;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            border: none;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            box-shadow:
                4px 4px 8px rgba(0, 0, 0, 0.5),
                -2px -2px 4px rgba(255, 255, 255, 0.02),
                inset 0 1px 1px rgba(255, 255, 255, 0.04),
                inset 0 -2px 4px rgba(0, 0, 0, 0.4);
        }

        .overlay-btn:hover {
            background: linear-gradient(180deg, #323232 0%, #222222 100%);
            color: var(--text-primary);
        }

        .overlay-btn:active {
            transform: scale(0.97);
            background: linear-gradient(180deg, #1a1a1a 0%, #121212 100%);
            box-shadow:
                inset 0 3px 8px rgba(0, 0, 0, 0.7),
                inset 0 -1px 2px rgba(255, 255, 255, 0.02);
        }

        .overlay-btn.active {
            background: linear-gradient(180deg, #1a1a1a 0%, #141414 100%);
            border: none;
            box-shadow:
                inset 0 2px 6px rgba(0, 0, 0, 0.6),
                inset 0 -1px 2px rgba(255, 255, 255, 0.03);
        }

        .overlay-btn.active.terrain {
            background: rgba(139, 92, 42, 0.3);
            border: 1px solid rgba(139, 92, 42, 0.5);
            color: #d4a574;
        }

        .overlay-btn.active.traffic {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid rgba(0, 212, 255, 0.4);
            color: #00d4ff;
        }

        .overlay-btn.active.weather {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.4);
            color: #ef4444;
        }

        .overlay-btn.active.airspace {
            background: rgba(236, 72, 153, 0.2);
            border: 1px solid rgba(236, 72, 153, 0.4);
            color: #ec4899;
        }

        .overlay-btn.active.towers {
            background: rgba(168, 85, 247, 0.2);
            border: 1px solid rgba(168, 85, 247, 0.4);
            color: #a855f7;
        }

        .overlay-btn.active.tfr {
            background: rgba(249, 115, 22, 0.2);
            border: 1px solid rgba(249, 115, 22, 0.4);
            color: #f97316;
        }

        .overlay-btn.active.buildings {
            background: rgba(236, 72, 153, 0.2);
            border: 1px solid rgba(236, 72, 153, 0.4);
            color: #ec4899;
        }

        .overlay-btn.active.clouds {
            background: rgba(148, 163, 184, 0.2);
            border: 1px solid rgba(148, 163, 184, 0.4);
            color: #94a3b8;
        }

        .overlay-btn.active.icing {
            background: rgba(6, 182, 212, 0.2);
            border: 1px solid rgba(6, 182, 212, 0.4);
            color: #06b6d4;
        }

        .overlay-btn.active.visibility {
            background: rgba(168, 162, 158, 0.2);
            border: 1px solid rgba(168, 162, 158, 0.4);
            color: #d6d3d1;
        }

        .overlay-btn svg {
            width: 24px;
            height: 24px;
        }

        /* Light mode overlay buttons - white */
        .light-mode .overlay-btn {
            background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 100%);
            color: #333333;
            box-shadow:
                2px 2px 6px rgba(0, 0, 0, 0.15),
                -1px -1px 3px rgba(255, 255, 255, 0.8),
                inset 0 1px 1px rgba(255, 255, 255, 0.9),
                inset 0 -1px 2px rgba(0, 0, 0, 0.05);
        }

        .light-mode .overlay-btn:hover {
            background: linear-gradient(180deg, #ffffff 0%, #e8e8e8 100%);
            color: #111111;
        }

        .light-mode .overlay-btn:active {
            background: linear-gradient(180deg, #f0f0f0 0%, #e0e0e0 100%);
        }

        .light-mode .overlay-btn.active {
            background: linear-gradient(180deg, #e8e8e8 0%, #e0e0e0 100%);
            box-shadow:
                inset 0 2px 4px rgba(0, 0, 0, 0.1),
                inset 0 -1px 2px rgba(255, 255, 255, 0.5);
        }

        .light-mode .tape-current {
            color: #1a1a1a;
            text-shadow: 0 1px 4px rgba(255,255,255,0.8);
        }

        .light-mode .tape-label {
            color: rgba(0,0,0,0.5);
        }

        .light-mode .tape-secondary {
            color: #0369a1;
        }

        .fuel-bar-container {
            margin-top: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .fuel-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #22c55e, #84cc16);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .fuel-bar.low {
            background: linear-gradient(90deg, #f59e0b, #eab308);
        }

        /* Fuel section in left panel */
        .fuel-section {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }

        .fuel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .fuel-label {
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .fuel-value {
            font-size: 13px;
            color: #22c55e;
            font-weight: 600;
        }

        .fuel-section .fuel-bar-container {
            height: 6px;
            background: rgba(255, 255, 255, 0.15);
        }

        /* Aircraft Behavior grid */
        .behavior-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        .behavior-grid .spec-value {
            font-variant-numeric: tabular-nums;
        }

        .fuel-bar.critical {
            background: linear-gradient(90deg, #ef4444, #dc2626);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            inset: 0;
            z-index: 2000;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            transition: opacity 0.5s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Route Controls */
        .route-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .route-input {
            width: 70px !important;
            flex: none !important;
            text-align: center;
            padding: 12px 8px !important;
        }

        .swap-btn {
            width: 32px;
            height: 32px;
            min-width: 32px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .swap-btn:hover {
            background: var(--bg-tertiary);
            color: var(--accent);
            border-color: var(--accent);
        }

        .swap-btn svg {
            width: 16px;
            height: 16px;
        }

        .go-btn {
            width: 48px;
            height: 48px;
            min-width: 48px;
            background: var(--success);
            border: none;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            transition: all 0.2s ease;
        }

        .go-btn:hover {
            background: #16a34a;
            transform: scale(1.05);
        }

        .go-btn.active {
            background: var(--danger);
        }

        .go-btn.active:hover {
            background: #dc2626;
        }

        .go-btn svg {
            width: 20px;
            height: 20px;
        }

        .sim-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 12px;
        }

        .progress-bar {
            flex: 1;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: var(--success);
            border-radius: 3px;
            transition: width 0.1s ease;
        }

        .progress-text {
            min-width: 45px;
            text-align: right;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        /* Flight Phase Indicator (inside progress panel) */
        .flight-phase-indicator {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 10px;
            font-weight: 600;
            color: #00ffff;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .flight-phase-indicator.visible {
            display: flex;
        }

        /* Phase-specific colors */
        .flight-phase-indicator.phase-takeoff {
            color: #22c55e;
        }

        .flight-phase-indicator.phase-climb {
            color: #3b82f6;
        }

        .flight-phase-indicator.phase-cruise {
            color: #00ffff;
        }

        .flight-phase-indicator.phase-descent {
            color: #f59e0b;
        }

        .flight-phase-indicator.phase-approach,
        .flight-phase-indicator.phase-final {
            color: #f97316;
        }

        .flight-phase-indicator.phase-flare,
        .flight-phase-indicator.phase-touchdown,
        .flight-phase-indicator.phase-rollout {
            color: #ef4444;
        }

        .flight-phase-indicator .pulse-dot {
            width: 5px;
            height: 5px;
            background: currentColor;
            border-radius: 50%;
            animation: pulse-dot 1s ease-in-out infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .svs-controls {
                width: calc(100% - 40px);
                bottom: 80px;
            }

            .overlay-toolbar {
                bottom: 20px;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
            }

            .altitude-tape,
            .speed-tape {
                display: none;
            }

            .heading-indicator {
                width: 300px;
            }
        }

        /* Aircraft Label Popup */
        .aircraft-label {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00d4ff;
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            z-index: 1000;
            min-width: 140px;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3);
        }
        .aircraft-label.visible {
            opacity: 1;
        }
        .ac-callsign {
            font-weight: 600;
            font-size: 16px;
            color: #00d4ff;
            margin-bottom: 4px;
        }
        .ac-type {
            color: #999;
            font-size: 12px;
            margin-bottom: 6px;
        }
        .ac-data-row {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            margin-top: 4px;
        }
        .ac-alt, .ac-speed {
            color: #fff;
            font-size: 13px;
        }
        .ac-alt span, .ac-speed span {
            color: #7dd3fc;
        }
        .light-mode .aircraft-label {
            background: rgba(255, 255, 255, 0.95);
            border-color: #0284c7;
            box-shadow: 0 4px 20px rgba(2, 132, 199, 0.3);
        }
        .light-mode .ac-callsign {
            color: #0284c7;
        }
        .light-mode .ac-type {
            color: #666;
        }
        .light-mode .ac-alt, .light-mode .ac-speed {
            color: #1a1a1a;
        }
        .light-mode .ac-alt span, .light-mode .ac-speed span {
            color: #0369a1;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing Synthetic Vision...</div>
    </div>

    <!-- Floating Logo/Brand - links to main page -->
    <a href="/" class="floating-brand" title="Back to Weather Dashboard">
        <svg class="orca-logo" viewBox="0 0 798 257" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path d="M67.8809 234.41C186.564 258.373 307.51 270.119 360.879 234.41C414.248 198.702 779.734 36.4014 796.092 14.7603C812.45 -6.88083 723.078 -6.93654 548.57 29.5108C375.251 65.7097 321.828 80.6187 159.348 125.963L155.986 126.901C-9.12734 172.979 -50.8019 210.448 67.8809 234.41Z"/>
        </svg>
    </a>

    <!-- Floating Theme Toggle -->
    <button class="floating-theme-toggle" onclick="toggleTheme()" title="Toggle Light/Dark Mode">
        <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
        </svg>
        <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="5"/>
            <line x1="12" y1="1" x2="12" y2="3"/>
            <line x1="12" y1="21" x2="12" y2="23"/>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
            <line x1="1" y1="12" x2="3" y2="12"/>
            <line x1="21" y1="12" x2="23" y2="12"/>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
        </svg>
    </button>

    <!-- X-Plane Connection Status Indicator -->
    <div id="xplane-status" class="xplane-status" onclick="toggleXPlaneMode()" title="Toggle X-Plane Mode">
        <div class="xplane-icon">
            <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                <path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"/>
            </svg>
        </div>
        <div class="xplane-text">
            <span id="xplane-status-label">X-Plane</span>
            <span id="xplane-status-detail">Click to enable</span>
        </div>
    </div>

    <!-- Autopilot Assist Panel -->
    <div id="autopilot-assist" class="autopilot-assist-panel" style="display: none;">
        <div class="ap-header">
            <span>AUTOPILOT ASSIST</span>
            <button onclick="toggleAutopilotAssistPanel()" class="ap-close">&times;</button>
        </div>
        <div class="ap-controls">
            <div class="ap-row">
                <label>ALT HOLD</label>
                <button id="ap-alt-hold" onclick="toggleAltitudeHold()">OFF</button>
                <input type="number" id="ap-target-alt" placeholder="ft" step="100">
            </div>
            <div class="ap-row">
                <label>HDG HOLD</label>
                <button id="ap-hdg-hold" onclick="toggleHeadingHold()">OFF</button>
                <input type="number" id="ap-target-hdg" placeholder="deg" min="0" max="360">
            </div>
        </div>
        <div class="ap-note">
            Note: Assists provide visual guidance only.<br>
            Inceptor remains primary control via X-Plane.
        </div>
    </div>

    <!-- X-Plane Debug Panel -->
    <div id="xplane-debug" class="xplane-debug-panel">
        <div class="debug-header">
            <span>X-PLANE DEBUG</span>
            <button onclick="minimizeDebugPanel()" class="debug-minimize" id="debug-minimize-btn">−</button>
            <button onclick="toggleXPlaneDebug()" class="debug-close">&times;</button>
        </div>
        <div class="debug-content" id="debug-content">
            <div class="debug-row"><span>Status:</span><span id="dbg-status">Disconnected</span></div>
            <div class="debug-row"><span>Packets:</span><span id="dbg-packets">0</span></div>
            <div class="debug-row"><span>Source:</span><span id="dbg-source">-</span></div>
            <div class="debug-separator"></div>
            <div class="debug-row"><span>LAT:</span><span id="dbg-lat">0.000000</span></div>
            <div class="debug-row"><span>LON:</span><span id="dbg-lon">0.000000</span></div>
            <div class="debug-row"><span>ALT MSL:</span><span id="dbg-alt">0 ft</span></div>
            <div class="debug-row"><span>ALT AGL:</span><span id="dbg-agl">0 ft</span></div>
            <div class="debug-separator"></div>
            <div class="debug-row"><span>PITCH:</span><span id="dbg-pitch">0.0°</span></div>
            <div class="debug-row"><span>ROLL:</span><span id="dbg-roll">0.0°</span></div>
            <div class="debug-row"><span>HDG TRUE:</span><span id="dbg-hdg-true">0°</span></div>
            <div class="debug-row"><span>HDG MAG:</span><span id="dbg-hdg-mag">0°</span></div>
            <div class="debug-row"><span>MAG VAR:</span><span id="dbg-magvar">0°</span></div>
            <div class="debug-separator"></div>
            <div class="debug-row"><span>IAS:</span><span id="dbg-ias">0 kts</span></div>
            <div class="debug-row"><span>TAS:</span><span id="dbg-tas">0 kts</span></div>
            <div class="debug-row"><span>GS:</span><span id="dbg-gs">0 kts</span></div>
            <div class="debug-row"><span>VS:</span><span id="dbg-vs">0 fpm</span></div>
            <div class="debug-separator"></div>
            <div class="debug-row"><span>AOA:</span><span id="dbg-aoa">0.0°</span></div>
            <div class="debug-row"><span>G-Force:</span><span id="dbg-g">1.0</span></div>
            <div class="debug-row"><span>Mach:</span><span id="dbg-mach">0.00</span></div>
        </div>
    </div>

    <!-- Main SVS Canvas -->
    <div id="svs-container">
        <canvas id="svs-canvas"></canvas>
    </div>

    <!-- Aircraft Label Popup (for ADS-B traffic) -->
    <div id="aircraftLabel" class="aircraft-label"></div>

    <!-- HUD Overlay -->
    <!-- Flight Path Vector (2D HUD overlay) -->
    <div class="fpv-guide-line" id="fpvGuideLine"></div>
    <div class="flight-path-vector" id="flightPathVector">
        <div class="fpv-symbol">
            <div class="fpv-circle"></div>
            <div class="fpv-wings">
                <div class="fpv-wing"></div>
                <div class="fpv-wing"></div>
            </div>
            <div class="fpv-tail"></div>
        </div>
    </div>

    <div class="hud-overlay">
        <!-- Bank Indicator -->
        <div class="bank-indicator">
            <div class="bank-arc"></div>
            <div class="bank-pointer" id="bankPointer"></div>
        </div>

        <!-- Attitude Indicator -->
        <div class="attitude-indicator">
            <div class="pitch-ladder" id="pitchLadder">
                <div class="pitch-line" data-pitch="20">
                    <span>20</span>
                    <div class="pitch-line-bar"></div>
                    <span>20</span>
                </div>
                <div class="pitch-line" data-pitch="10">
                    <span>10</span>
                    <div class="pitch-line-bar"></div>
                    <span>10</span>
                </div>
                <div class="pitch-line horizon" data-pitch="0">
                    <div class="pitch-line-bar"></div>
                </div>
                <div class="pitch-line negative" data-pitch="-10">
                    <span>10</span>
                    <div class="pitch-line-bar"></div>
                    <span>10</span>
                </div>
                <div class="pitch-line negative" data-pitch="-20">
                    <span>20</span>
                    <div class="pitch-line-bar"></div>
                    <span>20</span>
                </div>
            </div>

            <!-- Flight Path Marker -->
            <div class="flight-path-marker">
                <div class="fpm-wing left"></div>
                <div class="fpm-center"></div>
                <div class="fpm-wing right"></div>
                <div class="fpm-tail"></div>
            </div>
        </div>

        <!-- Heading Indicator -->
        <div class="heading-indicator">
            <div class="heading-pointer"></div>
            <div class="compass-tape" id="compassTape"></div>
            <div class="heading-current" id="headingCurrent">000</div>
        </div>

        <!-- Altitude Tape -->
        <div class="altitude-tape">
            <div class="tape-label">ALT</div>
            <div class="tape-current" id="altitudeCurrent">5000</div>
            <div class="tape-secondary" id="vsiValue">+0 fpm</div>
        </div>

        <!-- Speed Tape -->
        <div class="speed-tape">
            <div class="tape-label">IAS</div>
            <div class="tape-current" id="speedCurrent">120</div>
            <div class="tape-secondary" id="accelValue">0 kt/m</div>
        </div>
    </div>

    <!-- Circular Compass -->
    <div class="compass-container" id="compassContainer">
        <div class="compass-ring"></div>
        <div class="compass-pointer"></div>
        <div class="compass-dial" id="compassDial">
            <!-- Ticks and labels will be generated by JS -->
        </div>
        <div class="compass-center">
            <div class="compass-heading-value" id="compassHeading">000</div>
            <div class="compass-track-value" id="compassTrack">000</div>
        </div>
    </div>

    <!-- Wind Dial -->
    <div class="wind-dial-container">
        <div class="wind-dial-ring"></div>
        <div class="wind-dial-pointer"></div>
        <div class="wind-dial-rotator" id="windDialRotator">
            <div class="wind-sock">
                <div class="wind-sock-segment"></div>
                <div class="wind-sock-segment"></div>
                <div class="wind-sock-segment"></div>
                <div class="wind-sock-segment"></div>
                <div class="wind-sock-segment"></div>
            </div>
        </div>
        <div class="wind-dial-center">
            <span class="wind-speed-value" id="windSpeedValue">0</span>
            <span class="wind-speed-unit">kts</span>
        </div>
    </div>

    <!-- Traffic Mini Map -->
    <div class="traffic-map-container">
        <div class="traffic-map-ring"></div>
        <div class="traffic-map-range inner"></div>
        <div class="traffic-map-range outer"></div>
        <div class="traffic-map-rotator" id="trafficMapRotator">
            <!-- Aircraft will be dynamically added here -->
        </div>
        <div class="traffic-map-ownship"></div>
        <div class="traffic-map-center">30nm</div>
    </div>

    <!-- Controls Panel -->
    <div class="svs-controls" id="svsControls">
        <div class="panel-header">
            <span class="panel-title">SKYTRON N90210</span>
            <div class="panel-buttons">
                <button class="panel-btn" id="resetBtn" title="Reset Route">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                        <path d="M3 3v5h5"/>
                    </svg>
                </button>
                <button class="panel-btn" id="togglePanelBtn" title="Expand/Minimize">
                    <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="15 3 21 3 21 9"/>
                        <polyline points="9 21 3 21 3 15"/>
                        <line x1="21" y1="3" x2="14" y2="10"/>
                        <line x1="3" y1="21" x2="10" y2="14"/>
                    </svg>
                    <svg class="collapse-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:none;">
                        <polyline points="4 14 10 14 10 20"/>
                        <polyline points="20 10 14 10 14 4"/>
                        <line x1="14" y1="10" x2="21" y2="3"/>
                        <line x1="3" y1="21" x2="10" y2="14"/>
                    </svg>
                </button>
            </div>
        </div>
        <div class="control-group route-group">
            <label>Route</label>
            <div class="control-row route-row">
                <input type="text" id="routeFrom" placeholder="LAX" class="route-input">
                <button class="swap-btn" id="swapRouteBtn" title="Swap Origin/Destination">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M7 16l-4-4 4-4"/>
                        <path d="M17 8l4 4-4 4"/>
                        <path d="M3 12h18"/>
                    </svg>
                </button>
                <input type="text" id="routeTo" placeholder="SFO" class="route-input">
                <button class="go-btn" id="goBtn" title="Simulate Flight">
                    <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="5,3 19,12 5,21"/>
                    </svg>
                    <svg class="stop-icon" viewBox="0 0 24 24" fill="currentColor" style="display:none;">
                        <rect x="6" y="6" width="12" height="12" rx="1"/>
                    </svg>
                </button>
            </div>
        </div>
        <div class="sim-progress-panel" id="simProgressPanel">
            <div class="progress-info">
                <span class="progress-route" id="progressRoute">---</span>
                <span class="progress-distance" id="progressDistance">0 nm</span>
            </div>
            <div class="progress-bar-large">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-stats">
                <span id="progressPercent">0%</span>
                <span class="flight-rules" id="flightRules">VFR</span>
                <span id="progressETA">--:--</span>
            </div>
            <div class="flight-phase-indicator" id="simStatus">
                <div class="pulse-dot"></div>
                <span id="simStatusText">TAKEOFF</span>
            </div>
            <div class="fuel-section">
                <div class="fuel-header">
                    <span class="fuel-label">FUEL</span>
                    <span class="fuel-value" id="infoFuel">81.0 gal</span>
                </div>
                <div class="fuel-bar-container">
                    <div class="fuel-bar" id="fuelBar"></div>
                </div>
            </div>
        </div>
        <div class="control-group expandable-group">
            <label>Position</label>
            <div class="control-row">
                <input type="text" id="positionInput" placeholder="LAX or 34.05, -118.24">
                <button class="icon-btn" id="useLocationBtn" title="Use Current Location">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <circle cx="12" cy="12" r="3"/>
                        <line x1="12" y1="2" x2="12" y2="6"/>
                        <line x1="12" y1="18" x2="12" y2="22"/>
                        <line x1="2" y1="12" x2="6" y2="12"/>
                        <line x1="18" y1="12" x2="22" y2="12"/>
                    </svg>
                </button>
            </div>
        </div>
        <div class="control-group expandable-group aircraft-specs">
            <label>Aircraft Performance</label>
            <div class="specs-grid">
                <div class="spec-item">
                    <span class="spec-label">Ceiling</span>
                    <span class="spec-value">17,500 ft</span>
                </div>
                <div class="spec-item">
                    <span class="spec-label">Vne</span>
                    <span class="spec-value">200 kts</span>
                </div>
                <div class="spec-item">
                    <span class="spec-label">Cruise</span>
                    <span class="spec-value">180 kts</span>
                </div>
                <div class="spec-item">
                    <span class="spec-label">Climb</span>
                    <span class="spec-value">1,400 fpm</span>
                </div>
                <div class="spec-item">
                    <span class="spec-label">Fuel Cap</span>
                    <span class="spec-value">81 gal</span>
                </div>
                <div class="spec-item">
                    <span class="spec-label">Range</span>
                    <span class="spec-value" id="specRange">~1,000 nm</span>
                </div>
            </div>
        </div>
        <div class="control-group expandable-group aircraft-behavior">
            <label>Aircraft Behavior</label>
            <div class="specs-grid behavior-grid">
                <div class="spec-item">
                    <span class="spec-label">LAT</span>
                    <span class="spec-value" id="infoLat">34.0522</span>
                </div>
                <div class="spec-item">
                    <span class="spec-label">LON</span>
                    <span class="spec-value" id="infoLon">-118.2437</span>
                </div>
                <div class="spec-item">
                    <span class="spec-label">GND</span>
                    <span class="spec-value" id="infoGround">0 ft</span>
                </div>
                <div class="spec-item">
                    <span class="spec-label">HDG</span>
                    <span class="spec-value" id="infoHdg">000°</span>
                </div>
                <div class="spec-item">
                    <span class="spec-label">PITCH</span>
                    <span class="spec-value" id="infoPitch">0°</span>
                </div>
                <div class="spec-item">
                    <span class="spec-label">ROLL</span>
                    <span class="spec-value" id="infoRoll">0°</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Overlay Toggles -->
    <div class="overlay-toolbar">
        <button class="overlay-btn terrain active" data-layer="terrain" title="Terrain">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 20h18L15 8l-3 4-4-3-5 11z"/>
            </svg>
        </button>
        <button class="overlay-btn traffic" data-layer="traffic" title="Traffic">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 16v-2l-8-5V3.5a1.5 1.5 0 0 0-3 0V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"/>
            </svg>
        </button>
        <button class="overlay-btn weather" data-layer="weather" title="Weather">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"/>
                <polyline points="13 11 9 17 15 17 11 23"/>
            </svg>
        </button>
        <button class="overlay-btn airspace" data-layer="airspace" title="Airspace">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/>
            </svg>
        </button>
        <button class="overlay-btn towers" data-layer="towers" title="Towers">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 22h16M10 22V10l-4 2v10M14 22V10l4 2v10M12 2l6 4-6 4-6-4 6-4z"/>
            </svg>
        </button>
        <button class="overlay-btn tfr" data-layer="tfr" title="TFR">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"/>
                <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/>
            </svg>
        </button>
        <button class="overlay-btn buildings" data-layer="buildings" title="Buildings">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="4" y="2" width="16" height="20" rx="2" ry="2"/>
                <path d="M9 22v-4h6v4M8 6h.01M16 6h.01M12 6h.01M12 10h.01M12 14h.01M16 10h.01M16 14h.01M8 10h.01M8 14h.01"/>
            </svg>
        </button>
        <button class="overlay-btn clouds" data-layer="clouds" title="Clouds">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 10h-1.26A8 8 0 109 20h9a5 5 0 000-10z"/>
            </svg>
        </button>
        <button class="overlay-btn icing" data-layer="icing" title="Icing">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2v20M2 12h20M4.93 4.93l14.14 14.14M19.07 4.93L4.93 19.07"/>
            </svg>
        </button>
        <button class="overlay-btn visibility" data-layer="visibility" title="Visibility">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                <circle cx="12" cy="12" r="3"/>
            </svg>
        </button>
    </div>

    <script>
        // ============================================
        // SYNTHETIC VISION SYSTEM
        // ============================================

        // State
        // Cirrus SR22 Performance Specifications
        const SR22 = {
            serviceCeiling: 17500,      // ft
            maxSpeed: 200,              // kts (capped as requested)
            cruiseSpeed: 180,           // kts at 75% power
            climbSpeed: 110,            // kts (Vy best rate)
            stallSpeed: 60,             // kts clean
            approachSpeed: 80,          // kts
            maxClimbRate: 1400,         // fpm
            fuelCapacity: 81,           // gallons usable
            fuelBurnClimb: 17,          // gph at climb power
            fuelBurnCruise: 15.5,       // gph at 75% power
            fuelBurnDescent: 8,         // gph at reduced power
            fuelBurnIdle: 4,            // gph at idle
            range: 1000                 // nm at 75% power with reserves
        };

        const state = {
            position: { lat: 33.9425, lon: -118.4081 }, // LAX
            altitude: 0, // Start at zero (ground level)
            heading: 250, // LAX runway 25
            pitch: 0,
            roll: 0,
            groundSpeed: 0, // Parked on ground
            verticalSpeed: 0,
            speedHistory: [],
            acceleration: 0,
            targetHeading: null,
            terrainData: null,
            fuel: SR22.fuelCapacity,    // Current fuel in gallons
            fuelBurnRate: 0,            // Current gph
            overlays: {
                terrain: true,
                traffic: false,  // Live ADS-B traffic - disabled in performance mode
                weather: false,
                airspace: false,
                towers: false,
                tfr: false,
                buildings: false,
                clouds: true,  // Enabled by default for flight awareness
                icing: true,   // Enabled by default for flight awareness
                visibility: false
            },
            buildingData: null, // Cached building data from OSM
            simulation: {
                active: false,
                route: null,
                progress: 0,
                startTime: null,
                duration: 60000,
                cruiseAltitude: 17500,  // SR22 ceiling
                lastUpdateTime: 0
            },
            windDirection: 270,  // Wind FROM direction (degrees)
            windSpeed: 12       // Wind speed in knots
        };

        // ==================== X-PLANE 12 INTEGRATION STATE ====================
        const xplaneState = {
            enabled: false,           // X-Plane mode active
            connected: false,         // WebSocket connected to backend
            receiving: false,         // Receiving UDP data from X-Plane
            websocket: null,          // WebSocket connection
            lastPacketTime: 0,        // Last data received timestamp
            reconnectAttempts: 0,
            maxReconnectAttempts: 10,
            reconnectDelay: 2000,     // ms
            packetsReceived: 0,

            // Autopilot assist features (available in X-Plane mode)
            autopilotAssist: {
                altitudeHold: false,
                headingHold: false,
                targetAltitude: null,
                targetHeading: null
            }
        };

        // Last terrain position for reload checking
        let lastTerrainPosition = { lat: 0, lon: 0 };
        const TERRAIN_RELOAD_THRESHOLD_NM = 5;

        // ==================== X-PLANE WEBSOCKET CLIENT ====================
        function connectXPlaneWebSocket() {
            if (xplaneState.websocket && xplaneState.websocket.readyState === WebSocket.OPEN) {
                return; // Already connected
            }

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/xplane`;

            console.log('Connecting to X-Plane WebSocket:', wsUrl);
            xplaneState.websocket = new WebSocket(wsUrl);

            xplaneState.websocket.onopen = function() {
                console.log('X-Plane WebSocket connected');
                xplaneState.connected = true;
                xplaneState.reconnectAttempts = 0;
                updateXPlaneStatusIndicator();
            };

            xplaneState.websocket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);

                    if (data.type === 'ping') {
                        // Respond to keep-alive
                        xplaneState.websocket.send(JSON.stringify({ type: 'pong' }));
                        return;
                    }

                    if (data.type === 'connection_status') {
                        xplaneState.receiving = data.xplane_connected;
                        xplaneState.packetsReceived = data.packets_received || 0;
                        updateXPlaneStatusIndicator();
                        return;
                    }

                    // Flight data update from X-Plane
                    if (data.lat !== undefined && xplaneState.enabled) {
                        handleXPlaneData(data);
                    }
                } catch (e) {
                    console.error('Error parsing X-Plane data:', e);
                }
            };

            xplaneState.websocket.onclose = function() {
                console.log('X-Plane WebSocket disconnected');
                xplaneState.connected = false;
                xplaneState.receiving = false;
                updateXPlaneStatusIndicator();

                // Attempt reconnect
                if (xplaneState.enabled && xplaneState.reconnectAttempts < xplaneState.maxReconnectAttempts) {
                    xplaneState.reconnectAttempts++;
                    console.log(`Reconnecting in ${xplaneState.reconnectDelay}ms (attempt ${xplaneState.reconnectAttempts})`);
                    setTimeout(connectXPlaneWebSocket, xplaneState.reconnectDelay);
                }
            };

            xplaneState.websocket.onerror = function(error) {
                console.error('X-Plane WebSocket error:', error);
            };
        }

        function disconnectXPlaneWebSocket() {
            if (xplaneState.websocket) {
                xplaneState.websocket.close();
                xplaneState.websocket = null;
            }
            xplaneState.connected = false;
            xplaneState.receiving = false;
        }

        // ==================== HANDLE INCOMING X-PLANE DATA ====================
        function handleXPlaneData(data) {
            if (!xplaneState.enabled) return;

            xplaneState.lastPacketTime = performance.now();
            xplaneState.receiving = data.connected;
            xplaneState.packetsReceived = data.packets_received || xplaneState.packetsReceived;

            // Update SVS state from X-Plane data
            state.position.lat = data.lat;
            state.position.lon = data.lon;
            state.altitude = data.alt_msl;
            // Use magnetic heading if available, otherwise compute from true + mag_var
            if (data.heading_mag > -900) {
                state.heading = data.heading_mag;
            } else {
                // Estimate magnetic variation if not provided by X-Plane
                // For Western US (California), variation is approximately 11-13° East
                // Simple approximation based on longitude
                let magVar = data.mag_var;
                if (!magVar || magVar === 0) {
                    // Approximate magnetic variation for US based on longitude
                    // West Coast: ~12°E, Central: ~5°E, East Coast: ~10-15°W
                    const lon = data.lon || 0;
                    if (lon < -100) {
                        // West of 100°W - approximate 12° East
                        magVar = 12;
                    } else if (lon < -80) {
                        // Central US - approximate 3° East
                        magVar = 3;
                    } else {
                        // East Coast - approximate 12° West
                        magVar = -12;
                    }
                }
                // Compute magnetic from true: mag = true - variation (East positive)
                state.heading = (data.heading_true - magVar + 360) % 360;
            }
            state.pitch = data.pitch;
            state.roll = data.roll;
            state.groundSpeed = data.groundspeed;
            state.verticalSpeed = data.vertical_speed;

            // Additional data for enhanced displays
            if (data.airspeed_ind !== undefined) {
                state.indicatedAirspeed = data.airspeed_ind;
            }
            if (data.airspeed_true !== undefined) {
                state.trueAirspeed = data.airspeed_true;
            }
            if (data.alpha !== undefined) {
                state.angleOfAttack = data.alpha;
            }

            // Calculate wind from TAS vs groundspeed (approximation)
            if (data.airspeed_true !== undefined && data.groundspeed !== undefined) {
                const tas = data.airspeed_true;
                const gs = data.groundspeed;
                // Use same heading as state.heading (magnetic when available)
                const hdg = state.heading;

                // Wind component along flight path (headwind positive, tailwind negative)
                const windComponent = tas - gs;

                // Estimate wind speed (simplified - assumes wind is along flight path)
                state.windSpeed = Math.abs(windComponent);

                // Wind direction: if headwind, wind is FROM the heading direction
                // if tailwind, wind is FROM opposite direction
                if (windComponent > 0) {
                    // Headwind - wind coming from ahead
                    state.windDirection = hdg;
                } else {
                    // Tailwind - wind coming from behind
                    state.windDirection = (hdg + 180) % 360;
                }

                // Update wind dial
                updateWindDial();
            }
            if (data.g_normal !== undefined) {
                state.gForce = data.g_normal;
            }
            if (data.mach !== undefined) {
                state.mach = data.mach;
            }

            // Trigger terrain reload if position changed significantly
            checkTerrainReload();

            updateXPlaneStatusIndicator();
            updateXPlaneDebugPanel(data);
        }

        // ==================== X-PLANE DEBUG PANEL ====================
        function updateXPlaneDebugPanel(data) {
            const dbg = (id, val) => {
                const el = document.getElementById(id);
                if (el) el.textContent = val;
            };

            dbg('dbg-status', data.connected ? 'CONNECTED' : 'DISCONNECTED');
            dbg('dbg-packets', data.packets_received || 0);
            dbg('dbg-source', data.source_ip ? `${data.source_ip}:${data.source_port}` : '-');

            dbg('dbg-lat', data.lat?.toFixed(6) || '0.000000');
            dbg('dbg-lon', data.lon?.toFixed(6) || '0.000000');
            dbg('dbg-alt', `${Math.round(data.alt_msl || 0)} ft`);
            dbg('dbg-agl', `${Math.round(data.alt_agl || 0)} ft`);

            dbg('dbg-pitch', `${(data.pitch || 0).toFixed(1)}°`);
            dbg('dbg-roll', `${(data.roll || 0).toFixed(1)}°`);
            dbg('dbg-hdg-true', `${Math.round(data.heading_true || 0)}°`);
            dbg('dbg-hdg-mag', data.heading_mag > -900 ? `${Math.round(data.heading_mag)}°` : `~${Math.round(state.heading)}°`);
            // Show magnetic variation with source indicator
            let magVarDisplay = 'N/A';
            if (data.mag_var && data.mag_var !== 0) {
                magVarDisplay = `${data.mag_var.toFixed(1)}°`;
            } else if (data.lon) {
                // Show estimated value
                const lon = data.lon;
                const estVar = lon < -100 ? 12 : lon < -80 ? 3 : -12;
                magVarDisplay = `~${estVar}° (est)`;
            }
            dbg('dbg-magvar', magVarDisplay);

            dbg('dbg-ias', `${Math.round(data.airspeed_ind || 0)} kts`);
            dbg('dbg-tas', `${Math.round(data.airspeed_true || 0)} kts`);
            dbg('dbg-gs', `${Math.round(data.groundspeed || 0)} kts`);
            dbg('dbg-vs', `${Math.round(data.vertical_speed || 0)} fpm`);

            dbg('dbg-aoa', `${(data.alpha || 0).toFixed(1)}°`);
            dbg('dbg-g', (data.g_normal || 1).toFixed(2));
            dbg('dbg-mach', (data.mach || 0).toFixed(3));
        }

        function toggleXPlaneDebug() {
            const panel = document.getElementById('xplane-debug');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        }

        // ==================== TERRAIN RELOAD CHECK ====================
        function checkTerrainReload() {
            const dist = calculateDistance(
                lastTerrainPosition.lat,
                lastTerrainPosition.lon,
                state.position.lat,
                state.position.lon
            );

            if (dist > TERRAIN_RELOAD_THRESHOLD_NM) {
                lastTerrainPosition = { lat: state.position.lat, lon: state.position.lon };
                // Trigger terrain reload - the existing loadTerrainData function handles this
                if (typeof loadTerrainData === 'function') {
                    loadTerrainData(state.position.lat, state.position.lon);
                }
            }
        }

        // ==================== MODE SWITCHING ====================
        function enableXPlaneMode() {
            xplaneState.enabled = true;

            // Stop internal simulation if running
            if (state.simulation && state.simulation.active) {
                if (typeof stopSimulation === 'function') {
                    stopSimulation();
                } else {
                    state.simulation.active = false;
                }
            }

            // Connect WebSocket
            connectXPlaneWebSocket();

            // Update UI
            updateXPlaneStatusIndicator();
            showXPlaneNotification('X-Plane mode enabled - awaiting data from simulator');
        }

        function disableXPlaneMode() {
            xplaneState.enabled = false;
            disconnectXPlaneWebSocket();
            updateXPlaneStatusIndicator();
            showXPlaneNotification('X-Plane mode disabled - internal simulation available');
        }

        function toggleXPlaneMode() {
            if (xplaneState.enabled) {
                disableXPlaneMode();
            } else {
                enableXPlaneMode();
            }
        }

        // ==================== X-PLANE STATUS INDICATOR ====================
        function updateXPlaneStatusIndicator() {
            const statusEl = document.getElementById('xplane-status');
            const labelEl = document.getElementById('xplane-status-label');
            const detailEl = document.getElementById('xplane-status-detail');

            if (!statusEl) return;

            // Reset classes
            statusEl.classList.remove('connected', 'receiving');

            if (!xplaneState.enabled) {
                labelEl.textContent = 'X-Plane';
                detailEl.textContent = 'Click to enable';
            } else if (!xplaneState.connected) {
                labelEl.textContent = 'X-Plane';
                detailEl.textContent = 'Connecting...';
            } else if (!xplaneState.receiving) {
                statusEl.classList.add('connected');
                labelEl.textContent = 'X-Plane';
                detailEl.textContent = 'Awaiting data';
            } else {
                statusEl.classList.add('connected', 'receiving');
                labelEl.textContent = 'X-Plane LIVE';
                detailEl.textContent = `${Math.round(state.altitude)} ft | ${Math.round(state.groundSpeed)} kts`;
            }
        }

        function showXPlaneNotification(message) {
            // Create and show a temporary notification
            const notification = document.createElement('div');
            notification.className = 'xplane-notification';
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.85);
                color: #fff;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10000;
                border: 1px solid rgba(255, 255, 255, 0.2);
                animation: fadeInOut 3s forwards;
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // ==================== AUTOPILOT ASSIST FUNCTIONS ====================
        function toggleAltitudeHold() {
            const assist = xplaneState.autopilotAssist;
            assist.altitudeHold = !assist.altitudeHold;

            if (assist.altitudeHold) {
                const input = document.getElementById('ap-target-alt');
                assist.targetAltitude = input ? (parseInt(input.value) || Math.round(state.altitude)) : Math.round(state.altitude);
                if (input) input.value = assist.targetAltitude;
            }

            const btn = document.getElementById('ap-alt-hold');
            if (btn) {
                btn.textContent = assist.altitudeHold ? 'ON' : 'OFF';
                btn.classList.toggle('active', assist.altitudeHold);
            }
        }

        function toggleHeadingHold() {
            const assist = xplaneState.autopilotAssist;
            assist.headingHold = !assist.headingHold;

            if (assist.headingHold) {
                const input = document.getElementById('ap-target-hdg');
                assist.targetHeading = input ? (parseInt(input.value) || Math.round(state.heading)) : Math.round(state.heading);
                if (input) input.value = assist.targetHeading;
            }

            const btn = document.getElementById('ap-hdg-hold');
            if (btn) {
                btn.textContent = assist.headingHold ? 'ON' : 'OFF';
                btn.classList.toggle('active', assist.headingHold);
            }
        }

        function toggleAutopilotAssistPanel() {
            const panel = document.getElementById('autopilot-assist');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Comprehensive US & International Airport Database with Runway Data
        // Runway data sourced from OurAirports open data (ourairports.com/data/)
        let AIRPORTS = {
            // ===== MAJOR US HUBS =====
            // Runway data from OurAirports.com - accurate threshold coordinates
            // Both runway ends included for proper departure direction selection
            'KLAX': { lat: 33.9425, lon: -118.4081, name: 'Los Angeles Intl', elev: 128,
                runways: [
                    // Runway 06L/24R
                    { id: '06L', hdg: 83, len: 8925, wid: 150, lat: 33.9491, lon: -118.431 },
                    { id: '24R', hdg: 263, len: 8925, wid: 150, lat: 33.9521, lon: -118.402 },
                    // Runway 06R/24L
                    { id: '06R', hdg: 83, len: 10285, wid: 150, lat: 33.9467, lon: -118.435 },
                    { id: '24L', hdg: 263, len: 10285, wid: 150, lat: 33.9502, lon: -118.402 },
                    // Runway 07L/25R
                    { id: '07L', hdg: 83, len: 12091, wid: 150, lat: 33.9358, lon: -118.419 },
                    { id: '25R', hdg: 263, len: 12091, wid: 150, lat: 33.9399, lon: -118.38 },
                    // Runway 07R/25L
                    { id: '07R', hdg: 83, len: 11096, wid: 200, lat: 33.9338, lon: -118.419 },
                    { id: '25L', hdg: 263, len: 11096, wid: 200, lat: 33.9375, lon: -118.383 }
                ]},
            'KSFO': { lat: 37.6213, lon: -122.3790, name: 'San Francisco Intl', elev: 13,
                runways: [
                    // Runway 01L/19R
                    { id: '01L', hdg: 14, len: 7500, wid: 200, lat: 37.6046, lon: -122.3836 },
                    { id: '19R', hdg: 194, len: 7500, wid: 200, lat: 37.6256, lon: -122.3779 },
                    // Runway 01R/19L
                    { id: '01R', hdg: 14, len: 8648, wid: 200, lat: 37.6046, lon: -122.3752 },
                    { id: '19L', hdg: 194, len: 8648, wid: 200, lat: 37.6283, lon: -122.3691 },
                    // Runway 10L/28R
                    { id: '10L', hdg: 117, len: 11870, wid: 200, lat: 37.6187, lon: -122.3939 },
                    { id: '28R', hdg: 297, len: 11870, wid: 200, lat: 37.6073, lon: -122.3579 },
                    // Runway 10R/28L
                    { id: '10R', hdg: 117, len: 11381, wid: 200, lat: 37.6283, lon: -122.3939 },
                    { id: '28L', hdg: 297, len: 11381, wid: 200, lat: 37.6129, lon: -122.3579 }
                ]},
            'KJFK': { lat: 40.6413, lon: -73.7781, name: 'John F Kennedy Intl', elev: 13,
                runways: [
                    // Runway 04L/22R
                    { id: '04L', hdg: 31, len: 12079, wid: 200, lat: 40.622, lon: -73.7856 },
                    { id: '22R', hdg: 211, len: 12079, wid: 200, lat: 40.6488, lon: -73.7647 },
                    // Runway 04R/22L
                    { id: '04R', hdg: 31, len: 8400, wid: 200, lat: 40.6254, lon: -73.7703 },
                    { id: '22L', hdg: 211, len: 8400, wid: 200, lat: 40.6452, lon: -73.7549 },
                    // Runway 13L/31R
                    { id: '13L', hdg: 121, len: 10000, wid: 200, lat: 40.6578, lon: -73.7902 },
                    { id: '31R', hdg: 301, len: 10000, wid: 200, lat: 40.6437, lon: -73.7593 },
                    // Runway 13R/31L
                    { id: '13R', hdg: 121, len: 14511, wid: 200, lat: 40.6484, lon: -73.8167 },
                    { id: '31L', hdg: 301, len: 14511, wid: 200, lat: 40.6279, lon: -73.7716 }
                ]},
            'KORD': { lat: 41.9742, lon: -87.9073, name: "O'Hare Intl", elev: 680,
                runways: [
                    // Runway 04L/22R
                    { id: '04L', hdg: 39, len: 7500, wid: 150, lat: 41.9817, lon: -87.9139 },
                    { id: '22R', hdg: 219, len: 7500, wid: 150, lat: 41.9975, lon: -87.8964 },
                    // Runway 09L/27R
                    { id: '09L', hdg: 90, len: 7500, wid: 150, lat: 42.0028, lon: -87.9267 },
                    { id: '27R', hdg: 270, len: 7500, wid: 150, lat: 42.0028, lon: -87.8991 },
                    // Runway 09R/27L
                    { id: '09R', hdg: 90, len: 7967, wid: 150, lat: 41.9839, lon: -87.9184 },
                    { id: '27L', hdg: 270, len: 7967, wid: 150, lat: 41.9839, lon: -87.8891 },
                    // Runway 10C/28C
                    { id: '10C', hdg: 90, len: 10801, wid: 200, lat: 41.9657, lon: -87.9315 },
                    { id: '28C', hdg: 270, len: 10801, wid: 200, lat: 41.9657, lon: -87.8918 },
                    // Runway 10L/28R
                    { id: '10L', hdg: 90, len: 13000, wid: 150, lat: 41.969, lon: -87.9315 },
                    { id: '28R', hdg: 270, len: 13000, wid: 150, lat: 41.9691, lon: -87.8837 }
                ]},
            'KATL': { lat: 33.6407, lon: -84.4277, name: 'Hartsfield-Jackson Atlanta', elev: 1026,
                runways: [
                    // Runway 08L/26R
                    { id: '08L', hdg: 90, len: 9000, wid: 150, lat: 33.6495, lon: -84.439 },
                    { id: '26R', hdg: 270, len: 9000, wid: 150, lat: 33.6495, lon: -84.4095 },
                    // Runway 08R/26L
                    { id: '08R', hdg: 90, len: 10000, wid: 150, lat: 33.6468, lon: -84.4384 },
                    { id: '26L', hdg: 270, len: 10000, wid: 150, lat: 33.6468, lon: -84.4055 },
                    // Runway 09L/27R
                    { id: '09L', hdg: 90, len: 11890, wid: 150, lat: 33.6347, lon: -84.448 },
                    { id: '27R', hdg: 270, len: 11890, wid: 150, lat: 33.6347, lon: -84.4089 },
                    // Runway 09R/27L
                    { id: '09R', hdg: 90, len: 9001, wid: 150, lat: 33.6318, lon: -84.448 },
                    { id: '27L', hdg: 270, len: 9001, wid: 150, lat: 33.6318, lon: -84.4184 },
                    // Runway 10/28
                    { id: '10', hdg: 90, len: 9000, wid: 150, lat: 33.6203, lon: -84.4479 },
                    { id: '28', hdg: 270, len: 9000, wid: 150, lat: 33.6203, lon: -84.4183 }
                ]},
            'KDEN': { lat: 39.8561, lon: -104.6737, name: 'Denver Intl', elev: 5431,
                runways: [
                    // Runway 07/25
                    { id: '07', hdg: 91, len: 12000, wid: 150, lat: 39.8409, lon: -104.727 },
                    { id: '25', hdg: 271, len: 12000, wid: 150, lat: 39.8407, lon: -104.684 },
                    // Runway 08/26
                    { id: '08', hdg: 91, len: 12000, wid: 150, lat: 39.8776, lon: -104.662 },
                    { id: '26', hdg: 271, len: 12000, wid: 150, lat: 39.8772, lon: -104.619 },
                    // Runway 16L/34R
                    { id: '16L', hdg: 181, len: 12000, wid: 150, lat: 39.897, lon: -104.687 },
                    { id: '34R', hdg: 1, len: 12000, wid: 150, lat: 39.8641, lon: -104.687 },
                    // Runway 16R/34L
                    { id: '16R', hdg: 181, len: 16000, wid: 200, lat: 39.8958, lon: -104.696 },
                    { id: '34L', hdg: 1, len: 16000, wid: 200, lat: 39.8519, lon: -104.697 },
                    // Runway 17L/35R
                    { id: '17L', hdg: 181, len: 12000, wid: 150, lat: 39.865, lon: -104.641 },
                    { id: '35R', hdg: 1, len: 12000, wid: 150, lat: 39.832, lon: -104.642 },
                    // Runway 17R/35L
                    { id: '17R', hdg: 181, len: 12000, wid: 150, lat: 39.8612, lon: -104.66 },
                    { id: '35L', hdg: 1, len: 12000, wid: 150, lat: 39.8283, lon: -104.661 }
                ]},
            'KSEA': { lat: 47.4502, lon: -122.3088, name: 'Seattle-Tacoma Intl', elev: 433,
                runways: [
                    // Runway 16L/34R
                    { id: '16L', hdg: 176, len: 11901, wid: 150, lat: 47.472, lon: -122.3114 },
                    { id: '34R', hdg: 356, len: 11901, wid: 150, lat: 47.4396, lon: -122.3088 },
                    // Runway 16C/34C
                    { id: '16C', hdg: 176, len: 9426, wid: 150, lat: 47.4656, lon: -122.3019 },
                    { id: '34C', hdg: 356, len: 9426, wid: 150, lat: 47.4402, lon: -122.2996 },
                    // Runway 16R/34L
                    { id: '16R', hdg: 176, len: 8500, wid: 200, lat: 47.4591, lon: -122.2925 },
                    { id: '34L', hdg: 356, len: 8500, wid: 200, lat: 47.4361, lon: -122.2903 }
                ]},
            'KMIA': { lat: 25.7959, lon: -80.2870, name: 'Miami Intl', elev: 8,
                runways: [
                    // Runway 08L/26R
                    { id: '08L', hdg: 87, len: 8600, wid: 150, lat: 25.8029, lon: -80.3015 },
                    { id: '26R', hdg: 267, len: 8600, wid: 150, lat: 25.804, lon: -80.2754 },
                    // Runway 08R/26L
                    { id: '08R', hdg: 87, len: 10506, wid: 200, lat: 25.8007, lon: -80.3014 },
                    { id: '26L', hdg: 267, len: 10506, wid: 200, lat: 25.802, lon: -80.2695 },
                    // Runway 09/27
                    { id: '09', hdg: 87, len: 13000, wid: 150, lat: 25.7861, lon: -80.3148 },
                    { id: '27', hdg: 267, len: 13000, wid: 150, lat: 25.7877, lon: -80.2754 },
                    // Runway 12/30
                    { id: '12', hdg: 119, len: 9354, wid: 150, lat: 25.7993, lon: -80.3023 },
                    { id: '30', hdg: 299, len: 9354, wid: 150, lat: 25.7866, lon: -80.2775 }
                ]},
            'KLAS': { lat: 36.0840, lon: -115.1537, name: 'Las Vegas Harry Reid', elev: 2181,
                runways: [
                    // Runway 01L/19R
                    { id: '01L', hdg: 25, len: 8988, wid: 150, lat: 36.0753, lon: -115.17 },
                    { id: '19R', hdg: 205, len: 8988, wid: 150, lat: 36.0977, lon: -115.158 },
                    // Runway 01R/19L
                    { id: '01R', hdg: 25, len: 9771, wid: 150, lat: 36.0742, lon: -115.1675 },
                    { id: '19L', hdg: 205, len: 9771, wid: 150, lat: 36.0985, lon: -115.1535 },
                    // Runway 08L/26R
                    { id: '08L', hdg: 90, len: 14515, wid: 150, lat: 36.0763, lon: -115.1713 },
                    { id: '26R', hdg: 270, len: 14515, wid: 150, lat: 36.0763, lon: -115.121 },
                    // Runway 08R/26L
                    { id: '08R', hdg: 90, len: 10526, wid: 150, lat: 36.0736, lon: -115.161 },
                    { id: '26L', hdg: 270, len: 10526, wid: 150, lat: 36.0737, lon: -115.126 }
                ]},
            'KPHX': { lat: 33.4373, lon: -112.0078, name: 'Phoenix Sky Harbor', elev: 1135,
                runways: [
                    // Note: PHX runways not in OurAirports sample - using existing data
                    { id: '07L', hdg: 74, len: 10300, wid: 150, lat: 33.4417, lon: -112.0380 },
                    { id: '25R', hdg: 254, len: 10300, wid: 150, lat: 33.4450, lon: -111.998 },
                    { id: '07R', hdg: 74, len: 11489, wid: 150, lat: 33.4303, lon: -112.0350 },
                    { id: '25L', hdg: 254, len: 11489, wid: 150, lat: 33.4336, lon: -111.990 },
                    { id: '08', hdg: 74, len: 7800, wid: 150, lat: 33.4480, lon: -112.0150 },
                    { id: '26', hdg: 254, len: 7800, wid: 150, lat: 33.4508, lon: -111.988 }
                ]},
            'KDFW': { lat: 32.8998, lon: -97.0403, name: 'Dallas/Fort Worth', elev: 607,
                runways: [
                    // Runway 13L/31R
                    { id: '13L', hdg: 135, len: 9000, wid: 200, lat: 32.9126, lon: -97.0215 },
                    { id: '31R', hdg: 315, len: 9000, wid: 200, lat: 32.895, lon: -97.0008 },
                    // Runway 13R/31L
                    { id: '13R', hdg: 139, len: 9301, wid: 150, lat: 32.9096, lon: -97.0831 },
                    { id: '31L', hdg: 319, len: 9301, wid: 150, lat: 32.8903, lon: -97.0633 },
                    // Runway 17C/35C
                    { id: '17C', hdg: 180, len: 13401, wid: 150, lat: 32.9157, lon: -97.026 },
                    { id: '35C', hdg: 0, len: 13401, wid: 150, lat: 32.8789, lon: -97.0262 },
                    // Runway 17L/35R
                    { id: '17L', hdg: 180, len: 8500, wid: 150, lat: 32.8983, lon: -97.0098 },
                    { id: '35R', hdg: 0, len: 8500, wid: 150, lat: 32.875, lon: -97.0099 },
                    // Runway 17R/35L
                    { id: '17R', hdg: 180, len: 13401, wid: 200, lat: 32.9157, lon: -97.0299 },
                    { id: '35L', hdg: 0, len: 13401, wid: 200, lat: 32.8789, lon: -97.0301 },
                    // Runway 18L/36R
                    { id: '18L', hdg: 180, len: 13400, wid: 200, lat: 32.9158, lon: -97.0507 },
                    { id: '36R', hdg: 0, len: 13400, wid: 200, lat: 32.879, lon: -97.0509 },
                    // Runway 18R/36L
                    { id: '18R', hdg: 180, len: 13400, wid: 150, lat: 32.9158, lon: -97.0546 },
                    { id: '36L', hdg: 0, len: 13400, wid: 150, lat: 32.879, lon: -97.0548 }
                ]},
            'KBOS': { lat: 42.3656, lon: -71.0096, name: 'Boston Logan', elev: 20,
                runways: [
                    { id: '04R', hdg: 040, len: 10083, wid: 150, lat: 42.3543, lon: -71.0238 },
                    { id: '04L', hdg: 040, len: 7864, wid: 150, lat: 42.3596, lon: -71.0280 },
                    { id: '09', hdg: 095, len: 7001, wid: 150, lat: 42.3676, lon: -71.0320 },
                    { id: '15R', hdg: 150, len: 10006, wid: 150, lat: 42.3800, lon: -71.0080 }
                ]},
            'KEWR': { lat: 40.6895, lon: -74.1745, name: 'Newark Liberty', elev: 18,
                runways: [
                    { id: '04L', hdg: 040, len: 11000, wid: 150, lat: 40.6750, lon: -74.1920 },
                    { id: '04R', hdg: 040, len: 10000, wid: 150, lat: 40.6820, lon: -74.1850 },
                    { id: '11', hdg: 112, len: 6800, wid: 150, lat: 40.6980, lon: -74.1820 },
                    { id: '22L', hdg: 220, len: 10000, wid: 150, lat: 40.7050, lon: -74.1580 }
                ]},
            'KMSP': { lat: 44.8848, lon: -93.2223, name: 'Minneapolis-St Paul', elev: 841 },
            'KDTW': { lat: 42.2162, lon: -83.3554, name: 'Detroit Metro', elev: 645 },
            'KSLC': { lat: 40.7899, lon: -111.9791, name: 'Salt Lake City', elev: 4227 },
            'KSAN': { lat: 32.7336, lon: -117.1897, name: 'San Diego Intl', elev: 17 },
            'KPDX': { lat: 45.5898, lon: -122.5951, name: 'Portland Intl', elev: 31 },
            'PHNL': { lat: 21.3187, lon: -157.9225, name: 'Honolulu Intl', elev: 13 },
            'PANC': { lat: 61.1743, lon: -149.9962, name: 'Anchorage Intl', elev: 152 },

            // ===== SECONDARY US HUBS =====
            'KIAH': { lat: 29.9902, lon: -95.3368, name: 'Houston George Bush', elev: 97 },
            'KHOU': { lat: 29.6454, lon: -95.2789, name: 'Houston Hobby', elev: 46 },
            'KMCO': { lat: 28.4294, lon: -81.3089, name: 'Orlando Intl', elev: 96 },
            'KTPA': { lat: 27.9755, lon: -82.5332, name: 'Tampa Intl', elev: 26 },
            'KFLL': { lat: 26.0726, lon: -80.1527, name: 'Fort Lauderdale', elev: 9 },
            'KCLT': { lat: 35.2140, lon: -80.9431, name: 'Charlotte Douglas', elev: 748 },
            'KBWI': { lat: 39.1754, lon: -76.6683, name: 'Baltimore-Washington', elev: 146 },
            'KDCA': { lat: 38.8521, lon: -77.0377, name: 'Reagan National', elev: 15 },
            'KIAD': { lat: 38.9445, lon: -77.4558, name: 'Dulles Intl', elev: 313 },
            'KPHL': { lat: 39.8721, lon: -75.2411, name: 'Philadelphia Intl', elev: 36 },
            'KLGA': { lat: 40.7772, lon: -73.8726, name: 'LaGuardia', elev: 21 },
            'KSTL': { lat: 38.7487, lon: -90.3700, name: 'St Louis Lambert', elev: 618 },
            'KMCI': { lat: 39.2976, lon: -94.7139, name: 'Kansas City Intl', elev: 1026 },
            'KAUS': { lat: 30.1975, lon: -97.6664, name: 'Austin-Bergstrom', elev: 542 },
            'KSAT': { lat: 29.5337, lon: -98.4698, name: 'San Antonio Intl', elev: 809 },
            'KSMF': { lat: 38.6954, lon: -121.5908, name: 'Sacramento Intl', elev: 27 },
            'KSJC': { lat: 37.3626, lon: -121.9291, name: 'San Jose Intl', elev: 62 },
            'KOAK': { lat: 37.7213, lon: -122.2208, name: 'Oakland Intl', elev: 9 },
            'KSNA': { lat: 33.6757, lon: -117.8682, name: 'John Wayne Orange County', elev: 56 },
            'KONT': { lat: 34.0560, lon: -117.6012, name: 'Ontario Intl', elev: 944 },
            'KBUR': { lat: 34.2007, lon: -118.3585, name: 'Burbank Hollywood', elev: 778 },
            'KLGB': { lat: 33.8177, lon: -118.1516, name: 'Long Beach', elev: 60 },
            'KPSP': { lat: 33.8303, lon: -116.5067, name: 'Palm Springs Intl', elev: 477 },

            // ===== MOUNTAIN WEST =====
            'KRNO': { lat: 39.4991, lon: -119.7681, name: 'Reno-Tahoe Intl', elev: 4415 },
            'KABQ': { lat: 35.0402, lon: -106.6094, name: 'Albuquerque Intl', elev: 5355 },
            'KBOI': { lat: 43.5644, lon: -116.2228, name: 'Boise', elev: 2871 },
            'KGEG': { lat: 47.6199, lon: -117.5338, name: 'Spokane Intl', elev: 2376 },
            'KCOS': { lat: 38.8058, lon: -104.7007, name: 'Colorado Springs', elev: 6187 },
            'KASE': { lat: 39.2232, lon: -106.8689, name: 'Aspen-Pitkin County', elev: 7820 },
            'KEGE': { lat: 39.6426, lon: -106.9159, name: 'Eagle County Vail', elev: 6548 },
            'KGJT': { lat: 39.1224, lon: -108.5267, name: 'Grand Junction', elev: 4858 },
            'KSJC': { lat: 37.3626, lon: -121.9291, name: 'San Jose', elev: 62 },
            'KBIL': { lat: 45.8077, lon: -108.5429, name: 'Billings Logan', elev: 3652 },
            'KBZN': { lat: 45.7775, lon: -111.1530, name: 'Bozeman Yellowstone', elev: 4473 },
            'KMSO': { lat: 46.9163, lon: -114.0906, name: 'Missoula Intl', elev: 3206 },
            'KFCA': { lat: 48.3105, lon: -114.2559, name: 'Glacier Park Intl', elev: 2977 },
            'KGTF': { lat: 47.4820, lon: -111.3707, name: 'Great Falls Intl', elev: 3680 },
            'KHLN': { lat: 46.6068, lon: -111.9827, name: 'Helena Regional', elev: 3877 },
            'KJAC': { lat: 43.6073, lon: -110.7377, name: 'Jackson Hole', elev: 6451 },
            'KCYS': { lat: 41.1557, lon: -104.8118, name: 'Cheyenne Regional', elev: 6159 },
            'KCOD': { lat: 44.5202, lon: -109.0238, name: 'Yellowstone Regional', elev: 5102 },
            'KIDA': { lat: 43.5146, lon: -112.0708, name: 'Idaho Falls', elev: 4744 },
            'KTWF': { lat: 42.4818, lon: -114.4877, name: 'Twin Falls', elev: 4154 },
            'KSUN': { lat: 43.5044, lon: -114.2966, name: 'Sun Valley', elev: 5318 },
            'KPIH': { lat: 42.9098, lon: -112.5960, name: 'Pocatello Regional', elev: 4452 },

            // ===== SOUTHWEST =====
            'KELP': { lat: 31.8072, lon: -106.3778, name: 'El Paso Intl', elev: 3959 },
            'KTUS': { lat: 32.1161, lon: -110.9410, name: 'Tucson Intl', elev: 2643 },
            'KFLG': { lat: 35.1385, lon: -111.6692, name: 'Flagstaff Pulliam', elev: 7014 },
            'KSDL': { lat: 33.6229, lon: -111.9105, name: 'Scottsdale', elev: 1510 },
            'KGUP': { lat: 35.5111, lon: -108.7893, name: 'Gallup Municipal', elev: 6472 },
            'KSAF': { lat: 35.6171, lon: -106.0883, name: 'Santa Fe Municipal', elev: 6348 },
            'KPRC': { lat: 34.6545, lon: -112.4196, name: 'Prescott Regional', elev: 5045 },
            'KIWA': { lat: 33.3078, lon: -111.6556, name: 'Phoenix-Mesa Gateway', elev: 1384 },
            'KPHX': { lat: 33.4373, lon: -112.0078, name: 'Phoenix Sky Harbor', elev: 1135 },

            // ===== MIDWEST =====
            'KPIT': { lat: 40.4915, lon: -80.2329, name: 'Pittsburgh Intl', elev: 1203 },
            'KCLE': { lat: 41.4117, lon: -81.8498, name: 'Cleveland Hopkins', elev: 791 },
            'KCMH': { lat: 39.9980, lon: -82.8919, name: 'Columbus John Glenn', elev: 815 },
            'KCVG': { lat: 39.0488, lon: -84.6678, name: 'Cincinnati/Northern Kentucky', elev: 896 },
            'KIND': { lat: 39.7173, lon: -86.2944, name: 'Indianapolis Intl', elev: 797 },
            'KMKE': { lat: 42.9472, lon: -87.8966, name: 'Milwaukee Mitchell', elev: 723 },
            'KOSH': { lat: 43.9844, lon: -88.5570, name: 'Wittman Regional (Oshkosh)', elev: 808 },
            'KMDW': { lat: 41.7868, lon: -87.7522, name: 'Chicago Midway', elev: 620 },
            'KMSN': { lat: 43.1399, lon: -89.3375, name: 'Madison Dane County', elev: 887 },
            'KGRR': { lat: 42.8808, lon: -85.5228, name: 'Grand Rapids', elev: 794 },
            'KFNT': { lat: 42.9654, lon: -83.7436, name: 'Flint Bishop', elev: 782 },
            'KLAN': { lat: 42.7787, lon: -84.5874, name: 'Lansing Capital City', elev: 861 },
            'KAZO': { lat: 42.2350, lon: -85.5521, name: 'Kalamazoo', elev: 874 },
            'KSBN': { lat: 41.7087, lon: -86.3173, name: 'South Bend', elev: 799 },
            'KFWA': { lat: 40.9785, lon: -85.1951, name: 'Fort Wayne Intl', elev: 815 },
            'KEVV': { lat: 38.0370, lon: -87.5324, name: 'Evansville Regional', elev: 418 },
            'KDAY': { lat: 39.9024, lon: -84.2194, name: 'Dayton Intl', elev: 1009 },
            'KTOL': { lat: 41.5868, lon: -83.8078, name: 'Toledo Express', elev: 684 },
            'KCAK': { lat: 40.9161, lon: -81.4422, name: 'Akron-Canton', elev: 1228 },
            'KYNG': { lat: 41.2607, lon: -80.6791, name: 'Youngstown-Warren', elev: 1196 },
            'KDSM': { lat: 41.5340, lon: -93.6631, name: 'Des Moines Intl', elev: 958 },
            'KCID': { lat: 41.8847, lon: -91.7108, name: 'Cedar Rapids', elev: 869 },
            'KMLI': { lat: 41.4485, lon: -90.5075, name: 'Quad City Intl', elev: 590 },
            'KDBQ': { lat: 42.4020, lon: -90.7095, name: 'Dubuque Regional', elev: 1077 },
            'KFSD': { lat: 43.5820, lon: -96.7419, name: 'Sioux Falls Regional', elev: 1429 },
            'KRAP': { lat: 44.0453, lon: -103.0574, name: 'Rapid City Regional', elev: 3204 },
            'KFAR': { lat: 46.9207, lon: -96.8158, name: 'Fargo Hector', elev: 902 },
            'KBIS': { lat: 46.7727, lon: -100.7468, name: 'Bismarck', elev: 1661 },
            'KGFK': { lat: 47.9493, lon: -97.1761, name: 'Grand Forks Intl', elev: 845 },
            'KMOT': { lat: 48.2594, lon: -101.2803, name: 'Minot Intl', elev: 1716 },

            // ===== SOUTH =====
            'KBNA': { lat: 36.1245, lon: -86.6782, name: 'Nashville Intl', elev: 599 },
            'KMEM': { lat: 35.0424, lon: -89.9767, name: 'Memphis Intl', elev: 341 },
            'KRDU': { lat: 35.8776, lon: -78.7875, name: 'Raleigh-Durham', elev: 435 },
            'KPBI': { lat: 26.6832, lon: -80.0956, name: 'Palm Beach Intl', elev: 19 },
            'KRSW': { lat: 26.5362, lon: -81.7552, name: 'Fort Myers SW Florida', elev: 30 },
            'KJAX': { lat: 30.4941, lon: -81.6879, name: 'Jacksonville Intl', elev: 30 },
            'KPNS': { lat: 30.4734, lon: -87.1866, name: 'Pensacola Intl', elev: 121 },
            'KMSY': { lat: 29.9934, lon: -90.2580, name: 'New Orleans Louis Armstrong', elev: 4 },
            'KBHM': { lat: 33.5629, lon: -86.7535, name: 'Birmingham-Shuttlesworth', elev: 650 },
            'KHSV': { lat: 34.6372, lon: -86.7751, name: 'Huntsville Intl', elev: 629 },
            'KMOB': { lat: 30.6914, lon: -88.2428, name: 'Mobile Regional', elev: 219 },
            'KGPT': { lat: 30.4073, lon: -89.0701, name: 'Gulfport-Biloxi', elev: 28 },
            'KJAN': { lat: 32.3112, lon: -90.0759, name: 'Jackson-Medgar Evers', elev: 346 },
            'KBTR': { lat: 30.5332, lon: -91.1496, name: 'Baton Rouge Metro', elev: 70 },
            'KSHV': { lat: 32.4466, lon: -93.8256, name: 'Shreveport Regional', elev: 258 },
            'KLFT': { lat: 30.2053, lon: -91.9876, name: 'Lafayette Regional', elev: 42 },
            'KMLU': { lat: 32.5109, lon: -92.0377, name: 'Monroe Regional', elev: 79 },
            'KLCH': { lat: 30.1261, lon: -93.2234, name: 'Lake Charles Regional', elev: 15 },
            'KAEX': { lat: 31.3274, lon: -92.5498, name: 'Alexandria Intl', elev: 89 },

            // ===== TEXAS =====
            'KDAL': { lat: 32.8471, lon: -96.8518, name: 'Dallas Love Field', elev: 487 },
            'KAMA': { lat: 35.2194, lon: -101.7059, name: 'Amarillo Intl', elev: 3607 },
            'KLBB': { lat: 33.6636, lon: -101.8228, name: 'Lubbock Preston Smith', elev: 3282 },
            'KMAF': { lat: 31.9425, lon: -102.2019, name: 'Midland Intl', elev: 2871 },
            'KABI': { lat: 32.4113, lon: -99.6819, name: 'Abilene Regional', elev: 1791 },
            'KSPS': { lat: 33.9888, lon: -98.4919, name: 'Wichita Falls', elev: 1019 },
            'KTYR': { lat: 32.3541, lon: -95.4024, name: 'Tyler Pounds', elev: 544 },
            'KACT': { lat: 31.6113, lon: -97.2305, name: 'Waco Regional', elev: 516 },
            'KCLL': { lat: 30.5886, lon: -96.3638, name: 'College Station', elev: 321 },
            'KCRP': { lat: 27.7704, lon: -97.5012, name: 'Corpus Christi Intl', elev: 44 },
            'KBRO': { lat: 25.9068, lon: -97.4259, name: 'Brownsville', elev: 22 },
            'KHRL': { lat: 26.2285, lon: -97.6544, name: 'Harlingen Valley', elev: 36 },
            'KMFE': { lat: 26.1758, lon: -98.2386, name: 'McAllen Miller', elev: 107 },
            'KLRD': { lat: 27.5438, lon: -99.4616, name: 'Laredo Intl', elev: 508 },
            'KGGG': { lat: 32.3840, lon: -94.7115, name: 'Longview East Texas', elev: 365 },
            'KSJT': { lat: 31.3577, lon: -100.4963, name: 'San Angelo Regional', elev: 1919 },
            'KBPT': { lat: 29.9508, lon: -94.0207, name: 'Beaumont Port Arthur', elev: 15 },

            // ===== SOUTHEAST =====
            'KSAV': { lat: 32.1276, lon: -81.2021, name: 'Savannah/Hilton Head', elev: 51 },
            'KCHS': { lat: 32.8986, lon: -80.0405, name: 'Charleston Intl', elev: 46 },
            'KMYR': { lat: 33.6797, lon: -78.9283, name: 'Myrtle Beach Intl', elev: 25 },
            'KCAE': { lat: 33.9388, lon: -81.1195, name: 'Columbia Metro', elev: 236 },
            'KGSP': { lat: 34.8957, lon: -82.2189, name: 'Greenville-Spartanburg', elev: 964 },
            'KAVL': { lat: 35.4362, lon: -82.5418, name: 'Asheville Regional', elev: 2165 },
            'KILM': { lat: 34.2706, lon: -77.9026, name: 'Wilmington Intl', elev: 32 },
            'KFAY': { lat: 34.9912, lon: -78.8803, name: 'Fayetteville Regional', elev: 189 },
            'KPGV': { lat: 35.6352, lon: -77.3853, name: 'Greenville Pitt', elev: 26 },
            'KOAJ': { lat: 34.8292, lon: -77.6121, name: 'Jacksonville Albert Ellis', elev: 94 },
            'KGSO': { lat: 36.0978, lon: -79.9373, name: 'Greensboro Piedmont', elev: 925 },
            'KORF': { lat: 36.8946, lon: -76.2012, name: 'Norfolk Intl', elev: 26 },
            'KRIC': { lat: 37.5052, lon: -77.3197, name: 'Richmond Intl', elev: 167 },
            'KROA': { lat: 37.3255, lon: -79.9754, name: 'Roanoke-Blacksburg', elev: 1175 },
            'KCHO': { lat: 38.1386, lon: -78.4529, name: 'Charlottesville-Albemarle', elev: 639 },
            'KLYH': { lat: 37.3267, lon: -79.2004, name: 'Lynchburg Regional', elev: 938 },
            'KPHF': { lat: 37.1319, lon: -76.4930, name: 'Newport News', elev: 43 },
            'KLEX': { lat: 38.0365, lon: -84.6059, name: 'Lexington Blue Grass', elev: 979 },
            'KSDF': { lat: 38.1744, lon: -85.7360, name: 'Louisville Intl', elev: 501 },
            'KCHA': { lat: 35.0353, lon: -85.2038, name: 'Chattanooga Metro', elev: 683 },
            'KTYS': { lat: 35.8110, lon: -83.9940, name: 'Knoxville McGhee Tyson', elev: 981 },
            'KTRI': { lat: 36.4752, lon: -82.4074, name: 'Tri-Cities Regional', elev: 1519 },
            'KAGC': { lat: 40.3544, lon: -79.9302, name: 'Pittsburgh Allegheny', elev: 1252 },
            'KABE': { lat: 40.6521, lon: -75.4408, name: 'Lehigh Valley', elev: 393 },
            'KAVP': { lat: 41.3385, lon: -75.7234, name: 'Wilkes-Barre Scranton', elev: 962 },
            'KMDT': { lat: 40.1935, lon: -76.7634, name: 'Harrisburg Intl', elev: 310 },
            'KERI': { lat: 42.0831, lon: -80.1739, name: 'Erie Intl', elev: 732 },

            // ===== FLORIDA =====
            'KSFB': { lat: 28.7776, lon: -81.2375, name: 'Orlando Sanford', elev: 55 },
            'KDAB': { lat: 29.1799, lon: -81.0581, name: 'Daytona Beach Intl', elev: 34 },
            'KMLB': { lat: 28.1028, lon: -80.6453, name: 'Melbourne Orlando', elev: 33 },
            'KPIE': { lat: 27.9102, lon: -82.6874, name: 'St Pete-Clearwater', elev: 11 },
            'KSRQ': { lat: 27.3954, lon: -82.5544, name: 'Sarasota-Bradenton', elev: 30 },
            'KEYW': { lat: 24.5561, lon: -81.7596, name: 'Key West Intl', elev: 3 },
            'KGNV': { lat: 29.6901, lon: -82.2718, name: 'Gainesville Regional', elev: 152 },
            'KTLH': { lat: 30.3965, lon: -84.3503, name: 'Tallahassee Intl', elev: 81 },
            'KVPS': { lat: 30.4832, lon: -86.5254, name: 'Destin-Fort Walton', elev: 87 },
            'KECP': { lat: 30.3571, lon: -85.7954, name: 'Panama City NW Florida', elev: 69 },

            // ===== NORTHEAST =====
            'KPVD': { lat: 41.7326, lon: -71.4204, name: 'Providence TF Green', elev: 55 },
            'KBDL': { lat: 41.9389, lon: -72.6832, name: 'Hartford Bradley', elev: 173 },
            'KHVN': { lat: 41.2637, lon: -72.8868, name: 'New Haven Tweed', elev: 14 },
            'KSWF': { lat: 41.5041, lon: -74.1048, name: 'New York Stewart', elev: 491 },
            'KISP': { lat: 40.7952, lon: -73.1002, name: 'Long Island MacArthur', elev: 99 },
            'KHPN': { lat: 41.0670, lon: -73.7076, name: 'Westchester County', elev: 439 },
            'KALB': { lat: 42.7483, lon: -73.8017, name: 'Albany Intl', elev: 285 },
            'KSYR': { lat: 43.1112, lon: -76.1063, name: 'Syracuse Hancock', elev: 421 },
            'KROC': { lat: 43.1189, lon: -77.6724, name: 'Rochester Greater', elev: 559 },
            'KBUF': { lat: 42.9405, lon: -78.7322, name: 'Buffalo Niagara', elev: 728 },
            'KITH': { lat: 42.4910, lon: -76.4584, name: 'Ithaca Tompkins', elev: 1099 },
            'KELM': { lat: 42.1599, lon: -76.8916, name: 'Elmira Corning', elev: 954 },
            'KBGM': { lat: 42.2087, lon: -75.9798, name: 'Binghamton Greater', elev: 1636 },
            'KPWM': { lat: 43.6462, lon: -70.3093, name: 'Portland Jetport', elev: 76 },
            'KBGR': { lat: 44.8074, lon: -68.8281, name: 'Bangor Intl', elev: 192 },
            'KMHT': { lat: 42.9326, lon: -71.4357, name: 'Manchester-Boston', elev: 266 },
            'KBTV': { lat: 44.4720, lon: -73.1533, name: 'Burlington Intl', elev: 335 },
            'KPQI': { lat: 46.6890, lon: -68.0448, name: 'Presque Isle', elev: 534 },
            'KACK': { lat: 41.2531, lon: -70.0602, name: 'Nantucket Memorial', elev: 48 },
            'KMVY': { lat: 41.3931, lon: -70.6143, name: 'Marthas Vineyard', elev: 67 },
            'KHYA': { lat: 41.6693, lon: -70.2804, name: 'Cape Cod Barnstable', elev: 54 },

            // ===== PLAINS =====
            'KOMA': { lat: 41.3032, lon: -95.8941, name: 'Omaha Eppley', elev: 984 },
            'KOKC': { lat: 35.3931, lon: -97.6007, name: 'Oklahoma City Will Rogers', elev: 1295 },
            'KTUL': { lat: 36.1984, lon: -95.8881, name: 'Tulsa Intl', elev: 677 },
            'KLIT': { lat: 34.7294, lon: -92.2243, name: 'Little Rock', elev: 262 },
            'KXNA': { lat: 36.2819, lon: -94.3068, name: 'Northwest Arkansas', elev: 1287 },
            'KFSM': { lat: 35.3366, lon: -94.3674, name: 'Fort Smith Regional', elev: 469 },
            'KSGF': { lat: 37.2457, lon: -93.3886, name: 'Springfield-Branson', elev: 1268 },
            'KJLN': { lat: 37.1518, lon: -94.4983, name: 'Joplin Regional', elev: 981 },
            'KCOU': { lat: 38.8181, lon: -92.2196, name: 'Columbia Regional', elev: 889 },
            'KICT': { lat: 37.6499, lon: -97.4331, name: 'Wichita Eisenhower', elev: 1333 },
            'KLNK': { lat: 40.8510, lon: -96.7592, name: 'Lincoln', elev: 1219 },

            // ===== HAWAII & ALASKA =====
            'PHOG': { lat: 20.8986, lon: -156.4305, name: 'Maui Kahului', elev: 54 },
            'PHKO': { lat: 19.7388, lon: -156.0456, name: 'Kona Intl', elev: 47 },
            'PHTO': { lat: 19.7214, lon: -155.0485, name: 'Hilo Intl', elev: 38 },
            'PHLM': { lat: 20.7856, lon: -156.9514, name: 'Molokai', elev: 454 },
            'PHLI': { lat: 21.9760, lon: -159.3390, name: 'Lihue', elev: 153 },
            'PAFA': { lat: 64.8151, lon: -147.8561, name: 'Fairbanks Intl', elev: 439 },
            'PAJN': { lat: 58.3547, lon: -134.5762, name: 'Juneau Intl', elev: 21 },
            'PAKT': { lat: 55.3556, lon: -131.7137, name: 'Ketchikan Intl', elev: 89 },
            'PASN': { lat: 57.1675, lon: -170.2205, name: 'St Paul Island', elev: 63 },
            'PACD': { lat: 55.2063, lon: -162.7244, name: 'Cold Bay', elev: 96 },
            'PADQ': { lat: 57.7500, lon: -152.4939, name: 'Kodiak', elev: 73 },
            'PAOM': { lat: 64.5122, lon: -165.4453, name: 'Nome', elev: 37 },
            'PABE': { lat: 60.7798, lon: -161.8380, name: 'Bethel', elev: 126 },
            'PAOT': { lat: 66.8847, lon: -162.5985, name: 'Kotzebue', elev: 11 },
            'PABR': { lat: 71.2854, lon: -156.7660, name: 'Utqiagvik Wiley Post', elev: 44 },

            // ===== INTERNATIONAL =====
            'EGLL': { lat: 51.4700, lon: -0.4543, name: 'London Heathrow', elev: 83 },
            'LFPG': { lat: 49.0097, lon: 2.5479, name: 'Paris Charles de Gaulle', elev: 392 },
            'EDDF': { lat: 50.0379, lon: 8.5622, name: 'Frankfurt', elev: 364 },
            'EHAM': { lat: 52.3086, lon: 4.7639, name: 'Amsterdam Schiphol', elev: -11 },
            'LEMD': { lat: 40.4983, lon: -3.5676, name: 'Madrid Barajas', elev: 2001 },
            'LIRF': { lat: 41.8003, lon: 12.2389, name: 'Rome Fiumicino', elev: 15 },
            'LSZH': { lat: 47.4647, lon: 8.5492, name: 'Zurich', elev: 1416 },
            'CYVR': { lat: 49.1947, lon: -123.1792, name: 'Vancouver Intl', elev: 14 },
            'CYYZ': { lat: 43.6777, lon: -79.6248, name: 'Toronto Pearson', elev: 569 },
            'CYUL': { lat: 45.4706, lon: -73.7408, name: 'Montreal Trudeau', elev: 118 },
            'CYYC': { lat: 51.1225, lon: -114.0134, name: 'Calgary Intl', elev: 3557 },
            'CYEG': { lat: 53.3097, lon: -113.5800, name: 'Edmonton Intl', elev: 2373 },
            'MMMX': { lat: 19.4363, lon: -99.0721, name: 'Mexico City', elev: 7316 },
            'MMUN': { lat: 21.0365, lon: -86.8771, name: 'Cancun Intl', elev: 22 },
            'RJTT': { lat: 35.5494, lon: 139.7798, name: 'Tokyo Haneda', elev: 35 },
            'RJAA': { lat: 35.7653, lon: 140.3864, name: 'Tokyo Narita', elev: 141 },
            'VHHH': { lat: 22.3080, lon: 113.9185, name: 'Hong Kong', elev: 28 },
            'WSSS': { lat: 1.3644, lon: 103.9915, name: 'Singapore Changi', elev: 22 },
            'YSSY': { lat: -33.9461, lon: 151.1772, name: 'Sydney', elev: 21 },
            'NZAA': { lat: -37.0082, lon: 174.7850, name: 'Auckland', elev: 23 },
            'OMDB': { lat: 25.2528, lon: 55.3644, name: 'Dubai Intl', elev: 62 },
            'VABB': { lat: 19.0896, lon: 72.8656, name: 'Mumbai', elev: 39 },
            'ZBAA': { lat: 40.0799, lon: 116.6031, name: 'Beijing Capital', elev: 116 },
            'ZSPD': { lat: 31.1434, lon: 121.8052, name: 'Shanghai Pudong', elev: 13 },
            'RKSI': { lat: 37.4691, lon: 126.4505, name: 'Seoul Incheon', elev: 23 },
            // ===== ADDITIONAL US REGIONAL AIRPORTS =====
            // Mountain/West
            'KGTF': { lat: 47.4820, lon: -111.3707, name: 'Great Falls MT', elev: 3677 },
            'KHLN': { lat: 46.6068, lon: -111.9827, name: 'Helena MT', elev: 3877 },
            'KBUT': { lat: 45.9548, lon: -112.4972, name: 'Butte MT', elev: 5545 },
            'KLWT': { lat: 47.0493, lon: -109.4673, name: 'Lewistown MT', elev: 4167 },
            'KGGW': { lat: 48.2125, lon: -106.6147, name: 'Glasgow MT', elev: 2296 },
            'KMLS': { lat: 46.4280, lon: -105.8862, name: 'Miles City MT', elev: 2629 },
            'KDIK': { lat: 46.7974, lon: -102.8020, name: 'Dickinson ND', elev: 2592 },
            'KBIS': { lat: 46.7727, lon: -100.7468, name: 'Bismarck ND', elev: 1661 },
            'KMOT': { lat: 48.2594, lon: -101.2803, name: 'Minot ND', elev: 1716 },
            'KGFK': { lat: 47.9493, lon: -97.1761, name: 'Grand Forks ND', elev: 845 },
            'KFAR': { lat: 46.9207, lon: -96.8158, name: 'Fargo ND', elev: 902 },
            'KABR': { lat: 45.4491, lon: -98.4218, name: 'Aberdeen SD', elev: 1302 },
            'KPIR': { lat: 44.3827, lon: -100.2860, name: 'Pierre SD', elev: 1744 },
            // Wyoming
            'KSHR': { lat: 44.7692, lon: -106.9803, name: 'Sheridan WY', elev: 4021 },
            'KCOD': { lat: 44.5202, lon: -109.0238, name: 'Cody WY', elev: 5102 },
            'KRIW': { lat: 43.0642, lon: -108.4598, name: 'Riverton WY', elev: 5525 },
            'KCPR': { lat: 42.9080, lon: -106.4644, name: 'Casper WY', elev: 5350 },
            'KLAR': { lat: 41.3121, lon: -105.6750, name: 'Laramie WY', elev: 7284 },
            'KCYS': { lat: 41.1557, lon: -104.8118, name: 'Cheyenne WY', elev: 6156 },
            'KRKS': { lat: 41.5942, lon: -109.0652, name: 'Rock Springs WY', elev: 6764 },
            // Nebraska
            'KSNY': { lat: 41.1013, lon: -102.9853, name: 'Sidney NE', elev: 4313 },
            'KAIA': { lat: 42.0532, lon: -102.8037, name: 'Alliance NE', elev: 3931 },
            'KVTN': { lat: 42.8578, lon: -100.5480, name: 'Valentine NE', elev: 2596 },
            'KLBF': { lat: 41.1262, lon: -100.6837, name: 'North Platte NE', elev: 2777 },
            'KGRI': { lat: 40.9675, lon: -98.3096, name: 'Grand Island NE', elev: 1847 },
            'KEAR': { lat: 40.7270, lon: -99.0068, name: 'Kearney NE', elev: 2131 },
            'KLNK': { lat: 40.8510, lon: -96.7592, name: 'Lincoln NE', elev: 1219 },
            // Kansas
            'KGLD': { lat: 39.3706, lon: -101.6990, name: 'Goodland KS', elev: 3656 },
            'KHYS': { lat: 38.8422, lon: -99.2732, name: 'Hays KS', elev: 2010 },
            'KSLN': { lat: 38.7910, lon: -97.6522, name: 'Salina KS', elev: 1288 },
            'KMHK': { lat: 39.1410, lon: -96.6708, name: 'Manhattan KS', elev: 1057 },
            'KDDC': { lat: 37.7634, lon: -99.9656, name: 'Dodge City KS', elev: 2594 },
            'KGCK': { lat: 37.9275, lon: -100.7244, name: 'Garden City KS', elev: 2891 },
            'KLBL': { lat: 37.0442, lon: -100.9599, name: 'Liberal KS', elev: 2885 },
            // New Mexico
            'KSAF': { lat: 35.6171, lon: -106.0892, name: 'Santa Fe NM', elev: 6348 },
            'KSKX': { lat: 36.4582, lon: -105.6724, name: 'Taos NM', elev: 7095 },
            'KROW': { lat: 33.3016, lon: -104.5307, name: 'Roswell NM', elev: 3671 },
            'KCNM': { lat: 32.3375, lon: -104.2633, name: 'Carlsbad NM', elev: 3295 },
            'KLRU': { lat: 32.2894, lon: -106.9219, name: 'Las Cruces NM', elev: 4456 },
            'KFMN': { lat: 36.7412, lon: -108.2299, name: 'Farmington NM', elev: 5506 },
            'KGUP': { lat: 35.5111, lon: -108.7893, name: 'Gallup NM', elev: 6472 },
            // Arizona
            'KFLG': { lat: 35.1385, lon: -111.6712, name: 'Flagstaff AZ', elev: 7014 },
            'KPRC': { lat: 34.6545, lon: -112.4196, name: 'Prescott AZ', elev: 5045 },
            'KSEZ': { lat: 34.8486, lon: -111.7884, name: 'Sedona AZ', elev: 4830 },
            'KPGA': { lat: 36.9261, lon: -111.4483, name: 'Page AZ', elev: 4316 },
            'KIGM': { lat: 35.2595, lon: -113.9380, name: 'Kingman AZ', elev: 3449 },
            'KSDL': { lat: 33.6229, lon: -111.9106, name: 'Scottsdale AZ', elev: 1510 },
            // Texas Rural
            'KABI': { lat: 32.4113, lon: -99.6819, name: 'Abilene TX', elev: 1791 },
            'KSJT': { lat: 31.3577, lon: -100.4963, name: 'San Angelo TX', elev: 1919 },
            'KMFE': { lat: 26.1758, lon: -98.2386, name: 'McAllen TX', elev: 107 },
            'KBRO': { lat: 25.9068, lon: -97.4259, name: 'Brownsville TX', elev: 22 },
            'KHRL': { lat: 26.2285, lon: -97.6544, name: 'Harlingen TX', elev: 36 },
            'KLRD': { lat: 27.5438, lon: -99.4617, name: 'Laredo TX', elev: 508 },
            'KDRT': { lat: 29.3742, lon: -100.9273, name: 'Del Rio TX', elev: 1002 },
            'KPRX': { lat: 33.6366, lon: -95.4507, name: 'Paris TX', elev: 547 },
            // Additional Regional
            'KICT': { lat: 37.6499, lon: -97.4331, name: 'Wichita KS', elev: 1333 },
            'KTUL': { lat: 36.1984, lon: -95.8881, name: 'Tulsa OK', elev: 677 },
            'KOKC': { lat: 35.3931, lon: -97.6007, name: 'Oklahoma City OK', elev: 1295 },
            'KLIT': { lat: 34.7294, lon: -92.2243, name: 'Little Rock AR', elev: 266 },
            'KSGF': { lat: 37.2457, lon: -93.3886, name: 'Springfield MO', elev: 1268 },
            'KLEX': { lat: 38.0365, lon: -84.6059, name: 'Lexington KY', elev: 979 },
            'KSDF': { lat: 38.1740, lon: -85.7360, name: 'Louisville KY', elev: 501 },
            'KGRR': { lat: 42.8808, lon: -85.5228, name: 'Grand Rapids MI', elev: 794 },
            'KLAN': { lat: 42.7787, lon: -84.5874, name: 'Lansing MI', elev: 861 },
            'KFNT': { lat: 42.9655, lon: -83.7436, name: 'Flint MI', elev: 782 },
            'KGSO': { lat: 36.0978, lon: -79.9373, name: 'Greensboro NC', elev: 925 },
            'KAVL': { lat: 35.4362, lon: -82.5418, name: 'Asheville NC', elev: 2165 },
            'KMYR': { lat: 33.6797, lon: -78.9283, name: 'Myrtle Beach SC', elev: 25 },
            'KILM': { lat: 34.2706, lon: -77.9026, name: 'Wilmington NC', elev: 32 },
            'KRIC': { lat: 37.5052, lon: -77.3197, name: 'Richmond VA', elev: 167 },
            'KORF': { lat: 36.8946, lon: -76.2012, name: 'Norfolk VA', elev: 26 },
            'KROA': { lat: 37.3255, lon: -79.9754, name: 'Roanoke VA', elev: 1175 },
            'KCOS': { lat: 38.8058, lon: -104.7007, name: 'Colorado Springs CO', elev: 6187 },
            'KASE': { lat: 39.2232, lon: -106.8689, name: 'Aspen CO', elev: 7820 },
            'KEGE': { lat: 39.6426, lon: -106.9176, name: 'Eagle/Vail CO', elev: 6548 },
            'KGJT': { lat: 39.1224, lon: -108.5267, name: 'Grand Junction CO', elev: 4858 },
            'KRAP': { lat: 44.0453, lon: -103.0574, name: 'Rapid City SD', elev: 3204 },
            'KFSD': { lat: 43.5820, lon: -96.7419, name: 'Sioux Falls SD', elev: 1429 },
            'KJAC': { lat: 43.6073, lon: -110.7377, name: 'Jackson Hole WY', elev: 6451 },
            'KRNO': { lat: 39.4991, lon: -119.7681, name: 'Reno NV', elev: 4415 }
        };

        // Flag to track if dynamic airports have been loaded
        let dynamicAirportsLoaded = false;
        let ourAirportsLoaded = false;

        // Fetch ALL airports from OurAirports (comprehensive database including small airports)
        async function fetchOurAirports() {
            if (PERFORMANCE_MODE) return; // Disable external fetching
            if (ourAirportsLoaded) return;

            try {
                console.log('Loading comprehensive airport database from OurAirports...');

                // Fetch airports CSV from OurAirports (includes ALL airports worldwide)
                const response = await fetch('https://davidmegginson.github.io/ourairports-data/airports.csv');
                if (!response.ok) throw new Error('Failed to fetch OurAirports data');

                const csvText = await response.text();
                const lines = csvText.split('\n');
                const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());

                // Find column indices
                const idIdx = headers.indexOf('id');
                const identIdx = headers.indexOf('ident');
                const typeIdx = headers.indexOf('type');
                const nameIdx = headers.indexOf('name');
                const latIdx = headers.indexOf('latitude_deg');
                const lonIdx = headers.indexOf('longitude_deg');
                const elevIdx = headers.indexOf('elevation_ft');
                const isoCountryIdx = headers.indexOf('iso_country');
                const localCodeIdx = headers.indexOf('local_code');

                let addedCount = 0;
                let usCount = 0;

                // Parse each airport
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];
                    if (!line.trim()) continue;

                    // Parse CSV line (handle quoted fields)
                    const cols = parseCSVLine(line);
                    if (cols.length < Math.max(identIdx, latIdx, lonIdx) + 1) continue;

                    const ident = cols[identIdx]?.replace(/"/g, '').trim();
                    const type = cols[typeIdx]?.replace(/"/g, '').trim();
                    const name = cols[nameIdx]?.replace(/"/g, '').trim();
                    const lat = parseFloat(cols[latIdx]);
                    const lon = parseFloat(cols[lonIdx]);
                    const elev = parseInt(cols[elevIdx]) || 0;
                    const country = cols[isoCountryIdx]?.replace(/"/g, '').trim();
                    const localCode = cols[localCodeIdx]?.replace(/"/g, '').trim();

                    // Skip if no valid identifier or coordinates
                    if (!ident || isNaN(lat) || isNaN(lon)) continue;

                    // Skip closed airports
                    if (type === 'closed') continue;

                    // Focus on US airports (can expand later)
                    if (country !== 'US') continue;
                    usCount++;

                    // Add airport if not already in database
                    if (!AIRPORTS[ident]) {
                        AIRPORTS[ident] = {
                            lat: lat,
                            lon: lon,
                            name: name || ident,
                            elev: elev,
                            type: type // small_airport, medium_airport, large_airport, heliport, seaplane_base
                        };
                        addedCount++;

                        // Also add by local code (e.g., "SBA" for "KSBA")
                        if (localCode && !AIRPORTS[localCode]) {
                            AIRPORTS[localCode] = AIRPORTS[ident];
                        }
                    }
                }

                console.log(`OurAirports: Loaded ${addedCount} US airports (${usCount} total US entries, ${Object.keys(AIRPORTS).length} total in database)`);
                ourAirportsLoaded = true;

            } catch (error) {
                console.warn('Could not fetch OurAirports data:', error);
                // Fall back to FAA AWC
                fetchFAAairports();
            }
        }

        // Helper function to parse CSV line with quoted fields
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            return result;
        }

        // Fetch from FAA AWC (backup - only has airports with weather stations)
        async function fetchFAAairports() {
            if (PERFORMANCE_MODE) return; // Disable external fetching
            if (dynamicAirportsLoaded) return;

            try {
                const response = await fetch('https://aviationweather.gov/api/data/stationinfo?format=json');
                if (response.ok) {
                    const stations = await response.json();

                    const usStations = stations.filter(s =>
                        s.lat && s.lon && s.icaoId &&
                        (s.icaoId.startsWith('K') || s.icaoId.startsWith('PA') ||
                         s.icaoId.startsWith('PH') || s.icaoId.startsWith('PF') ||
                         s.icaoId.startsWith('PP') || s.icaoId.startsWith('PG'))
                    );

                    let addedCount = 0;
                    usStations.forEach(station => {
                        if (!AIRPORTS[station.icaoId]) {
                            AIRPORTS[station.icaoId] = {
                                lat: parseFloat(station.lat),
                                lon: parseFloat(station.lon),
                                name: station.name || station.icaoId,
                                elev: station.elev ? parseInt(station.elev) : 0
                            };
                            addedCount++;
                        }
                    });

                    console.log(`FAA AWC: Loaded ${addedCount} additional airports (total: ${Object.keys(AIRPORTS).length})`);
                    dynamicAirportsLoaded = true;
                }
            } catch (error) {
                console.warn('Could not fetch FAA airport list:', error);
            }
        }

        // Load airports on page load - try OurAirports first (comprehensive), then FAA AWC (backup)
        fetchOurAirports().then(() => {
            // Also load FAA data for any additional stations
            fetchFAAairports();
        });

        // Shorthand to ICAO mapping (allows LAX instead of KLAX, handles FAA IDs, etc.)
        function resolveAirportCode(code) {
            const upper = code.toUpperCase().trim();

            // If it's already in database, return as-is
            if (AIRPORTS[upper]) return upper;

            // Try adding K prefix for US airports (most common)
            if (AIRPORTS['K' + upper]) return 'K' + upper;

            // Try P prefix for Pacific/Alaska/Hawaii
            if (AIRPORTS['P' + upper]) return 'P' + upper;
            if (AIRPORTS['PA' + upper]) return 'PA' + upper;
            if (AIRPORTS['PH' + upper]) return 'PH' + upper;

            // Try without leading K (some people type KLAX when airport is just LAX)
            if (upper.startsWith('K') && AIRPORTS[upper.substring(1)]) {
                return upper.substring(1);
            }

            // Search by FAA identifier (3-letter codes like "SBA" instead of "KSBA")
            // OurAirports includes these as local_code entries
            for (const [icao, data] of Object.entries(AIRPORTS)) {
                if (data.localCode === upper || data.faaId === upper) {
                    return icao;
                }
            }

            // Return original (may still work if airport loads after this check)
            return upper;
        }

        // Three.js components
        let scene, camera, renderer;
        let terrainPoints, skyMesh, groundPlane;
        let oldTerrainPoints = null; // For smooth transitions
        let terrainTransitionProgress = 1; // 0 = old terrain, 1 = new terrain
        let trafficGroup, hazardsGroup, obstaclesGroup, buildingsGroup, cloudsGroup, icingGroup, visibilityGroup;
        let flightPathLine = null; // 3D flight path visualization
        let buildingsFetchController = null; // For cancelling in-flight requests

        // Flight dynamics
        let worldOffset = { x: 0, z: 0 };
        let lastFrameTime = 0;
        let lastOverlayUpdate = 0; // Track overlay updates

        // Live ADS-B Traffic
        let liveTrafficData = [];
        let lastTrafficFetch = 0;
        const TRAFFIC_REFRESH_INTERVAL = 3000; // 3 seconds between API calls
        const trafficMeshPool = new Map(); // hex -> mesh for pooling
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // ============================================
        // INITIALIZATION
        // ============================================

        // Performance mode - disable all external API fetching
        const PERFORMANCE_MODE = true;

        async function init() {
            setupThreeJS();
            setupControls();
            setupOverlayToggles();
            setupSimulationControls();
            setupPanelControls();
            generateCompassDial();

            // Minimize panels on startup for clean display
            minimizeDebugPanel();
            document.getElementById('svsControls').classList.add('minimized');

            if (!PERFORMANCE_MODE) {
                // Load initial terrain
                await loadTerrainData(state.position.lat, state.position.lon);

                // Fetch initial wind data for current position
                const initialWind = await fetchWindData(state.position.lat, state.position.lon);
                if (initialWind) {
                    state.windSpeed = initialWind.speed;
                    state.windDirection = initialWind.direction;
                }

                // Create initial overlay visuals (will be empty if disabled)
                createSimulatedTraffic();
                createSimulatedHazards();
                createSimulatedObstacles();

                // Initialize clouds and icing (enabled by default)
                if (state.overlays.clouds) {
                    updateCloudsOverlay();
                }
                if (state.overlays.icing) {
                    updateIcingOverlay();
                }
            } else {
                // Performance mode: create simple static ground plane
                createSimpleGround();
            }

            // Start render loop
            animate();

            // Hide loading overlay
            setTimeout(() => {
                document.getElementById('loadingOverlay').classList.add('hidden');
            }, 500);
        }

        function createSimpleGround() {
            // Simple flat ground plane for performance mode
            const groundGeometry = new THREE.PlaneGeometry(500000, 500000);
            const groundMaterial = new THREE.MeshBasicMaterial({
                color: 0x3d5c3d,  // Ground green
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            scene.add(ground);
        }

        function setupThreeJS() {
            const canvas = document.getElementById('svs-canvas');

            // Scene
            scene = new THREE.Scene();

            // Camera (pilot's perspective)
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 500000);
            camera.position.set(0, state.altitude * 0.3048, 0); // Convert feet to meters
            scene.add(camera); // Add camera to scene so its children (flight path) render

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas,
                antialias: false,  // Disable for better GPU performance
                powerPreference: "high-performance",  // Request dedicated GPU
                precision: "mediump",  // Medium precision for speed
                stencil: false,
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1);  // Fixed pixel ratio for consistent GPU performance
            // Set clear color based on theme (light mode is default)
            const isLightMode = document.documentElement.classList.contains('light-mode');
            renderer.setClearColor(isLightMode ? 0xf5f5f5 : 0x0a0a0a);
            renderer.sortObjects = false;  // Disable sorting for speed

            // Groups
            trafficGroup = new THREE.Group();
            hazardsGroup = new THREE.Group();
            obstaclesGroup = new THREE.Group();
            buildingsGroup = new THREE.Group();
            cloudsGroup = new THREE.Group();
            icingGroup = new THREE.Group();
            visibilityGroup = new THREE.Group();

            // In performance mode, don't add traffic/hazards/obstacles/buildings
            if (!PERFORMANCE_MODE) {
                scene.add(trafficGroup);
                scene.add(hazardsGroup);
                scene.add(obstaclesGroup);
                scene.add(buildingsGroup);
                scene.add(cloudsGroup);
                scene.add(icingGroup);
                scene.add(visibilityGroup);
            }

            // Create sky gradient
            createSkyGradient();

            // Handle resize
            window.addEventListener('resize', onWindowResize);

            // Handle click on canvas for aircraft selection
            document.getElementById('svs-canvas').addEventListener('click', onCanvasClick);
        }

        function createSkyGradient() {
            // Sky dome using hemisphere gradient
            const isLightMode = document.documentElement.classList.contains('light-mode');
            const skyGeo = new THREE.SphereGeometry(200000, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(isLightMode ? 0xbfdbfe : 0x1a365d) },
                    bottomColor: { value: new THREE.Color(isLightMode ? 0xfcd34d : 0x78350f) },
                    offset: { value: 0 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });

            skyMesh = new THREE.Mesh(skyGeo, skyMat);
            scene.add(skyMesh);
        }

        // ============================================
        // TERRAIN SYSTEM
        // ============================================

        async function loadTerrainData(lat, lon) {
            if (PERFORMANCE_MODE) return; // Disable all external fetching
            try {
                // Reset world offset when loading new terrain
                worldOffset = { x: 0, z: 0 };

                const gridSize = 80; // Reduced for better performance on embedded systems
                const radiusNM = 35; // Original radius
                const degreesPerNM = 1 / 60;
                const span = radiusNM * 2 * degreesPerNM;
                const step = span / gridSize;

                // Offset center forward in direction of heading - more terrain ahead
                const headingRad = state.heading * Math.PI / 180;
                const forwardOffsetNM = 20; // Forward offset (~45nm visible ahead)
                const forwardOffsetDeg = forwardOffsetNM * degreesPerNM;
                const offsetLat = lat + Math.cos(headingRad) * forwardOffsetDeg;
                const offsetLon = lon + Math.sin(headingRad) * forwardOffsetDeg / Math.cos(lat * Math.PI / 180);

                const lats = [];
                const lons = [];

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        lats.push((offsetLat - span/2 + y * step).toFixed(5));
                        lons.push((offsetLon - span/2 + x * step).toFixed(5));
                    }
                }

                // Fetch elevation data from Open-Meteo API (batched)
                const elevations = [];
                const batchSize = 1000;

                // Show loading state
                if (terrainPoints) {
                    terrainPoints.material.opacity = 0.5;
                }

                for (let i = 0; i < lats.length; i += batchSize) {
                    const batchLats = lats.slice(i, i + batchSize);
                    const batchLons = lons.slice(i, i + batchSize);

                    const url = `https://api.open-meteo.com/v1/elevation?latitude=${batchLats.join(',')}&longitude=${batchLons.join(',')}`;
                    const response = await fetch(url);
                    const data = await response.json();

                    if (data.elevation) {
                        elevations.push(...data.elevation);
                    }
                }

                console.log(`Terrain API returned ${elevations.length} elevation points`);

                state.terrainData = {
                    elevations,
                    gridSize,
                    span,
                    centerLat: lat,
                    centerLon: lon,
                    lats,
                    lons
                };

                console.log(`Creating terrain point cloud... gridSize=${gridSize}, expected points=${(gridSize-1)*5+1}^2`);
                createTerrainPointCloud();
                updateInfoDisplay();

            } catch (error) {
                console.error('Failed to load terrain:', error);
                // Generate procedural terrain as fallback
                generateProceduralTerrain();
            }
        }

        function generateProceduralTerrain() {
            const gridSize = 64;
            const elevations = [];

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    // Simple noise-based terrain
                    const nx = x / gridSize - 0.5;
                    const ny = y / gridSize - 0.5;
                    const dist = Math.sqrt(nx * nx + ny * ny);
                    const elevation = Math.sin(nx * 10) * Math.cos(ny * 10) * 500 +
                                     Math.sin(nx * 5 + ny * 3) * 300 +
                                     (1 - dist) * 200;
                    elevations.push(Math.max(0, elevation));
                }
            }

            state.terrainData = {
                elevations,
                gridSize,
                span: 50 / 60, // ~50nm span
                centerLat: state.position.lat,
                centerLon: state.position.lon
            };

            createTerrainPointCloud();
        }

        // Create circular texture for point sprites (circles instead of squares)
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Create radial gradient for soft-edged circle
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(32, 32, 32, 0, Math.PI * 2);
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function createTerrainPointCloud() {
            // Move current terrain to old for smooth transition
            if (terrainPoints) {
                // Clean up previous old terrain if exists
                if (oldTerrainPoints) {
                    scene.remove(oldTerrainPoints);
                    oldTerrainPoints.geometry.dispose();
                    oldTerrainPoints.material.dispose();
                }
                // Current becomes old
                oldTerrainPoints = terrainPoints;
                oldTerrainPoints.material.transparent = true;
                terrainTransitionProgress = 0; // Start transition
            }

            if (!state.terrainData) return;

            const { elevations, gridSize, span } = state.terrainData;

            // Create denser point cloud by interpolating between grid points
            const densityMultiplier = 8; // 8x denser (higher base resolution means less interpolation needed)
            const denseSize = (gridSize - 1) * densityMultiplier + 1;
            const totalPoints = denseSize * denseSize;

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(totalPoints * 3);
            const colors = new Float32Array(totalPoints * 3);

            const metersPerDegree = 111000;
            const spanMeters = span * metersPerDegree;
            const stepMeters = spanMeters / gridSize;
            const denseStepMeters = stepMeters / densityMultiplier;
            const ftToMeters = 0.3048;
            const aircraftAltMeters = state.altitude * ftToMeters;

            // Calculate forward offset in meters (terrain is generated ahead)
            const forwardOffsetMeters = 20 * 1852; // 20nm in meters (matches terrain forward offset)

            // Get reference ground elevation at ACTUAL aircraft position
            // Grid center is forwardOffsetNM AHEAD of the aircraft.
            // So the aircraft is BEHIND the grid center by forwardOffsetNM.
            // Grid rows go 0 (back) to gridSize-1 (front), center is gridSize/2.
            // Aircraft position = center - offset (not + offset!)
            const forwardOffsetNM = 20;
            const radiusNM = 35;
            const spanNM = radiusNM * 2;
            const aircraftRowOffset = (forwardOffsetNM / spanNM) * gridSize;
            // SUBTRACT offset because aircraft is BEHIND the grid center
            const aircraftRow = Math.max(Math.floor(gridSize / 2 - aircraftRowOffset), 0);
            const aircraftCol = Math.floor(gridSize / 2);
            const aircraftIdx = aircraftRow * gridSize + aircraftCol;
            const referenceGroundLevel = elevations[aircraftIdx] || elevations[Math.floor(elevations.length / 2)] || 0;

            // Additional offset to lower terrain (fixes visual height issue)
            const terrainLowerOffset = 120; // meters to push terrain down

            // Store reference for other systems (visibility, camera, etc.)
            state.referenceGroundLevel = referenceGroundLevel;
            state.terrainLowerOffset = terrainLowerOffset;
            console.log(`Reference ground level: ${referenceGroundLevel}m at grid pos (${aircraftRow}, ${aircraftCol}), idx ${aircraftIdx}`);

            let maxElevation = 0;
            let pointIndex = 0;

            // Bilinear interpolation helper
            function getInterpolatedElevation(gx, gy) {
                const x0 = Math.floor(gx);
                const y0 = Math.floor(gy);
                const x1 = Math.min(x0 + 1, gridSize - 1);
                const y1 = Math.min(y0 + 1, gridSize - 1);

                const fx = gx - x0;
                const fy = gy - y0;

                const e00 = elevations[y0 * gridSize + x0] || 0;
                const e10 = elevations[y0 * gridSize + x1] || 0;
                const e01 = elevations[y1 * gridSize + x0] || 0;
                const e11 = elevations[y1 * gridSize + x1] || 0;

                return e00 * (1 - fx) * (1 - fy) +
                       e10 * fx * (1 - fy) +
                       e01 * (1 - fx) * fy +
                       e11 * fx * fy;
            }

            // Rotate terrain to align with heading (terrain grid is lat/lon aligned, camera rotates by heading)
            const headingRad = THREE.MathUtils.degToRad(state.heading);
            const cosH = Math.cos(headingRad);
            const sinH = Math.sin(headingRad);

            for (let dy = 0; dy < denseSize; dy++) {
                for (let dx = 0; dx < denseSize; dx++) {
                    const gx = dx / densityMultiplier;
                    const gy = dy / densityMultiplier;

                    const elevation = getInterpolatedElevation(gx, gy);

                    // Position in grid-aligned coordinates (lat/lon orientation)
                    const gridX = dx - denseSize / 2;
                    const gridZ = dy - denseSize / 2;

                    // Grid coordinates before rotation (north-south/east-west aligned)
                    const rawX = gridX * denseStepMeters;  // East-west
                    const rawZ = -gridZ * denseStepMeters; // North-south (negated: north = positive)

                    // Rotate by heading to align terrain with camera view direction
                    const x = rawX * cosH + rawZ * sinH;
                    const z = -rawX * sinH + rawZ * cosH - forwardOffsetMeters;
                    // Position Y relative to reference ground level, with additional lowering offset
                    const y = elevation - referenceGroundLevel - terrainLowerOffset;

                    maxElevation = Math.max(maxElevation, elevation); // Track absolute max for display

                    positions[pointIndex * 3] = x;
                    positions[pointIndex * 3 + 1] = y;
                    positions[pointIndex * 3 + 2] = z;

                    // Enhanced color based on clearance and elevation
                    // Use absolute elevation for clearance, not relative Y position
                    const clearance = aircraftAltMeters - elevation;
                    const clearanceFt = clearance / ftToMeters;
                    const dist = Math.sqrt(x * x + z * z);
                    const distFade = Math.max(0.3, 1 - dist / (spanMeters * 0.7));

                    // During ground operations (< 500ft AGL), use neutral coloring
                    // This avoids confusing red terrain while taxiing
                    const isGroundOps = state.altitude < 1500 || (state.groundSpeed < 60 && state.verticalSpeed < 100);

                    if (isGroundOps) {
                        // Neutral gray/white terrain during taxi and low altitude
                        const elevGradient = Math.min(1, elevation / 3000);
                        colors[pointIndex * 3] = (0.5 + elevGradient * 0.3) * distFade;
                        colors[pointIndex * 3 + 1] = (0.55 + elevGradient * 0.25) * distFade;
                        colors[pointIndex * 3 + 2] = (0.6 + elevGradient * 0.2) * distFade;
                    } else if (clearanceFt < 300) {
                        // Bright red - immediate danger
                        colors[pointIndex * 3] = 1.0;
                        colors[pointIndex * 3 + 1] = 0.15;
                        colors[pointIndex * 3 + 2] = 0.15;
                    } else if (clearanceFt < 500) {
                        // Red - danger
                        colors[pointIndex * 3] = 0.94 * distFade;
                        colors[pointIndex * 3 + 1] = 0.27 * distFade;
                        colors[pointIndex * 3 + 2] = 0.27 * distFade;
                    } else if (clearanceFt < 750) {
                        // Orange - high caution
                        colors[pointIndex * 3] = 0.96 * distFade;
                        colors[pointIndex * 3 + 1] = 0.45 * distFade;
                        colors[pointIndex * 3 + 2] = 0.1 * distFade;
                    } else if (clearanceFt < 1000) {
                        // Yellow - caution
                        colors[pointIndex * 3] = 0.96 * distFade;
                        colors[pointIndex * 3 + 1] = 0.75 * distFade;
                        colors[pointIndex * 3 + 2] = 0.1 * distFade;
                    } else if (clearanceFt < 2000) {
                        // Light yellow/green transition
                        const t = (clearanceFt - 1000) / 1000;
                        colors[pointIndex * 3] = (0.7 - t * 0.4) * distFade;
                        colors[pointIndex * 3 + 1] = (0.75 + t * 0.15) * distFade;
                        colors[pointIndex * 3 + 2] = (0.2 + t * 0.1) * distFade;
                    } else {
                        // White/cyan tint for safe terrain with elevation gradient
                        const elevGradient = Math.min(1, elevation / 3000); // Gradient based on absolute elevation
                        colors[pointIndex * 3] = (0.85 + elevGradient * 0.15) * distFade;
                        colors[pointIndex * 3 + 1] = (0.9 + elevGradient * 0.1) * distFade;
                        colors[pointIndex * 3 + 2] = (0.95) * distFade;
                    }

                    pointIndex++;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Create circular point texture for smooth dots instead of squares
            const circleTexture = createCircleTexture();

            // Dynamic point size based on altitude - smaller at low altitude, larger at high
            const altAGL = Math.max(0, state.altitude - (state.terrainData?.elevations?.[Math.floor(state.terrainData.elevations.length/2)] / 0.3048 || 0));
            const baseSize = Math.min(80, Math.max(20, altAGL / 100)); // 20-80 range based on altitude

            const material = new THREE.PointsMaterial({
                size: baseSize,
                vertexColors: true,
                transparent: true,
                opacity: oldTerrainPoints ? 0 : 0.95,
                sizeAttenuation: true,
                map: circleTexture,
                alphaMap: circleTexture,
                alphaTest: 0.01
            });

            terrainPoints = new THREE.Points(geometry, material);
            terrainPoints.visible = state.overlays.terrain;
            scene.add(terrainPoints);
            console.log(`Terrain point cloud created: ${totalPoints} points, visible=${terrainPoints.visible}`);

            // If no old terrain, mark transition complete immediately
            if (!oldTerrainPoints) {
                terrainTransitionProgress = 1;
            }

            // Create/update ground floor mesh (shows mean ground level)
            updateGroundFloorMesh(maxElevation);

            // Update ground level display
            const groundLevel = maxElevation / ftToMeters;
            document.getElementById('infoGround').textContent = Math.round(groundLevel).toLocaleString() + ' ft';
        }

        // Track last altitude for color update optimization
        let lastColorUpdateAlt = 0;

        function updateTerrainColors() {
            // Dynamically update terrain point colors based on current altitude
            // This fixes the bug where colors were frozen at load time
            try {
                if (!terrainPoints || !terrainPoints.geometry) return;
                if (!terrainPoints.geometry.attributes.color) return;
                if (!terrainPoints.geometry.attributes.position) return;
                if (!state.terrainData || !state.terrainData.span) return;

                // Only update if altitude changed significantly (>50ft)
                const altDiff = Math.abs(state.altitude - lastColorUpdateAlt);
                if (altDiff < 50) return;
                lastColorUpdateAlt = state.altitude;

                const colors = terrainPoints.geometry.attributes.color.array;
                const positions = terrainPoints.geometry.attributes.position.array;
                if (!colors || !positions) return;
                const numPoints = positions.length / 3;

                const ftToMeters = 0.3048;
                const aircraftAltMeters = state.altitude * ftToMeters;
                const metersPerDegree = 111000;
                const spanMeters = state.terrainData.span * metersPerDegree;
                const refGround = state.referenceGroundLevel || 0;

                const isGroundOps = state.altitude < 1500 || (state.groundSpeed < 60 && state.verticalSpeed < 100);

                for (let i = 0; i < numPoints; i++) {
                    const x = positions[i * 3];
                    const relativeY = positions[i * 3 + 1]; // relative terrain position
                    const z = positions[i * 3 + 2];

                    // Convert relative Y back to absolute elevation for clearance calc
                    const absoluteElevation = relativeY + refGround;
                    const clearance = aircraftAltMeters - absoluteElevation;
                    const clearanceFt = clearance / ftToMeters;
                    const dist = Math.sqrt(x * x + z * z);
                    const distFade = Math.max(0.3, 1 - dist / (spanMeters * 0.7));

                    if (isGroundOps) {
                        // Neutral gray/white during ground ops
                        const elevGradient = Math.min(1, absoluteElevation / 3000);
                        colors[i * 3] = (0.5 + elevGradient * 0.3) * distFade;
                        colors[i * 3 + 1] = (0.55 + elevGradient * 0.25) * distFade;
                        colors[i * 3 + 2] = (0.6 + elevGradient * 0.2) * distFade;
                    } else if (clearanceFt < 300) {
                        // Bright red - immediate danger
                        colors[i * 3] = 1.0;
                        colors[i * 3 + 1] = 0.15;
                        colors[i * 3 + 2] = 0.15;
                    } else if (clearanceFt < 500) {
                        // Red - danger
                        colors[i * 3] = 0.94 * distFade;
                        colors[i * 3 + 1] = 0.27 * distFade;
                        colors[i * 3 + 2] = 0.27 * distFade;
                    } else if (clearanceFt < 750) {
                        // Orange - high caution
                        colors[i * 3] = 0.96 * distFade;
                        colors[i * 3 + 1] = 0.45 * distFade;
                        colors[i * 3 + 2] = 0.1 * distFade;
                    } else if (clearanceFt < 1000) {
                        // Yellow - caution
                        colors[i * 3] = 0.96 * distFade;
                        colors[i * 3 + 1] = 0.75 * distFade;
                        colors[i * 3 + 2] = 0.1 * distFade;
                    } else if (clearanceFt < 2000) {
                        // Yellow-green transition
                        const t = (clearanceFt - 1000) / 1000;
                        colors[i * 3] = (0.7 - t * 0.4) * distFade;
                        colors[i * 3 + 1] = (0.75 + t * 0.15) * distFade;
                        colors[i * 3 + 2] = (0.2 + t * 0.1) * distFade;
                    } else {
                        // White/cyan - safe
                        const elevGradient = Math.min(1, absoluteElevation / 3000);
                        colors[i * 3] = (0.85 + elevGradient * 0.15) * distFade;
                        colors[i * 3 + 1] = (0.9 + elevGradient * 0.1) * distFade;
                        colors[i * 3 + 2] = 0.95 * distFade;
                    }
                }

                terrainPoints.geometry.attributes.color.needsUpdate = true;
            } catch (e) {
                console.error('Error updating terrain colors:', e);
            }
        }

        function updateGroundFloorMesh(groundElevationMeters) {
            // Remove existing ground plane
            if (groundPlane) {
                scene.remove(groundPlane);
                groundPlane.geometry.dispose();
                groundPlane.material.dispose();
                groundPlane = null;
            }

            // Get average ground elevation from terrain data
            let avgElevation = groundElevationMeters;
            if (state.terrainData && state.terrainData.elevations && state.terrainData.elevations.length > 0) {
                const elevations = state.terrainData.elevations;
                const sum = elevations.reduce((a, b) => a + b, 0);
                avgElevation = sum / elevations.length;
            }

            const isLightMode = document.documentElement.classList.contains('light-mode');

            // Create a large ground plane at the average elevation
            const planeSize = 300000; // Large enough to extend to horizon
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize, 32, 32);

            // Create gradient material - darker near camera, fading to horizon
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: isLightMode ? 0x3d5c3d : 0x1a2e1a, // Muted green/brown
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            groundPlane.rotation.x = -Math.PI / 2; // Make horizontal
            // Position relative to reference ground level (0 = aircraft's ground level)
            const refGround = state.referenceGroundLevel || 0;
            const lowerOffset = state.terrainLowerOffset || 15;
            groundPlane.position.y = avgElevation - refGround - lowerOffset; // Relative to reference
            groundPlane.position.z = -50000; // Offset forward

            scene.add(groundPlane);
        }

        // ============================================
        // TRAFFIC & HAZARDS
        // ============================================

        function createAircraftShape() {
            // Create a more detailed aircraft silhouette
            const shape = new THREE.Shape();

            // Fuselage
            shape.moveTo(0, 200);
            shape.lineTo(30, 150);
            shape.lineTo(40, 50);
            shape.lineTo(40, -100);
            shape.lineTo(20, -200);
            shape.lineTo(-20, -200);
            shape.lineTo(-40, -100);
            shape.lineTo(-40, 50);
            shape.lineTo(-30, 150);
            shape.lineTo(0, 200);

            return shape;
        }

        // ============================================
        // LIVE ADS-B TRAFFIC SYSTEM
        // ============================================

        async function fetchLiveTraffic(lat, lon, radiusNm = 30) {
            try {
                // Use backend proxy to avoid CORS issues
                const url = `/api/aviation/adsb?lat=${lat}&lon=${lon}&dist=${radiusNm}`;
                const response = await fetch(url);
                if (!response.ok) {
                    console.warn('ADS-B fetch failed:', response.status);
                    return [];
                }
                const data = await response.json();
                if (data.error) {
                    console.warn('ADS-B API error:', data.error);
                }
                console.log(`ADS-B: ${data.total || 0} aircraft in range`);
                return data.ac || [];
            } catch (error) {
                console.warn('ADS-B fetch error:', error);
                return [];
            }
        }

        function getAircraftSize(category) {
            // Aircraft category to mesh size mapping (realistic scale for scene)
            const sizes = {
                'A1': 8,    // Light (Cessna, etc)
                'A2': 12,   // Small (regional jets)
                'A3': 18,   // Large (737, A320)
                'A4': 18,   // High vortex large
                'A5': 25,   // Heavy (747, A380)
                'A6': 25,   // High performance
                'A7': 10,   // Rotorcraft
                'B1': 6,    // Glider
                'B2': 6,    // Lighter than air
                'B4': 4,    // Ultralight
                'B6': 4,    // UAV
                'C1': 6,    // Surface emergency
                'C2': 6,    // Surface service
            };
            return sizes[category] || 12; // Default to small aircraft
        }

        function createAircraftMesh(category) {
            const group = new THREE.Group();
            const size = getAircraftSize(category);
            const isHeli = category === 'A7' || category === 'B1';
            const isLight = category === 'A1' || category === 'B4' || category === 'B6';
            const isHeavy = category === 'A5' || category === 'A6';
            const isJet = category === 'A2' || category === 'A3' || category === 'A4' || isHeavy;

            // Material - white with slight glow
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.95
            });

            const accentMat = new THREE.MeshBasicMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.6
            });

            if (isHeli) {
                // Helicopter - teardrop fuselage + tail boom + rotor
                const fuselageShape = new THREE.Shape();
                fuselageShape.moveTo(0, 0);
                fuselageShape.quadraticCurveTo(size * 0.4, size * 0.3, size * 0.3, 0);
                fuselageShape.quadraticCurveTo(size * 0.4, -size * 0.2, 0, -size * 0.15);
                fuselageShape.quadraticCurveTo(-size * 0.2, -size * 0.1, 0, 0);

                const fuselageGeo = new THREE.ExtrudeGeometry(fuselageShape, {
                    depth: size * 0.25,
                    bevelEnabled: false
                });
                const fuselage = new THREE.Mesh(fuselageGeo, material);
                fuselage.rotation.y = Math.PI / 2;
                fuselage.position.set(0, 0, -size * 0.1);

                // Tail boom
                const tailBoom = new THREE.Mesh(
                    new THREE.CylinderGeometry(size * 0.03, size * 0.05, size * 0.8, 6),
                    material
                );
                tailBoom.rotation.x = Math.PI / 2;
                tailBoom.position.z = size * 0.5;

                // Main rotor disc
                const rotor = new THREE.Mesh(
                    new THREE.RingGeometry(size * 0.1, size * 0.55, 24),
                    new THREE.MeshBasicMaterial({ color: 0xaaddff, transparent: true, opacity: 0.25, side: THREE.DoubleSide })
                );
                rotor.rotation.x = -Math.PI / 2;
                rotor.position.y = size * 0.15;

                // Tail rotor
                const tailRotor = new THREE.Mesh(
                    new THREE.CircleGeometry(size * 0.12, 12),
                    new THREE.MeshBasicMaterial({ color: 0xaaddff, transparent: true, opacity: 0.3, side: THREE.DoubleSide })
                );
                tailRotor.rotation.y = Math.PI / 2;
                tailRotor.position.set(size * 0.08, size * 0.05, size * 0.85);

                group.add(fuselage, tailBoom, rotor, tailRotor);

            } else if (isLight) {
                // Light aircraft (Cessna-style) - high wing, straight
                // Fuselage - tapered cylinder
                const fuselageGeo = new THREE.CylinderGeometry(size * 0.08, size * 0.1, size * 1.4, 8);
                const fuselage = new THREE.Mesh(fuselageGeo, material);
                fuselage.rotation.x = Math.PI / 2;

                // Nose cone
                const nose = new THREE.Mesh(
                    new THREE.ConeGeometry(size * 0.08, size * 0.25, 8),
                    material
                );
                nose.rotation.x = -Math.PI / 2;
                nose.position.z = -size * 0.8;

                // High straight wings
                const wingGeo = createWingGeometry(size * 1.4, size * 0.25, 0, size * 0.02);
                const wingL = new THREE.Mesh(wingGeo, material);
                wingL.position.set(-size * 0.08, size * 0.1, -size * 0.1);
                const wingR = new THREE.Mesh(wingGeo, material);
                wingR.scale.x = -1;
                wingR.position.set(size * 0.08, size * 0.1, -size * 0.1);

                // Tail
                const tailV = new THREE.Mesh(
                    new THREE.BoxGeometry(size * 0.02, size * 0.25, size * 0.2),
                    material
                );
                tailV.position.set(0, size * 0.15, size * 0.6);

                const tailH = new THREE.Mesh(
                    new THREE.BoxGeometry(size * 0.5, size * 0.02, size * 0.12),
                    material
                );
                tailH.position.set(0, size * 0.05, size * 0.6);

                group.add(fuselage, nose, wingL, wingR, tailV, tailH);

            } else if (isJet) {
                // Jet aircraft - swept wings, proper fuselage
                const fuselageLength = isHeavy ? size * 2.2 : size * 1.8;
                const fuselageRadius = isHeavy ? size * 0.12 : size * 0.09;

                // Fuselage - smooth tapered cylinder
                const fuselageGeo = new THREE.CylinderGeometry(fuselageRadius * 0.7, fuselageRadius, fuselageLength, 12);
                const fuselage = new THREE.Mesh(fuselageGeo, material);
                fuselage.rotation.x = Math.PI / 2;

                // Nose cone - smooth
                const nose = new THREE.Mesh(
                    new THREE.ConeGeometry(fuselageRadius * 0.7, size * 0.35, 12),
                    material
                );
                nose.rotation.x = -Math.PI / 2;
                nose.position.z = -fuselageLength / 2 - size * 0.15;

                // Swept wings
                const wingSpan = isHeavy ? size * 1.8 : size * 1.4;
                const sweepAngle = isHeavy ? 35 : 28; // degrees
                const wingGeo = createWingGeometry(wingSpan, size * 0.35, sweepAngle, size * 0.025);

                const wingL = new THREE.Mesh(wingGeo, material);
                wingL.position.set(-fuselageRadius * 0.5, 0, size * 0.1);
                const wingR = new THREE.Mesh(wingGeo, material);
                wingR.scale.x = -1;
                wingR.position.set(fuselageRadius * 0.5, 0, size * 0.1);

                // Tail fin (swept)
                const tailFinShape = new THREE.Shape();
                tailFinShape.moveTo(0, 0);
                tailFinShape.lineTo(size * 0.15, size * 0.35);
                tailFinShape.lineTo(size * 0.25, size * 0.35);
                tailFinShape.lineTo(size * 0.12, 0);
                tailFinShape.lineTo(0, 0);

                const tailFinGeo = new THREE.ExtrudeGeometry(tailFinShape, { depth: size * 0.015, bevelEnabled: false });
                const tailFin = new THREE.Mesh(tailFinGeo, material);
                tailFin.rotation.y = Math.PI / 2;
                tailFin.position.set(-size * 0.007, 0, fuselageLength / 2 - size * 0.15);

                // Horizontal stabilizer (swept)
                const hstabGeo = createWingGeometry(size * 0.45, size * 0.15, 30, size * 0.015);
                const hstabL = new THREE.Mesh(hstabGeo, material);
                hstabL.position.set(-fuselageRadius * 0.3, size * 0.02, fuselageLength / 2 - size * 0.1);
                const hstabR = new THREE.Mesh(hstabGeo, material);
                hstabR.scale.x = -1;
                hstabR.position.set(fuselageRadius * 0.3, size * 0.02, fuselageLength / 2 - size * 0.1);

                group.add(fuselage, nose, wingL, wingR, tailFin, hstabL, hstabR);

                // Engines
                if (isHeavy) {
                    // 4-engine heavy (747-style) - engines under wings
                    const positions = [
                        [-size * 0.35, -size * 0.08, size * 0.05],
                        [-size * 0.65, -size * 0.1, size * 0.15],
                        [size * 0.35, -size * 0.08, size * 0.05],
                        [size * 0.65, -size * 0.1, size * 0.15]
                    ];
                    positions.forEach(pos => {
                        const engine = createEngineNacelle(size * 0.06, size * 0.25);
                        engine.position.set(...pos);
                        group.add(engine);
                    });
                } else {
                    // Twin engine (737/A320-style)
                    const engineL = createEngineNacelle(size * 0.07, size * 0.28);
                    engineL.position.set(-size * 0.4, -size * 0.08, size * 0.1);
                    const engineR = createEngineNacelle(size * 0.07, size * 0.28);
                    engineR.position.set(size * 0.4, -size * 0.08, size * 0.1);
                    group.add(engineL, engineR);
                }
            } else {
                // Default turboprop style
                const fuselageGeo = new THREE.CylinderGeometry(size * 0.08, size * 0.1, size * 1.5, 8);
                const fuselage = new THREE.Mesh(fuselageGeo, material);
                fuselage.rotation.x = Math.PI / 2;

                const nose = new THREE.Mesh(
                    new THREE.SphereGeometry(size * 0.08, 8, 6),
                    material
                );
                nose.position.z = -size * 0.75;

                // Straight wings
                const wingGeo = createWingGeometry(size * 1.2, size * 0.28, 5, size * 0.02);
                const wingL = new THREE.Mesh(wingGeo, material);
                wingL.position.set(-size * 0.08, 0, 0);
                const wingR = new THREE.Mesh(wingGeo, material);
                wingR.scale.x = -1;
                wingR.position.set(size * 0.08, 0, 0);

                // T-tail
                const tailV = new THREE.Mesh(
                    new THREE.BoxGeometry(size * 0.02, size * 0.3, size * 0.18),
                    material
                );
                tailV.position.set(0, size * 0.15, size * 0.65);

                const tailH = new THREE.Mesh(
                    new THREE.BoxGeometry(size * 0.45, size * 0.02, size * 0.1),
                    material
                );
                tailH.position.set(0, size * 0.3, size * 0.65);

                group.add(fuselage, nose, wingL, wingR, tailV, tailH);
            }

            // Helper function for swept wing geometry
            function createWingGeometry(span, chord, sweepDeg, thickness) {
                const shape = new THREE.Shape();
                const sweep = Math.tan(sweepDeg * Math.PI / 180) * span;

                // Wing shape in XY plane (will be rotated to XZ)
                // X = spanwise (outward from fuselage)
                // Y = chordwise (front to back, positive = back)
                shape.moveTo(0, -chord * 0.6);           // Root leading edge
                shape.lineTo(span, sweep - chord * 0.3); // Tip leading edge (swept back)
                shape.lineTo(span, sweep + chord * 0.3); // Tip trailing edge
                shape.lineTo(0, chord * 0.4);            // Root trailing edge
                shape.lineTo(0, -chord * 0.6);           // Close

                const geo = new THREE.ExtrudeGeometry(shape, {
                    depth: thickness,
                    bevelEnabled: false
                });

                // Rotate: first around X to lay flat, then around Z to flip chord direction
                geo.rotateX(-Math.PI / 2);  // Lay flat in XZ plane
                geo.rotateY(Math.PI);       // Flip so leading edge faces forward (-Z)

                return geo;
            }

            // Helper function for engine nacelle
            function createEngineNacelle(radius, length) {
                const engineGroup = new THREE.Group();
                const nacelle = new THREE.Mesh(
                    new THREE.CylinderGeometry(radius, radius * 0.85, length, 10),
                    material
                );
                nacelle.rotation.x = Math.PI / 2;

                // Intake ring
                const intake = new THREE.Mesh(
                    new THREE.TorusGeometry(radius, radius * 0.15, 6, 12),
                    accentMat
                );
                intake.rotation.y = Math.PI / 2;
                intake.position.z = -length / 2;

                engineGroup.add(nacelle, intake);
                return engineGroup;
            }

            // Add direction ribbon trail ahead of aircraft
            const ribbonLength = size * 4;
            const ribbonWidth = size * 0.15;
            const ribbonSegments = 8;

            // Create ribbon geometry (tapered ribbon pointing forward)
            const ribbonGeometry = new THREE.BufferGeometry();
            const ribbonVertices = [];
            const ribbonColors = [];

            for (let i = 0; i <= ribbonSegments; i++) {
                const t = i / ribbonSegments;
                const z = -t * ribbonLength;  // Extends forward (negative z)
                const width = ribbonWidth * (1 - t * 0.8);  // Tapers toward front

                // Left and right edge vertices
                ribbonVertices.push(-width, 0, z);
                ribbonVertices.push(width, 0, z);

                // Color fades from cyan to transparent
                const alpha = 1 - t;
                ribbonColors.push(0, 0.83, 1, alpha);  // Cyan
                ribbonColors.push(0, 0.83, 1, alpha);
            }

            // Create triangle indices for ribbon
            const ribbonIndices = [];
            for (let i = 0; i < ribbonSegments; i++) {
                const base = i * 2;
                ribbonIndices.push(base, base + 1, base + 2);
                ribbonIndices.push(base + 1, base + 3, base + 2);
            }

            ribbonGeometry.setAttribute('position', new THREE.Float32BufferAttribute(ribbonVertices, 3));
            ribbonGeometry.setAttribute('color', new THREE.Float32BufferAttribute(ribbonColors, 4));
            ribbonGeometry.setIndex(ribbonIndices);

            const ribbonMaterial = new THREE.MeshBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const ribbon = new THREE.Mesh(ribbonGeometry, ribbonMaterial);
            group.add(ribbon);

            return group;
        }

        function aircraftToScenePosition(aircraft) {
            // Convert aircraft lat/lon to scene-relative coordinates
            const distNm = calculateDistance(
                state.position.lat, state.position.lon,
                aircraft.lat, aircraft.lon
            );
            const bearing = calculateBearing(
                state.position.lat, state.position.lon,
                aircraft.lat, aircraft.lon
            );

            // Relative bearing from own aircraft heading
            const relBearing = (bearing - state.heading + 360) % 360;
            const relBearingRad = relBearing * Math.PI / 180;

            // Convert to scene units - scale down for visibility
            // 1nm = 200 scene units (same as terrain forward motion)
            const sceneScale = 200;
            const distSceneUnits = distNm * sceneScale;

            // Scene coordinates (x = right, z = forward negative, y = up)
            const x = Math.sin(relBearingRad) * distSceneUnits;
            const z = -Math.cos(relBearingRad) * distSceneUnits;

            // Altitude difference - scale to match scene
            // Scene uses roughly 1 unit = 10 feet for terrain
            const ownAltFt = state.altitude;
            const acAltFt = aircraft.alt_baro || aircraft.alt_geom || 0;
            const altDiffFt = acAltFt - ownAltFt;
            const y = altDiffFt * 0.1;  // Scale altitude difference

            return { x, y, z };
        }

        async function updateLiveTraffic() {
            if (PERFORMANCE_MODE) return;
            if (!state.overlays.traffic) return;

            const now = performance.now();
            if (now - lastTrafficFetch < TRAFFIC_REFRESH_INTERVAL) {
                // Just update positions smoothly between fetches
                renderLiveTraffic();
                return;
            }
            lastTrafficFetch = now;

            // Fetch new traffic data
            const newTraffic = await fetchLiveTraffic(
                state.position.lat,
                state.position.lon,
                30 // 30nm radius
            );

            // Filter out ground vehicles and invalid data
            liveTrafficData = newTraffic.filter(ac =>
                ac.lat && ac.lon &&
                (ac.alt_baro > 0 || ac.alt_geom > 0) &&
                ac.hex
            );

            console.log(`Live traffic: ${liveTrafficData.length} aircraft`);
            renderLiveTraffic();
        }

        function renderLiveTraffic() {
            if (!trafficGroup) {
                console.warn('renderLiveTraffic: trafficGroup not initialized');
                return;
            }

            const activeHexes = new Set();

            for (const ac of liveTrafficData) {
                activeHexes.add(ac.hex);

                let mesh = trafficMeshPool.get(ac.hex);
                if (!mesh) {
                    // Create new mesh for this aircraft
                    mesh = createAircraftMesh(ac.category);
                    mesh.userData = { aircraft: ac };
                    trafficMeshPool.set(ac.hex, mesh);
                    trafficGroup.add(mesh);
                    console.log(`Created mesh for ${ac.flight || ac.hex} (${ac.category})`);
                }

                // Update position
                const pos = aircraftToScenePosition(ac);

                // Debug first aircraft position
                if (trafficMeshPool.size === 1) {
                    console.log(`First aircraft pos: x=${pos.x.toFixed(0)}, y=${pos.y.toFixed(0)}, z=${pos.z.toFixed(0)}`);
                }

                // Smooth position update
                mesh.position.lerp(new THREE.Vector3(pos.x, pos.y, pos.z), 0.1);

                // Update rotation based on track
                const targetRotY = THREE.MathUtils.degToRad(-(ac.track || 0));
                mesh.rotation.y = THREE.MathUtils.lerp(mesh.rotation.y, targetRotY, 0.1);

                // Store updated aircraft data
                mesh.userData.aircraft = ac;
            }

            // Remove stale aircraft
            for (const [hex, mesh] of trafficMeshPool) {
                if (!activeHexes.has(hex)) {
                    trafficGroup.remove(mesh);
                    // Dispose geometry and materials
                    mesh.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    trafficMeshPool.delete(hex);
                }
            }
        }

        function clearLiveTraffic() {
            // Clear all traffic meshes
            for (const [hex, mesh] of trafficMeshPool) {
                trafficGroup.remove(mesh);
                mesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            trafficMeshPool.clear();
            liveTrafficData = [];
        }

        // Aircraft click detection
        function onCanvasClick(event) {
            if (!trafficGroup || trafficMeshPool.size === 0) return;

            // Calculate mouse position in normalized device coordinates
            const canvas = document.getElementById('svs-canvas');
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections with traffic meshes
            const intersects = raycaster.intersectObjects(trafficGroup.children, true);

            if (intersects.length > 0) {
                // Find the parent group (aircraft mesh) that contains userData
                let targetMesh = intersects[0].object;
                while (targetMesh.parent && !targetMesh.userData.aircraft) {
                    targetMesh = targetMesh.parent;
                }

                if (targetMesh.userData && targetMesh.userData.aircraft) {
                    showAircraftLabel(targetMesh.userData.aircraft, event.clientX, event.clientY);
                }
            } else {
                hideAircraftLabel();
            }
        }

        function showAircraftLabel(aircraft, x, y) {
            const label = document.getElementById('aircraftLabel');
            const callsign = aircraft.flight?.trim() || aircraft.r || aircraft.hex;
            const type = aircraft.t || 'Unknown type';
            const alt = aircraft.alt_baro || aircraft.alt_geom || 0;
            const speed = aircraft.gs || 0;
            const vrate = aircraft.baro_rate || aircraft.geom_rate || 0;

            label.innerHTML = `
                <div class="ac-callsign">${callsign}</div>
                <div class="ac-type">${type}</div>
                <div class="ac-data-row">
                    <div class="ac-alt"><span>ALT</span> ${alt.toLocaleString()} ft</div>
                    <div class="ac-speed"><span>GS</span> ${Math.round(speed)} kts</div>
                </div>
                ${vrate !== 0 ? `<div class="ac-data-row"><div class="ac-alt"><span>VS</span> ${vrate > 0 ? '+' : ''}${vrate} fpm</div></div>` : ''}
            `;

            // Position label near click, but keep on screen
            const labelWidth = 150;
            const labelHeight = 100;
            let labelX = x + 15;
            let labelY = y - 20;

            // Keep on screen
            if (labelX + labelWidth > window.innerWidth) {
                labelX = x - labelWidth - 15;
            }
            if (labelY + labelHeight > window.innerHeight) {
                labelY = window.innerHeight - labelHeight - 10;
            }
            if (labelY < 10) {
                labelY = 10;
            }

            label.style.left = labelX + 'px';
            label.style.top = labelY + 'px';
            label.classList.add('visible');
        }

        function hideAircraftLabel() {
            const label = document.getElementById('aircraftLabel');
            label.classList.remove('visible');
        }

        // Legacy function name for compatibility
        function createSimulatedTraffic() {
            // Disabled in performance mode
            if (PERFORMANCE_MODE) return;

            // Now triggers live traffic update
            if (state.overlays.traffic) {
                lastTrafficFetch = 0; // Force immediate fetch
                updateLiveTraffic();
            } else {
                clearLiveTraffic();
            }
        }

        function createSimulatedHazards() {
            if (PERFORMANCE_MODE) return;
            hazardsGroup.clear();

            if (!state.overlays.weather) return;

            // Create multiple storm cells at various distances ahead (extended range)
            // Positioned away from immediate departure corridor (first one at 25km)
            const stormPositions = [
                { x: 10000, z: -25000 },   // 25km ahead, 10km right
                { x: -8000, z: -50000 },   // 50km ahead, 8km left
                { x: 12000, z: -80000 },   // 80km ahead, 12km right
                { x: -10000, z: -110000 }, // 110km ahead, 10km left
                { x: 8000, z: -140000 },   // 140km ahead, 8km right
                { x: -12000, z: -170000 }  // 170km ahead, 12km left
            ];

            stormPositions.forEach((pos, idx) => {
                const stormGroup = new THREE.Group();

                // Create multiple layers for storm cell
                const baseRadius = 2000 + idx * 500;
                for (let i = 0; i < 5; i++) {
                    const radius = baseRadius - i * 300;
                    const height = 2000 + i * 2000;
                    const geometry = new THREE.RingGeometry(radius * 0.8, radius, 32);
                    const material = new THREE.MeshBasicMaterial({
                        color: i < 2 ? 0xff0000 : i < 4 ? 0xffaa00 : 0xffff00,
                        transparent: true,
                        opacity: 0.3 - i * 0.05,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(geometry, material);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = height;
                    stormGroup.add(ring);
                }

                // Storm core (vertical lines)
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                    const x = Math.cos(angle) * baseRadius * 0.7;
                    const z = Math.sin(angle) * baseRadius * 0.7;
                    const lineGeo = new THREE.BufferGeometry();
                    const lineVerts = new Float32Array([x, 1000, z, x, 12000, z]);
                    lineGeo.setAttribute('position', new THREE.BufferAttribute(lineVerts, 3));
                    const lineMat = new THREE.LineBasicMaterial({
                        color: 0xff4444,
                        transparent: true,
                        opacity: 0.4
                    });
                    const line = new THREE.Line(lineGeo, lineMat);
                    stormGroup.add(line);
                }

                stormGroup.position.set(pos.x, 0, pos.z);
                hazardsGroup.add(stormGroup);
            });

            // Turbulence areas at various distances (extended range)
            // Positioned away from immediate departure (first at 20km)
            const turbPositions = [
                { x: -8000, z: -20000 },   // 20km ahead
                { x: 10000, z: -45000 },   // 45km ahead
                { x: -6000, z: -75000 },   // 75km ahead
                { x: 9000, z: -105000 },   // 105km ahead
                { x: -7000, z: -135000 }   // 135km ahead
            ];

            turbPositions.forEach(pos => {
                const turbGroup = new THREE.Group();
                for (let i = 0; i < 8; i++) {
                    const curve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(-1500 + i * 350, 0, -800),
                        new THREE.Vector3(-1300 + i * 350, 150, 0),
                        new THREE.Vector3(-1500 + i * 350, -80, 800),
                        new THREE.Vector3(-1300 + i * 350, 80, 1600)
                    ]);
                    const points = curve.getPoints(20);
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    const mat = new THREE.LineBasicMaterial({
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.5
                    });
                    const line = new THREE.Line(geo, mat);
                    turbGroup.add(line);
                }
                turbGroup.position.set(pos.x, state.altitude * 0.3048, pos.z);
                hazardsGroup.add(turbGroup);
            });
        }

        function createSimulatedObstacles() {
            if (PERFORMANCE_MODE) return;
            obstaclesGroup.clear();

            // Towers - physical obstacles spread along route (extended range)
            // Positioned well off to the sides to avoid departure/arrival paths
            if (state.overlays.towers) {
                // Multiple towers at various distances ahead - all offset significantly from centerline
                // Minimum 5km lateral offset ensures no conflict with departure/arrival paths
                const towers = [
                    { x: 8000, z: -15000, height: 500 },   // Well right of path
                    { x: -7000, z: -25000, height: 350 },  // Well left of path
                    { x: 9000, z: -40000, height: 600 },   // Well right
                    { x: -8000, z: -55000, height: 450 },  // Well left
                    { x: 7000, z: -70000, height: 400 },   // Right side
                    { x: -9000, z: -85000, height: 550 },  // Left side
                    { x: 8000, z: -100000, height: 380 },  // Right
                    { x: -7000, z: -115000, height: 480 }, // Left
                    { x: 9000, z: -130000, height: 420 },  // Right
                    { x: -8000, z: -145000, height: 520 }, // Left
                    { x: 7000, z: -160000, height: 380 },  // Right
                    { x: -9000, z: -175000, height: 450 }  // Left
                ];

            towers.forEach(tower => {
                const towerGroup = new THREE.Group();

                // Tower structure (multiple vertical lines for lattice effect)
                const baseSize = 30;
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 2) {
                    const xOff = Math.cos(angle) * baseSize;
                    const zOff = Math.sin(angle) * baseSize;
                    const lineGeo = new THREE.BufferGeometry();
                    const lineVerts = new Float32Array([xOff, 0, zOff, xOff * 0.3, tower.height, zOff * 0.3]);
                    lineGeo.setAttribute('position', new THREE.BufferAttribute(lineVerts, 3));
                    const lineMat = new THREE.LineBasicMaterial({ color: 0xff00ff });
                    towerGroup.add(new THREE.Line(lineGeo, lineMat));
                }

                // Cross braces
                for (let h = tower.height * 0.25; h < tower.height; h += tower.height * 0.25) {
                    const braceSize = baseSize * (1 - h / tower.height * 0.7);
                    const braceGeo = new THREE.RingGeometry(braceSize * 0.8, braceSize, 4);
                    const braceMat = new THREE.MeshBasicMaterial({
                        color: 0xff00ff,
                        transparent: true,
                        opacity: 0.6,
                        side: THREE.DoubleSide
                    });
                    const brace = new THREE.Mesh(braceGeo, braceMat);
                    brace.rotation.x = Math.PI / 2;
                    brace.rotation.z = Math.PI / 4;
                    brace.position.y = h;
                    towerGroup.add(brace);
                }

                // Warning light at top (pulsing sphere)
                const lightGeo = new THREE.SphereGeometry(15, 8, 8);
                const lightMat = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.9
                });
                const light = new THREE.Mesh(lightGeo, lightMat);
                light.position.y = tower.height;
                towerGroup.add(light);

                // Obstacle avoidance ring
                const ringGeo = new THREE.RingGeometry(80, 100, 16);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = tower.height + 50;
                towerGroup.add(ring);

                towerGroup.position.set(tower.x, 0, tower.z);
                obstaclesGroup.add(towerGroup);
                });
            }

            // Class B Airspace - Wedding Cake Shape (inverted tiers getting smaller as you go up)
            if (state.overlays.airspace) {
            const airspaceGroup = new THREE.Group();

            // Wedding cake tiers - each tier is a distinct 3D volume
            // Class B typically: surface area up to 30nm, ceiling 10,000ft
            // Stepped shelves at different altitudes
            const weddingCakeTiers = [
                // Outer tier (lowest shelf)
                { outerRadius: 20000, innerRadius: 15000, floor: 6000, ceiling: 10000, color: 0x0044cc },
                // Middle outer tier
                { outerRadius: 15000, innerRadius: 10000, floor: 4000, ceiling: 10000, color: 0x0055dd },
                // Middle tier
                { outerRadius: 10000, innerRadius: 5000, floor: 2000, ceiling: 10000, color: 0x0066ee },
                // Inner core (surface to ceiling)
                { outerRadius: 5000, innerRadius: 0, floor: 0, ceiling: 10000, color: 0x0077ff }
            ];

            const segments = 48;

            weddingCakeTiers.forEach((tier, idx) => {
                const floorMeters = tier.floor * 0.3048;
                const ceilMeters = tier.ceiling * 0.3048;
                const tierHeight = ceilMeters - floorMeters;

                // Outer cylindrical wall
                const outerWallGeo = new THREE.CylinderGeometry(
                    tier.outerRadius, tier.outerRadius,
                    tierHeight, segments, 1, true
                );
                const wallMat = new THREE.MeshBasicMaterial({
                    color: tier.color,
                    transparent: true,
                    opacity: 0.12,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const outerWall = new THREE.Mesh(outerWallGeo, wallMat);
                outerWall.position.y = floorMeters + tierHeight / 2;
                airspaceGroup.add(outerWall);

                // Inner cylindrical wall (if not core)
                if (tier.innerRadius > 0) {
                    const innerWallGeo = new THREE.CylinderGeometry(
                        tier.innerRadius, tier.innerRadius,
                        tierHeight, segments, 1, true
                    );
                    const innerWall = new THREE.Mesh(innerWallGeo, wallMat.clone());
                    innerWall.position.y = floorMeters + tierHeight / 2;
                    airspaceGroup.add(innerWall);
                }

                // Floor shelf (the horizontal "shelf" of the wedding cake)
                const floorGeo = new THREE.RingGeometry(tier.innerRadius, tier.outerRadius, segments);
                const floorMat = new THREE.MeshBasicMaterial({
                    color: tier.color,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const floorMesh = new THREE.Mesh(floorGeo, floorMat);
                floorMesh.rotation.x = -Math.PI / 2;
                floorMesh.position.y = floorMeters;
                airspaceGroup.add(floorMesh);

                // Top of this tier section (only for visualization)
                if (idx === 0) {
                    // Only add ceiling cap for outermost tier
                    const ceilGeo = new THREE.RingGeometry(tier.innerRadius, tier.outerRadius, segments);
                    const ceilMat = new THREE.MeshBasicMaterial({
                        color: tier.color,
                        transparent: true,
                        opacity: 0.08,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const ceilMesh = new THREE.Mesh(ceilGeo, ceilMat);
                    ceilMesh.rotation.x = -Math.PI / 2;
                    ceilMesh.position.y = ceilMeters;
                    airspaceGroup.add(ceilMesh);
                }

                // Bright edge rings for floor
                const floorEdgeGeo = new THREE.TorusGeometry(tier.outerRadius, 50, 4, segments);
                const edgeMat = new THREE.MeshBasicMaterial({
                    color: tier.color,
                    transparent: true,
                    opacity: 0.6
                });
                const floorOuterEdge = new THREE.Mesh(floorEdgeGeo, edgeMat);
                floorOuterEdge.rotation.x = Math.PI / 2;
                floorOuterEdge.position.y = floorMeters;
                airspaceGroup.add(floorOuterEdge);

                if (tier.innerRadius > 0) {
                    const floorInnerEdgeGeo = new THREE.TorusGeometry(tier.innerRadius, 50, 4, segments);
                    const floorInnerEdge = new THREE.Mesh(floorInnerEdgeGeo, edgeMat.clone());
                    floorInnerEdge.rotation.x = Math.PI / 2;
                    floorInnerEdge.position.y = floorMeters;
                    airspaceGroup.add(floorInnerEdge);
                }

                // Vertical struts for depth perception
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                    // Outer struts
                    const ox = Math.cos(angle) * tier.outerRadius;
                    const oz = Math.sin(angle) * tier.outerRadius;
                    const outerStrutGeo = new THREE.BufferGeometry();
                    outerStrutGeo.setAttribute('position', new THREE.BufferAttribute(
                        new Float32Array([ox, floorMeters, oz, ox, ceilMeters, oz]), 3
                    ));
                    const strutMat = new THREE.LineBasicMaterial({
                        color: tier.color,
                        transparent: true,
                        opacity: 0.4
                    });
                    airspaceGroup.add(new THREE.Line(outerStrutGeo, strutMat));

                    // Inner struts
                    if (tier.innerRadius > 0) {
                        const ix = Math.cos(angle) * tier.innerRadius;
                        const iz = Math.sin(angle) * tier.innerRadius;
                        const innerStrutGeo = new THREE.BufferGeometry();
                        innerStrutGeo.setAttribute('position', new THREE.BufferAttribute(
                            new Float32Array([ix, floorMeters, iz, ix, ceilMeters, iz]), 3
                        ));
                        airspaceGroup.add(new THREE.Line(innerStrutGeo, strutMat.clone()));
                    }
                }

                // Horizontal rings at altitude intervals (1000ft)
                for (let alt = tier.floor + 1000; alt < tier.ceiling; alt += 1000) {
                    const altMeters = alt * 0.3048;
                    const outerRingGeo = new THREE.TorusGeometry(tier.outerRadius, 20, 4, segments);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: tier.color,
                        transparent: true,
                        opacity: 0.25
                    });
                    const outerRing = new THREE.Mesh(outerRingGeo, ringMat);
                    outerRing.rotation.x = Math.PI / 2;
                    outerRing.position.y = altMeters;
                    airspaceGroup.add(outerRing);

                    if (tier.innerRadius > 0) {
                        const innerRingGeo = new THREE.TorusGeometry(tier.innerRadius, 20, 4, segments);
                        const innerRing = new THREE.Mesh(innerRingGeo, ringMat.clone());
                        innerRing.rotation.x = Math.PI / 2;
                        innerRing.position.y = altMeters;
                        airspaceGroup.add(innerRing);
                    }
                }

                // Connect floors between tiers with radial lines
                if (tier.innerRadius > 0 && idx < weddingCakeTiers.length - 1) {
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                        const x1 = Math.cos(angle) * tier.innerRadius;
                        const z1 = Math.sin(angle) * tier.innerRadius;
                        const x2 = Math.cos(angle) * tier.outerRadius;
                        const z2 = Math.sin(angle) * tier.outerRadius;

                        const radialGeo = new THREE.BufferGeometry();
                        radialGeo.setAttribute('position', new THREE.BufferAttribute(
                            new Float32Array([x1, floorMeters, z1, x2, floorMeters, z2]), 3
                        ));
                        const radialMat = new THREE.LineBasicMaterial({
                            color: tier.color,
                            transparent: true,
                            opacity: 0.5
                        });
                        airspaceGroup.add(new THREE.Line(radialGeo, radialMat));
                    }
                }
            });

            // Add the complete ceiling cap at 10,000ft
            const topCapGeo = new THREE.CircleGeometry(5000, segments);
            const topCapMat = new THREE.MeshBasicMaterial({
                color: 0x0077ff,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const topCap = new THREE.Mesh(topCapGeo, topCapMat);
            topCap.rotation.x = -Math.PI / 2;
            topCap.position.y = 10000 * 0.3048;
            airspaceGroup.add(topCap);

            airspaceGroup.position.set(0, 0, -50000);
            obstaclesGroup.add(airspaceGroup);
            }

            // Add TFR (Temporary Flight Restriction) zone
            if (state.overlays.tfr) {
            const tfrGroup = new THREE.Group();
            const tfrRadius = 5000;
            const tfrHeight = 6000 * 0.3048;

            // TFR wall (red)
            const tfrWallGeo = new THREE.CylinderGeometry(tfrRadius, tfrRadius, tfrHeight, 32, 1, true);
            const tfrWallMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const tfrWall = new THREE.Mesh(tfrWallGeo, tfrWallMat);
            tfrWall.position.y = tfrHeight / 2;
            tfrGroup.add(tfrWall);

            // TFR floor
            const tfrFloorGeo = new THREE.CircleGeometry(tfrRadius, 32);
            const tfrFloorMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const tfrFloor = new THREE.Mesh(tfrFloorGeo, tfrFloorMat);
            tfrFloor.rotation.x = -Math.PI / 2;
            tfrGroup.add(tfrFloor);

            // TFR ceiling
            const tfrCeil = new THREE.Mesh(tfrFloorGeo.clone(), tfrFloorMat);
            tfrCeil.rotation.x = -Math.PI / 2;
            tfrCeil.position.y = tfrHeight;
            tfrGroup.add(tfrCeil);

            // TFR edge rings
            const tfrEdgeGeo = new THREE.TorusGeometry(tfrRadius, 40, 4, 32);
            const tfrEdgeMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.6 });
            const tfrFloorEdge = new THREE.Mesh(tfrEdgeGeo, tfrEdgeMat);
            tfrFloorEdge.rotation.x = Math.PI / 2;
            tfrGroup.add(tfrFloorEdge);
            const tfrCeilEdge = new THREE.Mesh(tfrEdgeGeo.clone(), tfrEdgeMat);
            tfrCeilEdge.rotation.x = Math.PI / 2;
            tfrCeilEdge.position.y = tfrHeight;
            tfrGroup.add(tfrCeilEdge);

            // X pattern on TFR
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                const x = Math.cos(angle) * tfrRadius;
                const z = Math.sin(angle) * tfrRadius;
                const lineGeo = new THREE.BufferGeometry();
                const lineVerts = new Float32Array([0, 0, 0, x, tfrHeight, z]);
                lineGeo.setAttribute('position', new THREE.BufferAttribute(lineVerts, 3));
                const lineMat = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.4 });
                tfrGroup.add(new THREE.Line(lineGeo, lineMat));
            }

            // Add multiple TFRs at different positions along route (extended range)
            // Positioned away from departure (first at 35km)
            const tfrPositions = [
                { x: -12000, z: -35000 },
                { x: 10000, z: -75000 },
                { x: -8000, z: -115000 },
                { x: 12000, z: -155000 }
            ];

            tfrPositions.forEach((pos, idx) => {
                const tfrClone = tfrGroup.clone();
                tfrClone.position.set(pos.x, 0, pos.z);
                obstaclesGroup.add(tfrClone);
            });
            }
        }

        // ============================================
        // BUILDINGS OVERLAY (OpenStreetMap Data)
        // ============================================

        async function fetchBuildingData(lat, lon) {
            if (PERFORMANCE_MODE) return []; // Disable external fetching
            // Cancel any in-flight request
            if (buildingsFetchController) {
                buildingsFetchController.abort();
            }
            buildingsFetchController = new AbortController();

            try {
                // Fetch buildings within larger radius for visibility
                const radiusMeters = 15000; // 15km radius
                const query = `
                    [out:json][timeout:15];
                    (
                        way["building"](around:${radiusMeters},${lat},${lon});
                        relation["building"](around:${radiusMeters},${lat},${lon});
                    );
                    out body geom;
                `;

                console.log(`Fetching buildings around ${lat.toFixed(4)}, ${lon.toFixed(4)}...`);

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query,
                    signal: buildingsFetchController.signal
                });

                if (!response.ok) throw new Error(`Overpass API error: ${response.status}`);

                const data = await response.json();
                state.buildingData = data.elements || [];
                console.log(`Found ${state.buildingData.length} buildings`);
                return state.buildingData;
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.warn('Building data fetch failed:', error);
                }
                return [];
            }
        }

        function createBuildingMeshes() {
            buildingsGroup.clear();

            if (!state.overlays.buildings || !state.buildingData || state.buildingData.length === 0) {
                console.log('Buildings: overlay disabled or no data');
                return;
            }

            console.log(`Creating meshes for ${state.buildingData.length} buildings...`);

            const ftToMeters = 0.3048;
            const metersPerDegLat = 111320;
            const metersPerDegLon = metersPerDegLat * Math.cos(state.position.lat * Math.PI / 180);

            // Get reference ground level to match terrain rendering
            // Buildings Y position should be relative to reference ground level (same as terrain)
            const referenceGroundLevel = state.referenceGroundLevel || 0;
            const terrainLowerOffset = state.terrainLowerOffset || 120;

            // Sort buildings by distance from aircraft (closer first)
            const sortedBuildings = state.buildingData
                .filter(b => b.geometry && b.geometry.length >= 3)
                .map(building => {
                    let centerLat = 0, centerLon = 0;
                    building.geometry.forEach(node => {
                        centerLat += node.lat;
                        centerLon += node.lon;
                    });
                    centerLat /= building.geometry.length;
                    centerLon /= building.geometry.length;

                    const dx = (centerLon - state.position.lon) * metersPerDegLon;
                    const dz = (centerLat - state.position.lat) * metersPerDegLat;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    return { ...building, centerLat, centerLon, dist };
                })
                .sort((a, b) => a.dist - b.dist);

            // Limit to closest buildings for performance (increased for better coverage)
            const buildingsToRender = sortedBuildings.slice(0, 500);

            buildingsToRender.forEach(building => {
                // Get building height - exaggerate for visibility
                let height = 15; // Default 15m
                if (building.tags) {
                    if (building.tags.height) {
                        height = parseFloat(building.tags.height) || 15;
                    } else if (building.tags['building:levels']) {
                        height = parseFloat(building.tags['building:levels']) * 4 || 15;
                    } else if (building.tags.building === 'skyscraper' || building.tags.building === 'tower') {
                        height = 100 + Math.random() * 150; // Tall buildings
                    } else if (building.tags.building === 'commercial' || building.tags.building === 'industrial') {
                        height = 20 + Math.random() * 20;
                    }
                }

                // Exaggerate height for better visibility from altitude (3x)
                height *= 3;

                // Create building shape from polygon
                const shape = new THREE.Shape();

                // Convert to local coordinates relative to building center
                building.geometry.forEach((node, idx) => {
                    const localX = (node.lon - building.centerLon) * metersPerDegLon;
                    const localZ = (node.lat - building.centerLat) * metersPerDegLat;

                    if (idx === 0) {
                        shape.moveTo(localX, localZ);
                    } else {
                        shape.lineTo(localX, localZ);
                    }
                });
                shape.closePath();

                // Extrude to create 3D building
                const extrudeSettings = {
                    depth: height,
                    bevelEnabled: false
                };

                try {
                    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                    geometry.rotateX(-Math.PI / 2); // Stand upright

                    // Color based on distance - brighter when closer (collision warning)
                    const distFade = Math.max(0.4, 1 - building.dist / 5000);
                    const isClose = building.dist < 1000; // Within 1km

                    // Building material - bright magenta/pink, brighter when close
                    const material = new THREE.MeshBasicMaterial({
                        color: isClose ? 0xff1493 : 0xec4899, // Hot pink if close
                        transparent: true,
                        opacity: isClose ? 0.85 : 0.7 * distFade,
                        side: THREE.DoubleSide
                    });

                    const mesh = new THREE.Mesh(geometry, material);

                    // Position building relative to aircraft (no forward offset - buildings appear at actual position)
                    const buildingX = (building.centerLon - state.position.lon) * metersPerDegLon;
                    const buildingZ = -(building.centerLat - state.position.lat) * metersPerDegLat;

                    // Y position: ground level relative to reference, matching terrain coordinate system
                    // Terrain uses: y = elevation - referenceGroundLevel - terrainLowerOffset
                    // Buildings should sit on top of that, so use same reference
                    const buildingGroundY = -terrainLowerOffset; // Base ground level in scene coords

                    mesh.position.set(buildingX, buildingGroundY, buildingZ);

                    // Debug: log first few building positions
                    if (buildingsGroup.children.length < 6) {
                        console.log(`Building ${buildingsGroup.children.length/2}: pos(${buildingX.toFixed(0)}, ${buildingGroundY.toFixed(0)}, ${buildingZ.toFixed(0)}), height=${height.toFixed(0)}m, dist=${building.dist.toFixed(0)}m`);
                    }
                    buildingsGroup.add(mesh);

                    // Add wireframe outline for better visibility (brighter lines)
                    const edges = new THREE.EdgesGeometry(geometry);
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: 0xff69b4,
                        transparent: true,
                        opacity: isClose ? 1.0 : 0.8,
                        linewidth: 2
                    });
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    wireframe.position.copy(mesh.position);
                    buildingsGroup.add(wireframe);
                } catch (e) {
                    // Skip malformed buildings
                }
            });

            console.log(`Buildings rendered: ${buildingsGroup.children.length / 2} meshes`);
        }

        async function updateBuildingsOverlay() {
            if (PERFORMANCE_MODE) return; // Disable external fetching
            if (!state.overlays.buildings) {
                buildingsGroup.clear();
                return;
            }

            // Fetch new building data for current position
            await fetchBuildingData(state.position.lat, state.position.lon);
            createBuildingMeshes();
        }

        // ============================================
        // CLOUDS OVERLAY
        // ============================================

        // Seeded random number generator for consistent cloud/icing positions
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function updateCloudsOverlay() {
            cloudsGroup.clear();

            if (!state.overlays.clouds) {
                return;
            }

            const ftToMeters = 0.3048;
            const forwardOffset = 18 * 1852; // Match terrain offset

            // Use position-based seed for consistent cloud placement
            const baseSeed = Math.floor(state.position.lat * 1000 + state.position.lon * 100);

            // Generate cloud layers at different altitudes
            // Simulated cloud data based on typical cloud types
            const cloudLayers = [
                { baseAlt: 2000, topAlt: 4000, coverage: 0.3, type: 'cumulus' },
                { baseAlt: 6000, topAlt: 8000, coverage: 0.5, type: 'stratocumulus' },
                { baseAlt: 15000, topAlt: 20000, coverage: 0.4, type: 'cirrus' },
                { baseAlt: 25000, topAlt: 35000, coverage: 0.2, type: 'cirrostratus' }
            ];

            let seedOffset = 0;
            cloudLayers.forEach(layer => {
                const numClouds = Math.floor(layer.coverage * 30);

                for (let i = 0; i < numClouds; i++) {
                    // Use seeded random for consistent positions
                    seedOffset++;
                    const x = (seededRandom(baseSeed + seedOffset) - 0.5) * 60000;
                    seedOffset++;
                    const z = -seededRandom(baseSeed + seedOffset) * 50000 - forwardOffset;
                    seedOffset++;
                    const y = (layer.baseAlt + seededRandom(baseSeed + seedOffset) * (layer.topAlt - layer.baseAlt)) * ftToMeters;

                    // Cloud size varies by type (using seeded random for consistency)
                    let width, height, depth;
                    seedOffset++;
                    const sizeRand1 = seededRandom(baseSeed + seedOffset);
                    seedOffset++;
                    const sizeRand2 = seededRandom(baseSeed + seedOffset);
                    seedOffset++;
                    const sizeRand3 = seededRandom(baseSeed + seedOffset);

                    if (layer.type === 'cumulus') {
                        width = 500 + sizeRand1 * 1000;
                        height = 300 + sizeRand2 * 800;
                        depth = 500 + sizeRand3 * 1000;
                    } else if (layer.type === 'stratocumulus') {
                        width = 2000 + sizeRand1 * 3000;
                        height = 200 + sizeRand2 * 400;
                        depth = 2000 + sizeRand3 * 3000;
                    } else if (layer.type === 'cirrus') {
                        width = 3000 + sizeRand1 * 5000;
                        height = 100 + sizeRand2 * 200;
                        depth = 1000 + sizeRand3 * 2000;
                    } else {
                        width = 5000 + sizeRand1 * 8000;
                        height = 500 + sizeRand2 * 1000;
                        depth = 5000 + sizeRand3 * 8000;
                    }

                    // Create cloud as semi-transparent box
                    const geometry = new THREE.BoxGeometry(width, height, depth);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: layer.type === 'cirrus' ? 0.15 : 0.35,
                        side: THREE.DoubleSide
                    });

                    const cloud = new THREE.Mesh(geometry, material);
                    cloud.position.set(x, y, z);

                    // Add slight rotation for variety (seeded)
                    seedOffset++;
                    cloud.rotation.y = seededRandom(baseSeed + seedOffset) * Math.PI;

                    cloudsGroup.add(cloud);
                }
            });

            console.log(`Clouds rendered: ${cloudsGroup.children.length} cloud volumes`);
        }

        // ============================================
        // ICING OVERLAY
        // ============================================

        function updateIcingOverlay() {
            icingGroup.clear();

            if (!state.overlays.icing) {
                return;
            }

            const ftToMeters = 0.3048;
            const forwardOffset = 18 * 1852;

            // Use position-based seed for consistent icing placement (offset from clouds)
            const baseSeed = Math.floor(state.position.lat * 1000 + state.position.lon * 100) + 50000;

            // Icing typically occurs in clouds between 0°C and -20°C
            // At standard atmosphere: 0°C at ~6500ft, -20°C at ~16000ft
            const icingZones = [
                { baseAlt: 5000, topAlt: 8000, severity: 'light', color: 0x38bdf8 },
                { baseAlt: 8000, topAlt: 12000, severity: 'moderate', color: 0x0ea5e9 },
                { baseAlt: 12000, topAlt: 16000, severity: 'severe', color: 0x0284c7 }
            ];

            let seedOffset = 0;
            icingZones.forEach(zone => {
                // Create icing zone volumes (seeded count for consistency)
                seedOffset++;
                const numZones = 8 + Math.floor(seededRandom(baseSeed + seedOffset) * 5);

                for (let i = 0; i < numZones; i++) {
                    seedOffset++;
                    const x = (seededRandom(baseSeed + seedOffset) - 0.5) * 50000;
                    seedOffset++;
                    const z = -seededRandom(baseSeed + seedOffset) * 40000 - forwardOffset;
                    seedOffset++;
                    const y = (zone.baseAlt + seededRandom(baseSeed + seedOffset) * (zone.topAlt - zone.baseAlt)) * ftToMeters;

                    seedOffset++;
                    const width = 3000 + seededRandom(baseSeed + seedOffset) * 5000;
                    const height = (zone.topAlt - zone.baseAlt) * ftToMeters * 0.5;
                    seedOffset++;
                    const depth = 3000 + seededRandom(baseSeed + seedOffset) * 5000;

                    const geometry = new THREE.BoxGeometry(width, height, depth);

                    // Use wireframe for icing zones
                    const edges = new THREE.EdgesGeometry(geometry);
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: zone.color,
                        transparent: true,
                        opacity: zone.severity === 'severe' ? 0.8 : zone.severity === 'moderate' ? 0.6 : 0.4
                    });
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    wireframe.position.set(x, y, z);
                    icingGroup.add(wireframe);

                    // Add semi-transparent fill for severe zones
                    if (zone.severity === 'severe' || zone.severity === 'moderate') {
                        const fillMaterial = new THREE.MeshBasicMaterial({
                            color: zone.color,
                            transparent: true,
                            opacity: zone.severity === 'severe' ? 0.15 : 0.08,
                            side: THREE.DoubleSide
                        });
                        const fill = new THREE.Mesh(geometry, fillMaterial);
                        fill.position.set(x, y, z);
                        icingGroup.add(fill);
                    }
                }
            });

            console.log(`Icing zones rendered: ${icingGroup.children.length} volumes`);
        }

        // ============================================
        // VISIBILITY OVERLAY
        // ============================================

        // Static seed for consistent visibility - set once per session
        let visibilitySeed = null;

        function updateVisibilityOverlay() {
            visibilityGroup.clear();

            if (!state.overlays.visibility) {
                return;
            }

            // Use a fixed seed for the session - only set once
            if (visibilitySeed === null) {
                visibilitySeed = Math.floor(Math.random() * 100000) + 12345;
            }

            const ftToMeters = 0.3048;
            const baseSeed = visibilitySeed;

            // Reference ground level for positioning (terrain-relative)
            const refGround = state.referenceGroundLevel || 0;

            // Visibility bands - static concentric rings at ground level
            const visibilityZones = [
                { dist: 8000, opacity: 0.04, color: 0x888888 },
                { dist: 15000, opacity: 0.06, color: 0x999999 },
                { dist: 25000, opacity: 0.10, color: 0xaaaaaa },
                { dist: 40000, opacity: 0.15, color: 0xbbbbbb }
            ];

            // Create concentric visibility rings at ground level
            visibilityZones.forEach((zone, idx) => {
                const innerRadius = idx === 0 ? 2000 : visibilityZones[idx - 1].dist;
                const outerRadius = zone.dist;

                const ringGeo = new THREE.RingGeometry(innerRadius, outerRadius, 48);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: zone.color,
                    transparent: true,
                    opacity: zone.opacity,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                // Position at ground level (y=0 in terrain-relative coordinates) plus small offset
                ring.position.y = 5; // Just above ground to avoid z-fighting
                visibilityGroup.add(ring);
            });

            // Fixed fog banks using stable seed
            for (let i = 0; i < 8; i++) {
                const angle = seededRandom(baseSeed + i * 7) * Math.PI * 2;
                const dist = 8000 + seededRandom(baseSeed + i * 11) * 25000;
                const x = Math.cos(angle) * dist;
                const z = -Math.sin(angle) * dist - 10000;

                const width = 3000 + seededRandom(baseSeed + i * 13) * 5000;
                const height = 100 + seededRandom(baseSeed + i * 17) * 200; // Shorter fog: 100-300m
                const depth = 3000 + seededRandom(baseSeed + i * 19) * 5000;

                const fogGeo = new THREE.BoxGeometry(width, height, depth);
                const fogMat = new THREE.MeshBasicMaterial({
                    color: 0xcccccc,
                    transparent: true,
                    opacity: 0.08, // More subtle
                    side: THREE.DoubleSide
                });
                const fogBank = new THREE.Mesh(fogGeo, fogMat);

                // Position fog banks so their BOTTOM is at/above ground level
                // Add height/2 since Three.js positions by center
                const bottomOffset = 20 + seededRandom(baseSeed + i * 23) * 50; // 20-70m above ground
                fogBank.position.set(x, bottomOffset + height / 2, z);
                visibilityGroup.add(fogBank);
            }

            // Haze layers
            for (let i = 0; i < 2; i++) {
                const hazeGeo = new THREE.PlaneGeometry(80000, 12000);
                const hazeMat = new THREE.MeshBasicMaterial({
                    color: 0xaaaaaa,
                    transparent: true,
                    opacity: 0.04 + i * 0.02,
                    side: THREE.DoubleSide
                });
                const haze = new THREE.Mesh(hazeGeo, hazeMat);
                haze.position.set(0, 1500 + i * 2500, -30000 - i * 20000);
                visibilityGroup.add(haze);
            }
        }

        // Flight path mesh showing full journey route
        let flightPathMesh = null;
        // Runway visualization mesh
        let runwayMesh = null;

        // Shared function to calculate position at a given progress
        // This ensures path line and simulation use IDENTICAL logic
        function getFlightPositionAtProgress(progressValue, simulation) {
            const { from, to, distance, waypoints } = simulation.route;
            const departureRunway = simulation.departureRunway;
            // CRITICAL: Must match transition point in updateFlightPathLine() and updateSimulation()
            const takeoffEndProgress = 0.15;

            if (progressValue < takeoffEndProgress && departureRunway) {
                // During takeoff phase - straight out from runway
                const takeoffProgress = progressValue / takeoffEndProgress;
                const departureDistanceNM = takeoffProgress * 8;
                const hdgRad = departureRunway.hdg * Math.PI / 180;
                const nmPerDegLat = 60;
                const nmPerDegLon = 60 * Math.cos(departureRunway.lat * Math.PI / 180);

                return {
                    lat: departureRunway.lat + (departureDistanceNM * Math.cos(hdgRad)) / nmPerDegLat,
                    lon: departureRunway.lon + (departureDistanceNM * Math.sin(hdgRad)) / nmPerDegLon
                };
            } else if (waypoints && waypoints.length > 1) {
                // After takeoff - follow waypoints
                const wpProgress = Math.max(0, (progressValue - takeoffEndProgress) / (1 - takeoffEndProgress));
                const totalWP = waypoints.length;
                const segProgress = wpProgress * (totalWP - 1);
                const segIdx = Math.min(Math.floor(segProgress), totalWP - 2);
                const segFrac = segProgress - segIdx;
                const wp1 = waypoints[segIdx];
                const wp2 = waypoints[Math.min(segIdx + 1, totalWP - 1)];
                return {
                    lat: wp1.lat + (wp2.lat - wp1.lat) * segFrac,
                    lon: wp1.lon + (wp2.lon - wp1.lon) * segFrac
                };
            } else {
                return {
                    lat: from.lat + (to.lat - from.lat) * progressValue,
                    lon: from.lon + (to.lon - from.lon) * progressValue
                };
            }
        }

        // Shared function to calculate altitude at a given progress
        function getFlightAltitudeAtProgress(progressValue, cruiseAlt) {
            const p = progressValue;
            if (p < 0.03) return 0;
            if (p < 0.08) return ((p - 0.03) / 0.05) * 500;
            if (p < 0.15) return 500 + ((p - 0.08) / 0.07) * 1500;
            if (p < 0.25) return 2000 + ((p - 0.15) / 0.10) * (cruiseAlt - 2000);
            if (p < 0.70) return cruiseAlt;
            if (p < 0.82) return cruiseAlt - ((p - 0.70) / 0.12) * (cruiseAlt - 3000);
            if (p < 0.90) return 3000 - ((p - 0.82) / 0.08) * 2500;
            if (p < 0.96) return 500 - ((p - 0.90) / 0.06) * 450;
            return Math.max(0, 50 - ((p - 0.96) / 0.04) * 50);
        }

        // Track last state for change detection
        let lastFlightPathState = null;
        let lastFlightPathRebuild = 0;

        // Smoothed state for flight path (prevents jitter)
        const flightPathSmoothed = {
            heading: 0,
            altitude: 0,
            verticalSpeed: 0,
            groundSpeed: 120,
            turnRate: 0, // degrees per second
            lastHeading: 0,
            lastTime: 0,
            initialized: false
        };

        // Lerp angle with wraparound handling (for heading)
        function lerpAngle(from, to, t) {
            let diff = to - from;
            // Handle wraparound (e.g., 350° to 10° should go through 360/0)
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            let result = from + diff * t;
            // Normalize to 0-360
            if (result < 0) result += 360;
            if (result >= 360) result -= 360;
            return result;
        }

        function updateFlightPathLine() {
            if (PERFORMANCE_MODE) return; // Disable flight path ribbon
            // 3D Flight Path Tunnel - Smooth world-space route visualization
            try {
                if (!camera) return;

                const isLight = document.documentElement.classList.contains('light-mode');
                const now = performance.now();

                // Initialize smoothed state on first call
                if (!flightPathSmoothed.initialized) {
                    flightPathSmoothed.heading = state.heading;
                    flightPathSmoothed.altitude = state.altitude;
                    flightPathSmoothed.verticalSpeed = state.verticalSpeed || 0;
                    flightPathSmoothed.groundSpeed = state.groundSpeed || 120;
                    flightPathSmoothed.lastHeading = state.heading;
                    flightPathSmoothed.lastTime = now;
                    flightPathSmoothed.turnRate = 0;
                    flightPathSmoothed.initialized = true;
                }

                // Calculate turn rate from heading change (very heavily smoothed)
                const dt = (now - flightPathSmoothed.lastTime) / 1000; // seconds
                if (dt > 0.05) { // Only sample every 50ms minimum
                    let headingDelta = state.heading - flightPathSmoothed.lastHeading;
                    // Handle wraparound
                    if (headingDelta > 180) headingDelta -= 360;
                    if (headingDelta < -180) headingDelta += 360;
                    const instantTurnRate = headingDelta / dt; // deg/sec
                    // Smooth the turn rate VERY heavily to avoid jitter/ghosting
                    flightPathSmoothed.turnRate += (instantTurnRate - flightPathSmoothed.turnRate) * 0.02;
                    // Clamp to small values - we want subtle curves, not wild swings
                    flightPathSmoothed.turnRate = Math.max(-2, Math.min(2, flightPathSmoothed.turnRate));
                    flightPathSmoothed.lastHeading = state.heading;
                    flightPathSmoothed.lastTime = now;
                }

                // Decay turn rate toward zero when flying straight
                if (Math.abs(flightPathSmoothed.turnRate) < 0.1) {
                    flightPathSmoothed.turnRate = 0;
                }

                // Smoothly interpolate toward actual values (every frame)
                const smoothFactor = 0.05; // Lower = smoother, higher = more responsive
                flightPathSmoothed.heading = lerpAngle(flightPathSmoothed.heading, state.heading, smoothFactor);
                flightPathSmoothed.altitude += (state.altitude - flightPathSmoothed.altitude) * smoothFactor;
                flightPathSmoothed.verticalSpeed += ((state.verticalSpeed || 0) - flightPathSmoothed.verticalSpeed) * smoothFactor;
                flightPathSmoothed.groundSpeed += ((state.groundSpeed || 120) - flightPathSmoothed.groundSpeed) * smoothFactor;

                // Only rebuild geometry periodically - NOT on every small change
                // This prevents the "ghosting" effect during banks
                const rebuildInterval = 500; // ms between rebuilds - longer = more stable
                const timeSinceRebuild = now - lastFlightPathRebuild;

                // Only force rebuild on theme change, otherwise just use timer
                const themeChanged = lastFlightPathState && lastFlightPathState.split('-')[0] !== String(isLight);
                const needsRebuild = !flightPathMesh ||
                    timeSinceRebuild > rebuildInterval ||
                    themeChanged;

                if (!needsRebuild && flightPathMesh) {
                    // Just update the group position/rotation smoothly without rebuilding
                    return;
                }

                lastFlightPathRebuild = now;
                lastFlightPathState = `${isLight}-${Math.floor(flightPathSmoothed.heading)}-${Math.floor(flightPathSmoothed.altitude)}`;

                // Remove existing
                if (flightPathMesh) {
                    if (flightPathMesh.parent) {
                        flightPathMesh.parent.remove(flightPathMesh);
                    }
                    flightPathMesh.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    flightPathMesh = null;
                }

                flightPathMesh = new THREE.Group();

                // ===========================================
                // FLIGHT PATH - World-space ribbon visualization
                // Uses SMOOTHED values to prevent jitter
                // ===========================================
                const pathLength = 30000; // 30km ahead
                const startDist = 40; // Start close to aircraft/compass

                const ftToMeters = 0.3048;
                // Use smoothed values for stable path
                const aircraftAltMeters = flightPathSmoothed.altitude * ftToMeters;
                const headingRad = flightPathSmoothed.heading * Math.PI / 180;

                // Detect ground operations - hide ribbon during taxi/early takeoff
                const isGroundOps = state.altitude < 200 && state.groundSpeed < 80;
                if (isGroundOps) {
                    // Don't show ribbon during ground ops - too glitchy
                    scene.add(flightPathMesh); // Add empty group
                    return;
                }

                // Use smoothed vertical rate for path projection
                const vsRate = flightPathSmoothed.verticalSpeed;
                const groundSpeedKts = Math.max(flightPathSmoothed.groundSpeed, 100); // Min 100kts for stable calculations
                const groundSpeedMps = groundSpeedKts * 0.514444; // m/s

                // Calculate climb/descent angle from smoothed VS and GS
                // Clamp to reasonable climb angles (max ±15 degrees)
                const vsMps = (vsRate / 60) * ftToMeters;
                const rawClimbRad = Math.atan2(vsMps, groundSpeedMps);
                const maxClimbRad = 15 * Math.PI / 180;
                const climbRad = Math.max(-maxClimbRad, Math.min(maxClimbRad, rawClimbRad));

                // Get turn rate (degrees per second) - positive = right turn
                const turnRate = flightPathSmoothed.turnRate;
                const turnRateRad = turnRate * Math.PI / 180; // rad/sec

                // Build CURVED path points in WORLD SPACE
                // Path curves based on current turn rate, projects ahead
                const pathPoints = [];
                let currentHeading = headingRad;
                let currentX = 0;
                let currentZ = 0;
                let currentY = aircraftAltMeters;

                const stepDist = 80; // meters per step
                const timePerStep = stepDist / groundSpeedMps; // seconds per step

                for (let dist = 0; dist <= pathLength; dist += stepDist) {
                    if (dist >= startDist) {
                        pathPoints.push(new THREE.Vector3(currentX, currentY, currentZ));
                    }

                    // Update heading based on turn rate (heading changes over time)
                    currentHeading += turnRateRad * timePerStep;

                    // Move forward along current heading
                    currentX += Math.sin(currentHeading) * stepDist;
                    currentZ -= Math.cos(currentHeading) * stepDist;

                    // Climb/descend
                    currentY += Math.tan(climbRad) * stepDist;
                    currentY = Math.max(0, Math.min(currentY, 20000));
                }

                if (pathPoints.length < 3) {
                    // Fallback: straight level path
                    for (let dist = startDist; dist <= pathLength; dist += 200) {
                        const worldX = Math.sin(headingRad) * dist;
                        const worldZ = -Math.cos(headingRad) * dist;
                        pathPoints.push(new THREE.Vector3(worldX, aircraftAltMeters, worldZ));
                    }
                }

                const flightPath = new THREE.CatmullRomCurve3(pathPoints);
                const pathColor = isLight ? 0x0077dd : 0x00ccff;

                // ===========================================
                // RIBBON - wide flat strip following the path
                // ===========================================
                const ribbonWidth = 25; // meters wide - visible near compass
                const ribbonSegments = 300;

                // Build ribbon geometry manually
                const ribbonPositions = [];
                const ribbonIndices = [];
                const ribbonColors = [];

                for (let i = 0; i <= ribbonSegments; i++) {
                    const t = i / ribbonSegments;
                    const pt = flightPath.getPointAt(t);
                    const tan = flightPath.getTangentAt(t);

                    // Get perpendicular vector (cross with up, fallback to right)
                    const up = new THREE.Vector3(0, 1, 0);
                    let perp = new THREE.Vector3().crossVectors(tan, up).normalize();
                    if (perp.length() < 0.1) {
                        perp = new THREE.Vector3(1, 0, 0);
                    }

                    // Width increases slightly with distance for visibility
                    const distFactor = 1 + t * 1.5; // Gets wider further away (less aggressive)
                    const width = ribbonWidth * distFactor;

                    // Left and right points
                    const left = pt.clone().add(perp.clone().multiplyScalar(-width / 2));
                    const right = pt.clone().add(perp.clone().multiplyScalar(width / 2));

                    ribbonPositions.push(left.x, left.y, left.z);
                    ribbonPositions.push(right.x, right.y, right.z);

                    // Color fades with distance (more transparent further away)
                    const alpha = 1 - t * 0.7; // 1.0 near, 0.3 far
                    const r = isLight ? 0 : 0;
                    const g = isLight ? 0.47 : 0.8;
                    const b = isLight ? 0.87 : 1;
                    ribbonColors.push(r, g, b, alpha);
                    ribbonColors.push(r, g, b, alpha);

                    // Create triangles (two per segment)
                    if (i < ribbonSegments) {
                        const idx = i * 2;
                        // Triangle 1
                        ribbonIndices.push(idx, idx + 1, idx + 2);
                        // Triangle 2
                        ribbonIndices.push(idx + 1, idx + 3, idx + 2);
                    }
                }

                const ribbonGeo = new THREE.BufferGeometry();
                ribbonGeo.setAttribute('position', new THREE.Float32BufferAttribute(ribbonPositions, 3));
                ribbonGeo.setAttribute('color', new THREE.Float32BufferAttribute(ribbonColors, 4));
                ribbonGeo.setIndex(ribbonIndices);
                ribbonGeo.computeVertexNormals();

                const ribbonMat = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                const ribbon = new THREE.Mesh(ribbonGeo, ribbonMat);
                flightPathMesh.add(ribbon);

                // ===========================================
                // EDGE LINES - thin lines on ribbon edges for definition
                // ===========================================
                const leftEdge = [];
                const rightEdge = [];
                for (let i = 0; i <= ribbonSegments; i++) {
                    const t = i / ribbonSegments;
                    const pt = flightPath.getPointAt(t);
                    const tan = flightPath.getTangentAt(t);
                    const up = new THREE.Vector3(0, 1, 0);
                    let perp = new THREE.Vector3().crossVectors(tan, up).normalize();
                    if (perp.length() < 0.1) perp = new THREE.Vector3(1, 0, 0);
                    const distFactor = 1 + t * 1.5;
                    const width = ribbonWidth * distFactor;
                    leftEdge.push(pt.clone().add(perp.clone().multiplyScalar(-width / 2)));
                    rightEdge.push(pt.clone().add(perp.clone().multiplyScalar(width / 2)));
                }

                const edgeMat = new THREE.LineBasicMaterial({
                    color: pathColor,
                    transparent: true,
                    opacity: 0.8
                });

                const leftGeo = new THREE.BufferGeometry().setFromPoints(leftEdge);
                const rightGeo = new THREE.BufferGeometry().setFromPoints(rightEdge);
                flightPathMesh.add(new THREE.Line(leftGeo, edgeMat));
                flightPathMesh.add(new THREE.Line(rightGeo, edgeMat));

                // Add to SCENE (world space) not camera
                scene.add(flightPathMesh);

            } catch (e) {
                console.error('Flight path error:', e);
            }
        }

        function updateRunwayVisualization() {
            // Remove existing runway
            if (runwayMesh) {
                scene.remove(runwayMesh);
                runwayMesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                runwayMesh = null;
            }

            // Only show during takeoff/landing phases
            if (!state.simulation.active) return;
            const progress = state.simulation.progress;
            const isTakeoffOrLanding = progress < 0.10 || progress > 0.90;
            if (!isTakeoffOrLanding) return;

            const { from, to } = state.simulation.route;
            const airport = progress < 0.5 ? from : to;
            const routeBearing = progress < 0.5 ? state.simulation.route.bearing : (state.simulation.route.bearing + 180) % 360;

            // Get actual runway data if available
            const activeRunway = progress < 0.5
                ? state.simulation.departureRunway
                : selectBestRunway(to, (routeBearing + 180) % 360); // Arrival runway

            const ftToMeters = 0.3048;

            // Use real runway dimensions if available, otherwise defaults
            const runwayLengthFt = activeRunway?.len || 8000;
            const runwayWidthFt = activeRunway?.wid || 150;
            const runwayLength = runwayLengthFt * ftToMeters; // Convert to meters
            const runwayWidth = runwayWidthFt * ftToMeters;

            // Camera is at aircraft position, looking forward (-Z direction)
            // For takeoff: aircraft starts at threshold, runway extends ahead
            // For landing: aircraft is approaching, runway is ahead
            const x = 0;
            const z = progress < 0.5
                ? -runwayLength / 2  // Takeoff: center runway ahead (we're at threshold)
                : -runwayLength / 2 - (state.altitude * ftToMeters) / Math.tan(3 * Math.PI / 180); // Landing: position based on glide slope
            const y = -state.altitude * ftToMeters; // Ground is below us by our altitude

            // Create runway group
            runwayMesh = new THREE.Group();

            // Main runway surface - aligned with camera forward direction
            const runwayGeometry = new THREE.PlaneGeometry(runwayWidth, runwayLength);
            const runwayMaterial = new THREE.MeshBasicMaterial({
                color: 0x2a2a2a,
                transparent: true,
                opacity: 0.95,
                side: THREE.DoubleSide
            });
            const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
            runway.rotation.x = -Math.PI / 2; // Lay flat on ground
            runwayMesh.add(runway);

            // Center line (dashed effect with multiple segments)
            const dashLength = 30;
            const gapLength = 20;
            const numDashes = Math.floor(runwayLength * 0.8 / (dashLength + gapLength));
            const lineMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });

            for (let i = 0; i < numDashes; i++) {
                const dashGeometry = new THREE.PlaneGeometry(1.5, dashLength);
                const dash = new THREE.Mesh(dashGeometry, lineMaterial);
                dash.rotation.x = -Math.PI / 2;
                dash.position.y = 0.1;
                dash.position.z = -runwayLength * 0.4 + i * (dashLength + gapLength) + dashLength / 2;
                runwayMesh.add(dash);
            }

            // Threshold markings at near end
            const thresholdWidth = runwayWidth * 0.7;
            const stripeWidth = 3;
            const stripeLength = 40;
            const numStripes = 8;
            const stripeSpacing = thresholdWidth / numStripes;

            for (let i = 0; i < numStripes; i++) {
                const stripeGeometry = new THREE.PlaneGeometry(stripeWidth, stripeLength);
                const stripe = new THREE.Mesh(stripeGeometry, lineMaterial);
                stripe.rotation.x = -Math.PI / 2;
                stripe.position.x = (i - (numStripes - 1) / 2) * stripeSpacing;
                stripe.position.y = 0.1;
                stripe.position.z = runwayLength / 2 - 80; // Near threshold
                runwayMesh.add(stripe);
            }

            // Edge lights (yellow) - small realistic size
            const lightGeometry = new THREE.SphereGeometry(0.15, 6, 6);
            const edgeLightMaterial = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                transparent: true,
                opacity: 0.95
            });
            const numLights = 25;

            for (let i = 0; i <= numLights; i++) {
                const t = i / numLights;
                const alongZ = (t - 0.5) * runwayLength;

                for (let side = -1; side <= 1; side += 2) {
                    const light = new THREE.Mesh(lightGeometry, edgeLightMaterial);
                    light.position.x = side * (runwayWidth / 2 + 1);
                    light.position.z = alongZ;
                    light.position.y = 0.15;
                    runwayMesh.add(light);
                }
            }

            // Centerline lights (green at start, white in middle) - small realistic size
            const clLightGeometry = new THREE.SphereGeometry(0.1, 6, 6);
            for (let i = 0; i < 30; i++) {
                const t = i / 30;
                const isGreen = t < 0.15; // First 15% are green (runway remaining)
                const clLightMaterial = new THREE.MeshBasicMaterial({
                    color: isGreen ? 0x00ff00 : 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                const clLight = new THREE.Mesh(clLightGeometry, clLightMaterial);
                clLight.position.x = 0;
                clLight.position.z = runwayLength * 0.45 - t * runwayLength * 0.9;
                clLight.position.y = 0.1; // Flush with ground
                runwayMesh.add(clLight);
            }

            // Position the whole runway group
            runwayMesh.position.set(x, y, z);
            scene.add(runwayMesh);
        }

        // Track current flight phase to avoid unnecessary DOM updates
        let currentFlightPhase = '';

        function updateFlightPhaseAnnunciator(phase) {
            if (phase === currentFlightPhase) return;
            currentFlightPhase = phase;

            const statusEl = document.getElementById('simStatus');
            const textEl = document.getElementById('simStatusText');
            if (!statusEl || !textEl) return;

            // Remove all phase classes
            statusEl.classList.remove(
                'phase-takeoff', 'phase-climb', 'phase-cruise',
                'phase-descent', 'phase-approach', 'phase-final',
                'phase-flare', 'phase-touchdown', 'phase-rollout'
            );

            // Map phase to display text and CSS class
            const phaseMap = {
                'TAKEOFF': { text: 'Takeoff', class: 'phase-takeoff' },
                'CLIMB': { text: 'Climb', class: 'phase-climb' },
                'CRUISE': { text: 'Cruise', class: 'phase-cruise' },
                'DESCENT': { text: 'Descent', class: 'phase-descent' },
                'APPROACH': { text: 'Approach', class: 'phase-approach' },
                'FINAL': { text: 'Final', class: 'phase-final' },
                'FLARE': { text: 'Landing', class: 'phase-flare' },
                'TOUCHDOWN': { text: 'Landing', class: 'phase-touchdown' },
                'ROLLOUT': { text: 'Landing', class: 'phase-rollout' }
            };

            const phaseInfo = phaseMap[phase] || { text: phase, class: '' };
            textEl.textContent = phaseInfo.text;
            if (phaseInfo.class) {
                statusEl.classList.add(phaseInfo.class);
            }
        }

        // ============================================
        // HUD UPDATES
        // ============================================

        function updateHUD() {
            // Altitude
            document.getElementById('altitudeCurrent').textContent = Math.round(state.altitude).toLocaleString();

            // VSI (below altitude)
            const vsiEl = document.getElementById('vsiValue');
            const vsiPrefix = state.verticalSpeed >= 0 ? '+' : '';
            vsiEl.textContent = `${vsiPrefix}${Math.round(state.verticalSpeed)} fpm`;
            vsiEl.className = 'tape-secondary' + (state.verticalSpeed > 100 ? ' positive' : state.verticalSpeed < -100 ? ' negative' : '');

            // Speed - use IAS (Indicated Airspeed) if available, otherwise groundspeed
            const displaySpeed = state.indicatedAirspeed || state.groundSpeed;
            document.getElementById('speedCurrent').textContent = Math.round(displaySpeed);

            // Acceleration (knots per minute)
            const accelEl = document.getElementById('accelValue');
            const accelPrefix = state.acceleration >= 0 ? '+' : '';
            accelEl.textContent = `${accelPrefix}${Math.round(state.acceleration)} kt/m`;
            accelEl.className = 'tape-secondary' + (state.acceleration > 5 ? ' positive' : state.acceleration < -5 ? ' negative' : '');

            // Update compass
            updateCompass();

            // Update wind dial
            updateWindDial();

            // Update traffic mini map
            updateTrafficMap();

            // Update flight rules (VFR/MVFR/IFR)
            updateFlightRules();
        }

        function updateFlightRules() {
            const rulesEl = document.getElementById('flightRules');
            if (!rulesEl) return;

            // Determine flight rules based on altitude and simulated visibility
            // IFR: Below cloud deck or low visibility
            // MVFR: Marginal conditions
            // VFR: Clear conditions
            let rules = 'VFR';
            let ruleClass = 'vfr';

            if (state.simulation.active) {
                const progress = state.simulation.progress;
                const alt = state.altitude;

                // Simulate varying conditions during flight
                // Generally VFR, but can enter MVFR/IFR based on altitude and phase
                if (alt < 1000) {
                    // Low altitude - check visibility conditions
                    if (state.overlays.visibility) {
                        rules = 'MVFR';
                        ruleClass = 'mvfr';
                    }
                } else if (alt > 18000) {
                    // Class A airspace - always IFR
                    rules = 'IFR';
                    ruleClass = 'ifr';
                } else if (state.overlays.clouds || state.overlays.icing) {
                    // In clouds = IFR
                    if (alt > 8000 && alt < 15000) {
                        rules = 'IFR';
                        ruleClass = 'ifr';
                    }
                }
            }

            rulesEl.textContent = rules;
            rulesEl.className = 'flight-rules ' + ruleClass;
        }

        function generateCompassDial() {
            const dial = document.getElementById('compassDial');
            const cardinals = { 0: 'N', 90: 'E', 180: 'S', 270: 'W' };

            // Generate ticks every 10 degrees
            for (let deg = 0; deg < 360; deg += 10) {
                const tick = document.createElement('div');
                tick.className = deg % 30 === 0 ? 'compass-tick major' : 'compass-tick';
                tick.style.transform = `translateX(-50%) rotate(${deg}deg)`;
                dial.appendChild(tick);

                // Add labels every 30 degrees
                if (deg % 30 === 0) {
                    const label = document.createElement('div');
                    const displayDeg = deg === 0 ? 0 : deg;

                    if (cardinals[deg]) {
                        label.className = 'compass-label cardinal';
                        label.textContent = cardinals[deg];
                    } else {
                        label.className = 'compass-label';
                        label.textContent = (deg / 10).toString();
                    }

                    label.style.transform = `translateX(-50%) rotate(${deg}deg)`;
                    dial.appendChild(label);
                }
            }
        }

        function updateCompass() {
            const dial = document.getElementById('compassDial');
            const headingDisplay = document.getElementById('compassHeading');
            const trackDisplay = document.getElementById('compassTrack');

            // Rotate dial opposite to heading (so current heading is at top)
            dial.style.transform = `rotate(${-state.heading}deg)`;

            // Update heading value (current magnetic heading)
            headingDisplay.textContent = Math.round(state.heading).toString().padStart(3, '0');

            // Target heading - only show if set by pilot, otherwise '---'
            if (state.targetHeading !== null) {
                trackDisplay.textContent = Math.round(state.targetHeading).toString().padStart(3, '0');
            } else {
                trackDisplay.textContent = '---';
            }
        }

        // Wind data fetching from Open-Meteo API
        let lastWindFetch = 0;
        const WIND_FETCH_INTERVAL = 30000; // Fetch every 30 seconds

        async function fetchWindData(lat, lon) {
            if (PERFORMANCE_MODE) return null; // Disable all external fetching
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=wind_speed_10m,wind_direction_10m&wind_speed_unit=kn`;
                const response = await fetch(url);
                if (!response.ok) return null;
                const data = await response.json();
                const current = data.current || {};
                return {
                    speed: current.wind_speed_10m || 0,
                    direction: current.wind_direction_10m || 0
                };
            } catch (e) {
                console.warn('Wind fetch failed:', e);
                return null;
            }
        }

        async function updateWindFromAPI() {
            const now = Date.now();
            if (now - lastWindFetch < WIND_FETCH_INTERVAL) return;
            lastWindFetch = now;

            const windData = await fetchWindData(state.position.lat, state.position.lon);
            if (windData) {
                state.windSpeed = windData.speed;
                state.windDirection = windData.direction;
            }
        }

        function updateWindDial() {
            const windRotator = document.getElementById('windDialRotator');
            const windSpeedDisplay = document.getElementById('windSpeedValue');
            const windSock = document.querySelector('.wind-sock');

            if (!windRotator || !windSpeedDisplay || !windSock) return;

            // Calculate relative wind direction
            // Wind FROM direction relative to aircraft heading
            // Windsock points in the direction wind is BLOWING TO (opposite of FROM)
            // So we add 180° to show the sock streaming downwind
            const windBlowingTo = (state.windDirection + 180) % 360;
            const relativeWind = (windBlowingTo - state.heading + 360) % 360;

            // Rotate the windsock - it streams in the direction wind is blowing
            windRotator.style.transform = `rotate(${relativeWind}deg)`;

            // Scale windsock length based on wind speed
            // At 0 kts: very short (collapsed), at 30+ kts: fully extended
            const maxWindSpeed = 30;
            const windFactor = Math.min(1, state.windSpeed / maxWindSpeed);

            // Get all windsock segments and scale their LENGTH (height) only
            // Width stays constant - like a real windsock extending in wind
            const segments = windSock.querySelectorAll('.wind-sock-segment');
            segments.forEach((seg, i) => {
                // Base heights for each segment - these scale with wind
                const baseHeights = [8, 7, 7, 6, 5];
                // Widths stay constant
                const baseWidths = [12, 11, 9, 7, 5];

                // Height scale: minimum 0.3 at calm (droopy), 1.0 at max wind (fully extended)
                const heightScale = 0.3 + (windFactor * 0.7);

                // Tail segments droop more in light wind (collapse toward the end)
                const tailDroop = (1 - windFactor) * (i * 0.15);
                const segmentHeightFactor = Math.max(0.2, heightScale - tailDroop);

                seg.style.height = `${baseHeights[i] * segmentHeightFactor}px`;
                seg.style.width = `${baseWidths[i]}px`; // Width stays constant

                // Tail fades slightly in light wind
                seg.style.opacity = 0.9 - (i * 0.05 * (1 - windFactor));
            });

            // Update wind speed display
            windSpeedDisplay.textContent = Math.round(state.windSpeed);

            // Fetch real wind data periodically (non-blocking)
            updateWindFromAPI();
        }

        function updateTrafficMap() {
            const rotator = document.getElementById('trafficMapRotator');
            if (!rotator) return;

            // Rotate the map opposite to heading (north-up relative to aircraft)
            rotator.style.transform = `rotate(${-state.heading}deg)`;

            // Clear existing aircraft markers
            rotator.innerHTML = '';

            // Add aircraft from live traffic data
            const mapRadius = 60; // pixels (half of 140px container minus padding)
            const rangeNM = 30; // nautical miles radius

            for (const ac of liveTrafficData) {
                if (!ac.lat || !ac.lon) continue;

                // Filter by altitude - only show aircraft within 1000ft of ownship
                const acAlt = ac.alt_baro || ac.alt_geom || 0;
                const altDiff = Math.abs(acAlt - state.altitude);
                if (altDiff > 1000) continue;

                // Calculate relative position
                const dLat = ac.lat - state.position.lat;
                const dLon = ac.lon - state.position.lon;

                // Convert to nautical miles (approximate)
                const nmPerDegLat = 60;
                const nmPerDegLon = 60 * Math.cos(state.position.lat * Math.PI / 180);
                const distNorth = dLat * nmPerDegLat;
                const distEast = dLon * nmPerDegLon;

                // Convert to pixels on map
                const scale = mapRadius / rangeNM;
                const x = distEast * scale;
                const y = -distNorth * scale; // Negative because screen Y is inverted

                // Skip if outside map bounds
                const dist = Math.sqrt(x * x + y * y);
                if (dist > mapRadius) continue;

                // Create aircraft marker
                const marker = document.createElement('div');
                marker.className = 'traffic-map-aircraft';

                // Position relative to center
                marker.style.left = `calc(50% + ${x}px)`;
                marker.style.top = `calc(50% + ${y}px)`;

                // Rotate arrow to show aircraft heading
                const track = ac.track || 0;
                marker.style.transform = `rotate(${track}deg)`;

                // Color based on relative altitude (using signed difference)
                const signedAltDiff = acAlt - state.altitude;
                if (signedAltDiff > 500) {
                    marker.classList.add('above');
                } else if (signedAltDiff < -500) {
                    marker.classList.add('below');
                }

                // Scale size based on altitude (higher = larger icon)
                const altScale = 0.6 + Math.min(1, acAlt / 40000) * 0.8;
                marker.style.setProperty('--ac-scale', altScale);

                rotator.appendChild(marker);
            }
        }

        // ============================================
        // CAMERA UPDATE
        // ============================================

        function updateCamera() {
            const ftToMeters = 0.3048;
            const altMeters = state.altitude * ftToMeters;
            const pilotEyeHeight = 3; // 3 meters (~10ft) pilot eye height

            // Camera height in RELATIVE coordinates (same as terrain)
            // Terrain at aircraft position is at y=0, so camera should be at altitude + eye height
            let cameraHeight = altMeters + pilotEyeHeight;

            // Ensure minimum height above ground (pilot eye level)
            cameraHeight = Math.max(cameraHeight, pilotEyeHeight);

            camera.position.y = cameraHeight;

            // Apply attitude with limits for landing
            // Clamp pitch to prevent looking underground during final approach
            let effectivePitch = state.pitch;
            if (state.altitude < 1000 && effectivePitch < -3) {
                // Gradually reduce nose-down pitch near ground
                const groundProximityFactor = state.altitude / 1000;
                effectivePitch = effectivePitch * groundProximityFactor + (-3) * (1 - groundProximityFactor);
            }

            const pitchRad = THREE.MathUtils.degToRad(-effectivePitch);
            const rollRad = THREE.MathUtils.degToRad(-state.roll);
            const headingRad = THREE.MathUtils.degToRad(-state.heading);

            camera.rotation.order = 'YXZ';
            camera.rotation.y = headingRad;
            camera.rotation.x = pitchRad;
            camera.rotation.z = rollRad;
        }

        // ============================================
        // CONTROLS
        // ============================================

        function setupControls() {
            // Position input
            document.getElementById('positionInput').addEventListener('change', async (e) => {
                const value = e.target.value.trim();

                if (/^[A-Z]{4}$/i.test(value)) {
                    // ICAO code - use approximate coordinates
                    const airports = {
                        'KLAX': { lat: 33.9425, lon: -118.4081 },
                        'KJFK': { lat: 40.6413, lon: -73.7781 },
                        'KSFO': { lat: 37.6213, lon: -122.3790 },
                        'KORD': { lat: 41.9742, lon: -87.9073 },
                        'KATL': { lat: 33.6407, lon: -84.4277 },
                        'KDEN': { lat: 39.8561, lon: -104.6737 },
                        'KSEA': { lat: 47.4502, lon: -122.3088 },
                        'KMIA': { lat: 25.7959, lon: -80.2870 }
                    };

                    const icao = value.toUpperCase();
                    if (airports[icao]) {
                        state.position = airports[icao];
                        await loadTerrainData(state.position.lat, state.position.lon);
                    }
                } else if (/^-?\d+\.?\d*,\s*-?\d+\.?\d*$/.test(value)) {
                    const [lat, lon] = value.split(',').map(v => parseFloat(v.trim()));
                    state.position = { lat, lon };
                    await loadTerrainData(lat, lon);
                }
            });

            // Use location button
            document.getElementById('useLocationBtn').addEventListener('click', () => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(async (pos) => {
                        state.position = {
                            lat: pos.coords.latitude,
                            lon: pos.coords.longitude
                        };
                        document.getElementById('positionInput').value =
                            `${state.position.lat.toFixed(4)}, ${state.position.lon.toFixed(4)}`;
                        await loadTerrainData(state.position.lat, state.position.lon);
                    });
                }
            });

        }

        function setupOverlayToggles() {
            document.querySelectorAll('.overlay-btn').forEach(btn => {
                const layer = btn.dataset.layer;

                // Set initial button state based on state.overlays
                if (state.overlays[layer]) {
                    btn.classList.add('active');
                }

                btn.addEventListener('click', () => {
                    btn.classList.toggle('active');
                    state.overlays[layer] = btn.classList.contains('active');

                    switch(layer) {
                        case 'terrain':
                            if (terrainPoints) terrainPoints.visible = state.overlays.terrain;
                            break;
                        case 'traffic':
                            createSimulatedTraffic();
                            break;
                        case 'weather':
                            createSimulatedHazards();
                            break;
                        case 'airspace':
                        case 'towers':
                        case 'tfr':
                            createSimulatedObstacles();
                            break;
                        case 'buildings':
                            updateBuildingsOverlay();
                            break;
                        case 'clouds':
                            updateCloudsOverlay();
                            break;
                        case 'icing':
                            updateIcingOverlay();
                            break;
                        case 'visibility':
                            updateVisibilityOverlay();
                            break;
                    }
                });
            });
        }

        function updateInfoDisplay() {
            document.getElementById('infoLat').textContent = state.position.lat.toFixed(4);
            document.getElementById('infoLon').textContent = state.position.lon.toFixed(4);

            // Update ground elevation from terrain data
            if (state.terrainData && state.terrainData.elevations) {
                const centerIdx = Math.floor(state.terrainData.elevations.length / 2);
                const groundElev = state.terrainData.elevations[centerIdx] || 0;
                document.getElementById('infoGround').textContent = Math.round(groundElev) + ' ft';
            }

            // Update HDG, PITCH, ROLL
            document.getElementById('infoHdg').textContent = Math.round((state.heading + 360) % 360).toString().padStart(3, '0') + '°';
            document.getElementById('infoPitch').textContent = state.pitch.toFixed(1) + '°';
            document.getElementById('infoRoll').textContent = state.roll.toFixed(1) + '°';

            // Update fuel display
            const fuelPercent = (state.fuel / SR22.fuelCapacity) * 100;
            document.getElementById('infoFuel').textContent = state.fuel.toFixed(1) + ' gal';

            const fuelBar = document.getElementById('fuelBar');
            fuelBar.style.width = fuelPercent + '%';
            fuelBar.classList.remove('low', 'critical');
            if (fuelPercent <= 15) {
                fuelBar.classList.add('critical');
            } else if (fuelPercent <= 30) {
                fuelBar.classList.add('low');
            }
        }

        // Debug panel minimize function
        function minimizeDebugPanel() {
            const content = document.getElementById('debug-content');
            const btn = document.getElementById('debug-minimize-btn');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                btn.textContent = '−';
            } else {
                content.style.display = 'none';
                btn.textContent = '+';
            }
        }

        function setupPanelControls() {
            const toggleBtn = document.getElementById('togglePanelBtn');
            const resetBtn = document.getElementById('resetBtn');
            const panel = document.getElementById('svsControls');

            // Track panel state: normal -> expanded -> minimized -> normal
            let panelState = 'normal';

            toggleBtn.addEventListener('click', () => {
                const expandIcon = toggleBtn.querySelector('.expand-icon');
                const collapseIcon = toggleBtn.querySelector('.collapse-icon');

                if (panelState === 'normal') {
                    panel.classList.add('expanded');
                    panel.classList.remove('fully-minimized');
                    expandIcon.style.display = 'none';
                    collapseIcon.style.display = 'block';
                    panelState = 'expanded';
                } else if (panelState === 'expanded') {
                    panel.classList.remove('expanded');
                    panel.classList.add('fully-minimized');
                    expandIcon.style.display = 'block';
                    collapseIcon.style.display = 'none';
                    panelState = 'minimized';
                } else {
                    panel.classList.remove('fully-minimized');
                    expandIcon.style.display = 'block';
                    collapseIcon.style.display = 'none';
                    panelState = 'normal';
                }
            });

            resetBtn.addEventListener('click', () => {
                resetSimulation();
            });
        }

        function resetSimulation() {
            // Stop any active simulation
            if (state.simulation.active) {
                stopSimulation();
            }

            // Reset inputs
            document.getElementById('routeFrom').value = '';
            document.getElementById('routeTo').value = '';

            // Reset state to defaults - start at LAX on ground
            state.position = { lat: 33.9425, lon: -118.4081 }; // LAX coordinates
            state.altitude = 0; // Start at zero (ground level)
            state.heading = 250; // LAX runway 25 heading
            state.pitch = 0;
            state.roll = 0;
            state.groundSpeed = 0;
            state.verticalSpeed = 0;
            state.acceleration = 0;
            state.fuel = SR22.fuelCapacity;
            state.fuelBurnRate = 0;

            // Reset progress panel
            document.getElementById('progressRoute').textContent = '---';
            document.getElementById('progressDistance').textContent = '0 nm';
            document.getElementById('progressPercent').textContent = '0%';
            document.getElementById('progressETA').textContent = '--:--';
            document.getElementById('progressFill').style.width = '0%';

            // Update displays and camera
            updateInfoDisplay();
            updateHUD();
            updateCamera(); // Critical: Reset camera to ground altitude

            // Clean up flight path
            if (flightPathMesh) {
                scene.remove(flightPathMesh);
                if (flightPathMesh.geometry) flightPathMesh.geometry.dispose();
                if (flightPathMesh.material) flightPathMesh.material.dispose();
                flightPathMesh = null;
            }
            // Clean up runway
            if (runwayMesh) {
                scene.remove(runwayMesh);
                runwayMesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                runwayMesh = null;
            }
            const guideLine = document.getElementById('fpvGuideLine');
            if (guideLine) guideLine.style.display = 'none';

            // Reload terrain at default position
            loadTerrainData(state.position.lat, state.position.lon);
        }

        // ============================================
        // FLIGHT SIMULATION
        // ============================================

        function setupSimulationControls() {
            const goBtn = document.getElementById('goBtn');
            const swapBtn = document.getElementById('swapRouteBtn');

            goBtn.addEventListener('click', () => {
                if (state.simulation.active) {
                    stopSimulation();
                } else {
                    startSimulation();
                }
            });

            // Swap route origin/destination
            swapBtn.addEventListener('click', () => {
                const fromInput = document.getElementById('routeFrom');
                const toInput = document.getElementById('routeTo');
                const temp = fromInput.value;
                fromInput.value = toInput.value;
                toInput.value = temp;
            });
        }

        function startSimulation() {
            const fromInput = resolveAirportCode(document.getElementById('routeFrom').value);
            const toInput = resolveAirportCode(document.getElementById('routeTo').value);

            // Get departure and destination coordinates
            const from = AIRPORTS[fromInput];
            const to = AIRPORTS[toInput];

            if (!from || !to) {
                alert('Please enter valid airport codes (e.g., LAX, SFO, JFK, or KLAX, KSFO, KJFK)');
                return;
            }

            // Calculate route properties
            const distance = calculateDistance(from.lat, from.lon, to.lat, to.lon);
            const bearing = calculateBearing(from.lat, from.lon, to.lat, to.lon);

            // Set cruise altitude based on distance (longer = higher, capped for 200kt sim)
            const cruiseAlt = Math.min(35000, Math.max(10000, 8000 + distance * 15));

            // Generate avoidance route with waypoints around weather/hazards
            const { waypoints, hazards } = generateAvoidanceRoute(from, to, bearing, distance);

            // Calculate realistic duration based on SR22 cruise speed
            // SR22 cruises at ~180 kts, but we accelerate time for visualization
            // Time compression: 1 second real = ~15 seconds flight time (15x speed)
            // At 180 kts, that's 0.75nm per real second
            // So 300nm flight = 400 seconds = 6.7 minutes real time
            const simSpeedMultiplier = 0.75; // nm per second of simulation (15x time compression)
            const duration = Math.max(120000, Math.min(900000, (distance / simSpeedMultiplier) * 1000));

            console.log(`Route: ${fromInput} → ${toInput}, Distance: ${distance.toFixed(0)}nm, Duration: ${(duration/1000).toFixed(0)}s, Waypoints: ${waypoints.length}`);

            state.simulation = {
                active: true,
                route: { from, to, distance, bearing, waypoints, hazards },
                progress: 0,
                startTime: performance.now(),
                duration: duration,
                cruiseAltitude: cruiseAlt,
                lastTerrainUpdate: 0,
                distanceTraveled: 0
            };

            // Update UI
            const goBtn = document.getElementById('goBtn');
            goBtn.classList.add('active');
            goBtn.querySelector('.play-icon').style.display = 'none';
            goBtn.querySelector('.stop-icon').style.display = 'block';

            document.getElementById('simProgressPanel').style.display = 'block';
            document.getElementById('simStatus').classList.add('visible');
            updateFlightPhaseAnnunciator('TAKEOFF');

            // Minimize controls panel
            document.getElementById('svsControls').classList.add('minimized');

            // Auto-enable all overlays for flight
            state.overlays.terrain = true;
            state.overlays.traffic = true;
            state.overlays.weather = true;
            state.overlays.airspace = true;
            state.overlays.towers = true;
            state.overlays.tfr = true;
            state.overlays.visibility = true;

            // Update button states to match
            document.querySelectorAll('.overlay-btn').forEach(btn => {
                btn.classList.add('active');
            });

            // Refresh overlay visuals
            createSimulatedTraffic();
            createSimulatedHazards();
            createSimulatedObstacles();
            updateVisibilityOverlay();

            // Initialize position at departure runway threshold
            // Select the best runway for departure based on route bearing
            const departureRunway = selectBestRunway(from, bearing);
            state.simulation.departureRunway = departureRunway;

            if (departureRunway) {
                // Start at runway threshold, use runway heading
                state.position = { lat: departureRunway.lat, lon: departureRunway.lon };
                state.heading = departureRunway.hdg;
                console.log(`Departure: Runway ${departureRunway.id} (${departureRunway.hdg}°)`);
            } else {
                // Fallback to airport reference point
                state.position = { lat: from.lat, lon: from.lon };
                state.heading = bearing;
            }
            state.altitude = 0; // Start at zero (ground level) - will rise with simulation
            state.groundSpeed = 0; // Start stationary on runway

            // Reset fuel to full tank
            state.fuel = SR22.fuelCapacity;
            state.fuelBurnRate = 0;

            // Update progress panel
            document.getElementById('progressRoute').textContent = `${fromInput} → ${toInput}`;
            document.getElementById('progressDistance').textContent = `${Math.round(distance)} nm`;
            document.getElementById('progressPercent').textContent = '0%';
            const etaMinutes = Math.ceil(duration / 60000);
            document.getElementById('progressETA').textContent = `${etaMinutes}:00`;

            // Load initial terrain
            loadTerrainData(state.position.lat, state.position.lon);

            // Refresh buildings overlay if enabled
            if (state.overlays.buildings) {
                updateBuildingsOverlay();
            }
        }

        function stopSimulation() {
            // Get destination airport info before clearing route
            const route = state.simulation.route;
            const destAirport = route ? route.to : null;

            state.simulation.active = false;
            state.simulation.progress = 0;

            // Update UI
            const goBtn = document.getElementById('goBtn');
            goBtn.classList.remove('active');
            goBtn.querySelector('.play-icon').style.display = 'block';
            goBtn.querySelector('.stop-icon').style.display = 'none';

            document.getElementById('simProgressPanel').style.display = 'none';
            document.getElementById('simStatus').classList.remove('visible');
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressPercent').textContent = '0%';

            // Expand controls panel
            document.getElementById('svsControls').classList.remove('minimized');

            // Reset to destination airport position and altitude
            if (destAirport) {
                state.position = { lat: destAirport.lat, lon: destAirport.lon };
                state.altitude = 0; // On ground (zero altitude)
            }

            // Zero out flight parameters - plane is stopped on ground
            state.groundSpeed = 0;
            state.verticalSpeed = 0;
            state.acceleration = 0;
            state.pitch = 0;
            state.roll = 0;

            // Update displays to show stopped state
            updateHUD();
            updateInfoDisplay();
        }

        function updateSimulation() {
            // Skip internal simulation when X-Plane mode is active and receiving data
            if (xplaneState.enabled && xplaneState.receiving) {
                return; // X-Plane is providing flight data
            }

            if (!state.simulation.active) return;

            const now = performance.now();
            const elapsed = now - state.simulation.startTime;
            const progress = Math.min(1, elapsed / state.simulation.duration);
            state.simulation.progress = progress;

            const { from, to, distance, bearing, waypoints } = state.simulation.route;
            const cruiseAlt = state.simulation.cruiseAltitude;

            // Store previous position for distance calculation
            const prevPos = { ...state.position };

            // Cirrus SR22 Flight Profile with realistic performance
            // Capped at service ceiling of 17,500 ft and 200 kts
            const effectiveCruiseAlt = Math.min(cruiseAlt, SR22.serviceCeiling);

            let targetAlt;
            let targetPitch = 0;
            let targetSpeed;
            let flightPhase = '';
            let fuelBurn = SR22.fuelBurnIdle;

            let targetVSI = 0;

            if (progress < 0.03) {
                // Runway roll - accelerating on ground (0-3%)
                flightPhase = 'TAKEOFF';
                const rollProgress = progress / 0.03;
                targetAlt = 0; // Stay on runway at ground level
                targetPitch = rollProgress * 2; // Very slight nose-up rotation
                targetSpeed = rollProgress * SR22.stallSpeed; // 0 to 60 kts (rotation speed)
                targetVSI = 0;
                fuelBurn = SR22.fuelBurnClimb;
            } else if (progress < 0.08) {
                // Rotation and liftoff (3-8%)
                flightPhase = 'TAKEOFF';
                const liftoffProgress = (progress - 0.03) / 0.05;
                targetAlt = liftoffProgress * 500; // Climb from 0 to 500ft AGL
                targetPitch = 2 + liftoffProgress * 8; // Gradual rotation to 10°
                targetSpeed = SR22.stallSpeed + liftoffProgress * (SR22.climbSpeed - SR22.stallSpeed);
                targetVSI = 800 * liftoffProgress; // Gradual VSI increase
                fuelBurn = SR22.fuelBurnClimb;
            } else if (progress < 0.15) {
                // Initial climb - cleaning up (8-15%)
                flightPhase = 'CLIMB';
                const climbProgress = (progress - 0.08) / 0.07;
                targetAlt = 500 + climbProgress * 1500; // 500 to 2000ft AGL
                targetPitch = 10 - climbProgress * 2; // 10° down to 8°
                targetSpeed = SR22.climbSpeed + climbProgress * 10; // 110 to 120 kts
                targetVSI = 800 + climbProgress * 400; // Increasing to 1200 fpm
                fuelBurn = SR22.fuelBurnClimb;
            } else if (progress < 0.25) {
                // Climb to cruise altitude (15-25%)
                flightPhase = 'CLIMB';
                const climbProgress = (progress - 0.15) / 0.10;
                targetAlt = 2000 + (effectiveCruiseAlt - 2000) * climbProgress;
                targetPitch = 8 - climbProgress * 5; // 8° down to 3°
                targetSpeed = 120 + climbProgress * (SR22.cruiseSpeed - 120); // 120 to 180 kts
                targetVSI = SR22.maxClimbRate - climbProgress * 800;
                fuelBurn = SR22.fuelBurnClimb * 0.9;
            } else if (progress < 0.35) {
                // Level off to cruise (25-35%)
                flightPhase = 'CRUISE';
                const levelProgress = (progress - 0.25) / 0.10;
                targetAlt = effectiveCruiseAlt;
                targetPitch = 3 - levelProgress * 1; // 3° down to 2°
                targetSpeed = SR22.cruiseSpeed;
                targetVSI = SR22.maxClimbRate * 0.5 * (1 - levelProgress); // Decreasing to 0
                fuelBurn = SR22.fuelBurnCruise;
            } else if (progress < 0.70) {
                // Cruise at 75% power (30-70%)
                flightPhase = 'CRUISE';
                targetAlt = effectiveCruiseAlt;
                targetPitch = 2;
                targetSpeed = SR22.cruiseSpeed; // 180 kts
                targetVSI = 0;
                fuelBurn = SR22.fuelBurnCruise;
            } else if (progress < 0.82) {
                // Top of descent (70-82%)
                flightPhase = 'DESCENT';
                const descentProgress = (progress - 0.70) / 0.12;
                targetAlt = effectiveCruiseAlt - (effectiveCruiseAlt - 3000) * descentProgress;
                targetPitch = -3;
                targetSpeed = SR22.cruiseSpeed - descentProgress * 20; // 180 to 160 kts
                targetVSI = -1000;
                fuelBurn = SR22.fuelBurnDescent;
            } else if (progress < 0.90) {
                // Approach (82-90%)
                flightPhase = 'APPROACH';
                const approachProgress = (progress - 0.82) / 0.08;
                targetAlt = 3000 - (3000 - 500) * approachProgress; // 3000 to 500ft AGL
                targetPitch = -4;
                targetSpeed = 160 - approachProgress * 60; // 160 to 100 kts
                targetVSI = -800;
                fuelBurn = SR22.fuelBurnDescent;
            } else if (progress < 0.96) {
                // Final approach (90-96%) - descend to 50ft
                flightPhase = 'FINAL';
                const finalProgress = (progress - 0.90) / 0.06;
                targetAlt = 500 - (500 - 50) * finalProgress; // 500 to 50ft AGL
                targetPitch = -3;
                targetSpeed = 100 - finalProgress * 15; // 100 to 85 kts
                targetVSI = -600 + finalProgress * 200; // -600 to -400 fpm
                fuelBurn = SR22.fuelBurnIdle;
            } else if (progress < 0.97) {
                // Flare (96-97%) - level off just above runway
                flightPhase = 'FLARE';
                const flareProgress = (progress - 0.96) / 0.01;
                targetAlt = 50 - 40 * flareProgress; // 50ft to 10ft AGL
                targetPitch = -1 + flareProgress * 4; // Nose up for flare
                targetSpeed = 85 - flareProgress * 10; // 85 to 75 kts
                targetVSI = -400 + flareProgress * 350; // Reduce sink to -50 fpm
                fuelBurn = SR22.fuelBurnIdle;
            } else if (progress < 0.975) {
                // Touchdown (97-97.5%) - wheels touch, nose comes down
                flightPhase = 'TOUCHDOWN';
                const touchProgress = (progress - 0.97) / 0.005;
                targetAlt = 10 - 10 * touchProgress; // 10ft to 0ft AGL
                targetPitch = 3 - touchProgress * 5; // Nose down after touchdown
                targetSpeed = 75 - touchProgress * 15; // 75 to 60 kts
                targetVSI = -50 + touchProgress * 50; // Sink to 0
                fuelBurn = SR22.fuelBurnIdle;
            } else {
                // Runway roll and deceleration (97.5-100%)
                flightPhase = 'ROLLOUT';
                const rollProgress = (progress - 0.975) / 0.025;
                targetAlt = 0; // On the ground
                targetPitch = -2; // Slight nose down on ground
                targetSpeed = 60 - rollProgress * 55; // 60 to 5 kts - brake to near stop
                targetVSI = 0;
                fuelBurn = SR22.fuelBurnIdle;
            }

            // Update flight phase annunciator
            updateFlightPhaseAnnunciator(flightPhase);

            // Smooth VSI transitions - gradual changes in climb/descent rate
            state.verticalSpeed = state.verticalSpeed * 0.95 + targetVSI * 0.05;

            // Calculate fuel consumption (accelerated for simulation)
            // Simulation runs faster than real time, so scale fuel burn accordingly
            // Calculate fuel consumption with time acceleration
            // simTimeRatio = how fast we're flying in simulation (nm/hr)
            // Match fuel burn to simulation speed so fuel depletes realistically over the flight
            const simTimeRatio = distance / (state.simulation.duration / 1000 / 3600); // nm/hr simulated
            const realTimeRatio = SR22.cruiseSpeed; // nm/hr real
            const fuelAcceleration = simTimeRatio / realTimeRatio;
            const frameHours = 1 / 60 / 3600; // Approximate frame time in hours (at 60fps)
            state.fuelBurnRate = fuelBurn;
            state.fuel = Math.max(0, state.fuel - fuelBurn * frameHours * fuelAcceleration);

            // Follow waypoints with proper takeoff handling
            let currentPos;
            let currentBearing;

            // Use shared position function for PERFECT sync with path line
            // CRITICAL: This must match the transition point in updateFlightPathLine() (0.15)
            const takeoffEndProgress = 0.15;
            const departureRunway = state.simulation.departureRunway;
            const runwayHeading = departureRunway ? departureRunway.hdg : bearing;

            // Get position using the shared function (same as path line uses)
            currentPos = getFlightPositionAtProgress(progress, state.simulation);

            // Calculate bearing based on flight phase - MUST match path line logic
            if (progress < takeoffEndProgress && departureRunway) {
                // During takeoff - fly straight along runway heading
                currentBearing = runwayHeading;
            } else {
                // After takeoff - calculate bearing to next waypoint
                // Use a look-ahead position to determine heading direction
                const lookAheadProgress = Math.min(1, progress + 0.02); // Look 2% ahead
                const aheadPos = getFlightPositionAtProgress(lookAheadProgress, state.simulation);
                currentBearing = calculateBearing(currentPos.lat, currentPos.lon, aheadPos.lat, aheadPos.lon);
            }

            state.position = currentPos;

            // Calculate actual distance traveled this frame (in NM)
            const frameDist = calculateDistance(prevPos.lat, prevPos.lon, currentPos.lat, currentPos.lon);

            // Store cumulative distance for terrain sync
            if (!state.simulation.distanceTraveled) state.simulation.distanceTraveled = 0;
            state.simulation.distanceTraveled += frameDist;

            // Calculate required heading with smooth transition
            const targetHeading = currentBearing;
            let headingDiff = targetHeading - state.heading;
            if (headingDiff > 180) headingDiff -= 360;
            if (headingDiff < -180) headingDiff += 360;

            // Heading response - faster for better sync with path line
            // During cruise use gentler turns, during climb/descent use faster turns
            // This ensures the aircraft follows the calculated path closely
            const deltaTime = 1/60; // Approximate frame time

            // Faster response during initial climb to align with route
            const isInitialClimb = progress < 0.25;
            const maxTurnRate = isInitialClimb ? 3.0 : 2.0; // degrees per second
            const correctionFactor = isInitialClimb ? 0.08 : 0.05; // 8% or 5% per frame

            const maxTurnPerFrame = maxTurnRate * deltaTime;
            const headingChange = Math.max(-maxTurnPerFrame, Math.min(maxTurnPerFrame, headingDiff * correctionFactor));
            state.heading = (state.heading + headingChange + 360) % 360;

            // Bank angle - max 20° for responsive turns that follow path
            const targetBank = Math.sign(headingDiff) * Math.min(20, Math.abs(headingDiff) * 0.3);
            state.roll = state.roll * 0.95 + targetBank * 0.05; // Faster bank response

            // Altitude and pitch transitions - faster during takeoff/landing for realism
            // During runway roll (progress < 0.03) and rollout (progress > 0.975), plane must stay on ground
            // During final/flare/touchdown (progress > 0.96), use very fast response for crisp landing
            const isRunwayRoll = progress < 0.03;
            const isRollout = progress > 0.975;
            const isFinalLanding = progress > 0.96;
            const isTakeoffOrLanding = progress < 0.15 || progress > 0.85;
            let altSmooth, pitchSmooth;
            if (isRunwayRoll || isRollout) {
                altSmooth = 0.5; // Extremely fast - lock to runway altitude
                pitchSmooth = 0.6;
            } else if (isFinalLanding) {
                altSmooth = 0.7; // Very fast - track altitude closely during landing
                pitchSmooth = 0.75;
            } else if (isTakeoffOrLanding) {
                altSmooth = 0.92;
                pitchSmooth = 0.90;
            } else {
                altSmooth = 0.985;
                pitchSmooth = 0.97;
            }

            // Apply altitude transition with phase-based smoothing
            state.altitude = state.altitude * altSmooth + targetAlt * (1 - altSmooth);

            // Apply pitch transition - critical for takeoff feel
            state.pitch = state.pitch * pitchSmooth + targetPitch * (1 - pitchSmooth);

            // Calculate acceleration from actual speed change
            // SR22 accelerates/decelerates gradually - typical GA aircraft response
            const newSpeed = Math.round(targetSpeed);
            const oldSpeed = state.groundSpeed;
            const deltaSpeed = newSpeed - oldSpeed;

            // Gradual speed changes - SR22 takes time to accelerate/decelerate
            // Max ~5 kts change per second for smooth transitions
            const maxSpeedChangePerFrame = 5 / 60; // 5 kts per second
            const speedChange = Math.max(-maxSpeedChangePerFrame, Math.min(maxSpeedChangePerFrame, deltaSpeed * 0.02));
            state.groundSpeed = state.groundSpeed + speedChange;

            // Calculate acceleration in kt/min from frame speed change
            // speedChange is kts per frame, convert to kts per minute (60 fps assumed)
            const instantAccel = speedChange * 60 * 60; // kts/frame * 60 frames/sec * 60 sec/min = kt/min
            // Less aggressive smoothing so it actually shows changes
            state.acceleration = state.acceleration * 0.8 + instantAccel * 0.2;
            // Round to nearest integer, clamp range
            state.acceleration = Math.round(state.acceleration);
            state.acceleration = Math.max(-50, Math.min(50, state.acceleration));

            // Wind data is fetched from Open-Meteo API in updateWindDial()
            // based on current aircraft position - no simulated wind needed

            // Update progress UI
            const progressPercentVal = Math.round(progress * 100);
            document.getElementById('progressFill').style.width = `${progressPercentVal}%`;
            document.getElementById('progressPercent').textContent = `${progressPercentVal}%`;

            // Update ETA
            const remainingMs = state.simulation.duration - (now - state.simulation.startTime);
            const remainingMin = Math.floor(remainingMs / 60000);
            const remainingSec = Math.floor((remainingMs % 60000) / 1000);
            document.getElementById('progressETA').textContent = `${remainingMin}:${remainingSec.toString().padStart(2, '0')}`;

            // Reload terrain based on distance traveled (every ~10nm for smoother updates)
            if (state.simulation.distanceTraveled > 10) {
                state.simulation.distanceTraveled = 0;
                loadTerrainData(state.position.lat, state.position.lon);
            }

            // Update position display
            document.getElementById('positionInput').value =
                `${state.position.lat.toFixed(4)}, ${state.position.lon.toFixed(4)}`;
            updateInfoDisplay();

            // Check if complete
            // Check if flight is complete
            if (progress >= 1) {
                // Brief delay to show final rollout before stopping
                setTimeout(() => {
                    stopSimulation();
                }, 2000);
                return; // Don't continue updating after reaching destination
            }
        }

        // Generate deviation waypoints to avoid hazards
        function generateAvoidanceRoute(from, to, bearing, distance) {
            const waypoints = [{ lat: from.lat, lon: from.lon }];

            // Simulate hazard positions along route (weather cells, TFRs)
            // In real implementation, these would come from weather API
            const hazards = [];

            // Generate some simulated weather cells along the route
            const numHazards = Math.floor(distance / 200); // One potential hazard every 200nm
            for (let i = 0; i < numHazards; i++) {
                const hazardProgress = 0.2 + (i / numHazards) * 0.6; // Between 20% and 80% of route
                const hazardPos = interpolateGreatCircle(from.lat, from.lon, to.lat, to.lon, hazardProgress);

                // Random offset from direct route (simulating off-route weather)
                const offsetNM = (Math.random() - 0.5) * 40; // ±20nm from route
                const perpBearing = (bearing + 90) % 360;
                const offsetLat = hazardPos.lat + (offsetNM / 60) * Math.cos(perpBearing * Math.PI / 180);
                const offsetLon = hazardPos.lon + (offsetNM / 60) * Math.sin(perpBearing * Math.PI / 180) / Math.cos(hazardPos.lat * Math.PI / 180);

                // Only add hazards that are close to the route (within 30nm)
                if (Math.abs(offsetNM) < 30) {
                    hazards.push({
                        lat: offsetLat,
                        lon: offsetLon,
                        radius: 15 + Math.random() * 20, // 15-35nm radius
                        progress: hazardProgress,
                        type: Math.random() > 0.3 ? 'weather' : 'tfr'
                    });
                }
            }

            // Generate waypoints that deviate around hazards
            const numWaypoints = Math.max(5, Math.floor(distance / 100)); // Waypoint every ~100nm
            for (let i = 1; i < numWaypoints; i++) {
                const wpProgress = i / numWaypoints;
                let wpPos = interpolateGreatCircle(from.lat, from.lon, to.lat, to.lon, wpProgress);

                // Check for nearby hazards and deviate
                for (const hazard of hazards) {
                    const distToHazard = calculateDistance(wpPos.lat, wpPos.lon, hazard.lat, hazard.lon);
                    if (distToHazard < hazard.radius + 10) { // 10nm buffer
                        // Calculate deviation direction (perpendicular to route)
                        const deviationDir = Math.random() > 0.5 ? 1 : -1;
                        const deviationNM = (hazard.radius + 15) * deviationDir; // Clear by 15nm
                        const perpBearing = (bearing + 90) % 360;

                        wpPos = {
                            lat: wpPos.lat + (deviationNM / 60) * Math.cos(perpBearing * Math.PI / 180),
                            lon: wpPos.lon + (deviationNM / 60) * Math.sin(perpBearing * Math.PI / 180) / Math.cos(wpPos.lat * Math.PI / 180)
                        };
                    }
                }

                waypoints.push(wpPos);
            }

            waypoints.push({ lat: to.lat, lon: to.lon });

            return { waypoints, hazards };
        }

        // Great circle interpolation
        function interpolateGreatCircle(lat1, lon1, lat2, lon2, fraction) {
            const toRad = deg => deg * Math.PI / 180;
            const toDeg = rad => rad * 180 / Math.PI;

            const φ1 = toRad(lat1);
            const λ1 = toRad(lon1);
            const φ2 = toRad(lat2);
            const λ2 = toRad(lon2);

            const d = 2 * Math.asin(Math.sqrt(
                Math.sin((φ2 - φ1) / 2) ** 2 +
                Math.cos(φ1) * Math.cos(φ2) * Math.sin((λ2 - λ1) / 2) ** 2
            ));

            if (d === 0) return { lat: lat1, lon: lon1 };

            const A = Math.sin((1 - fraction) * d) / Math.sin(d);
            const B = Math.sin(fraction * d) / Math.sin(d);

            const x = A * Math.cos(φ1) * Math.cos(λ1) + B * Math.cos(φ2) * Math.cos(λ2);
            const y = A * Math.cos(φ1) * Math.sin(λ1) + B * Math.cos(φ2) * Math.sin(λ2);
            const z = A * Math.sin(φ1) + B * Math.sin(φ2);

            const φ = Math.atan2(z, Math.sqrt(x * x + y * y));
            const λ = Math.atan2(y, x);

            return { lat: toDeg(φ), lon: toDeg(λ) };
        }

        // Calculate distance in nautical miles
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const toRad = deg => deg * Math.PI / 180;
            const R = 3440.065; // Earth radius in NM

            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);

            const a = Math.sin(dLat / 2) ** 2 +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;

            return 2 * R * Math.asin(Math.sqrt(a));
        }

        // Calculate bearing
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const toRad = deg => deg * Math.PI / 180;
            const toDeg = rad => rad * 180 / Math.PI;

            const φ1 = toRad(lat1);
            const φ2 = toRad(lat2);
            const Δλ = toRad(lon2 - lon1);

            const y = Math.sin(Δλ) * Math.cos(φ2);
            const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

            return (toDeg(Math.atan2(y, x)) + 360) % 360;
        }

        // Select best runway for departure based on route bearing
        function selectBestRunway(airport, desiredHeading) {
            if (!airport.runways || airport.runways.length === 0) {
                return null;
            }

            let bestRunway = null;
            let smallestDiff = 360;

            for (const runway of airport.runways) {
                // Calculate angular difference (handling wraparound)
                let diff = Math.abs(runway.hdg - desiredHeading);
                if (diff > 180) diff = 360 - diff;

                if (diff < smallestDiff) {
                    smallestDiff = diff;
                    bestRunway = runway;
                }
            }

            return bestRunway;
        }

        // ============================================
        // RENDER LOOP
        // ============================================

        // Performance optimization: frame throttling
        let targetFPS = 30; // Cap at 30fps for smoother performance
        let frameInterval = 1000 / targetFPS;
        let lastRenderTime = 0;
        let slowUpdateCounter = 0;

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const elapsed = now - lastRenderTime;

            // Throttle to target FPS
            if (elapsed < frameInterval) return;
            lastRenderTime = now - (elapsed % frameInterval);

            const deltaTime = lastFrameTime ? (now - lastFrameTime) / 1000 : 0;
            lastFrameTime = now;

            slowUpdateCounter++;

            // Update simulation if active
            updateSimulation();

            // Move terrain to create forward motion effect
            updateForwardMotion(deltaTime);

            // Smooth terrain transition (crossfade over ~0.5 seconds)
            if (terrainTransitionProgress < 1) {
                terrainTransitionProgress = Math.min(1, terrainTransitionProgress + deltaTime * 2);

                // Fade in new terrain
                if (terrainPoints && terrainPoints.material) {
                    terrainPoints.material.opacity = terrainTransitionProgress * 0.95;
                }

                // Fade out old terrain
                if (oldTerrainPoints && oldTerrainPoints.material) {
                    oldTerrainPoints.material.opacity = (1 - terrainTransitionProgress) * 0.95;

                    // Remove old terrain when transition complete
                    if (terrainTransitionProgress >= 1) {
                        scene.remove(oldTerrainPoints);
                        oldTerrainPoints.geometry.dispose();
                        oldTerrainPoints.material.dispose();
                        oldTerrainPoints = null;
                    }
                }
            }

            // Dynamic point size based on altitude - update every frame for smooth scaling
            if (terrainPoints && terrainPoints.material) {
                // Calculate AGL (above ground level)
                let groundElev = 0;
                if (state.terrainData && state.terrainData.elevations && state.terrainData.elevations.length > 0) {
                    const centerIdx = Math.floor(state.terrainData.elevations.length / 2);
                    groundElev = state.terrainData.elevations[centerIdx] / 0.3048; // Convert to feet
                }
                const altAGL = Math.max(0, state.altitude - groundElev);

                // Point size: smaller at low altitude (10-30), larger at high altitude (up to 80)
                // This prevents points from looking too big during takeoff
                const targetSize = Math.min(80, Math.max(15, 15 + altAGL / 200));
                terrainPoints.material.size = terrainPoints.material.size * 0.9 + targetSize * 0.1; // Smooth transition
            }

            // Update terrain colors every 10 frames (reduces CPU load)
            // Disabled in performance mode
            if (!PERFORMANCE_MODE && slowUpdateCounter % 10 === 0) {
                updateTerrainColors();
            }

            // Overlays now move with forward motion - no need to recreate periodically
            // They are only recreated when terrain reloads (world offset reset)

            // Update flight path line always, runway only during simulation
            updateFlightPathLine();
            if (state.simulation.active) {
                updateRunwayVisualization();
            }

            updateCamera();

            // Update HUD every frame, but info display less frequently
            updateHUD();
            if (slowUpdateCounter % 5 === 0) {
                updateInfoDisplay();
            }

            // Update live ADS-B traffic every 15 frames (~0.5 sec at 30fps)
            // Disabled in performance mode
            if (!PERFORMANCE_MODE && state.overlays.traffic && slowUpdateCounter % 15 === 0) {
                updateLiveTraffic();
            }

            renderer.render(scene, camera);
        }

        function updateForwardMotion(deltaTime) {
            if (!terrainPoints || deltaTime === 0) return;

            // Calculate movement based on simulation speed
            // Simulation runs at ~1.5nm per second (30x time compression)
            // Scale for 3D scene: 1nm = ~200 scene units for good visual motion
            let speedSceneUnits;

            if (state.simulation.active) {
                // Match the simulation speed: distance / duration gives nm per second
                const route = state.simulation.route;
                if (route && route.distance && state.simulation.duration > 0) {
                    // nm per second of simulation
                    const nmPerSec = route.distance / (state.simulation.duration / 1000);
                    // Convert to scene units - scale for smooth visual motion
                    speedSceneUnits = nmPerSec * 200;
                } else {
                    speedSceneUnits = Math.max(state.groundSpeed, 60) * 0.5; // Fallback with minimum
                }
            } else {
                // Normal mode: gentle visual motion based on ground speed (with minimum for visual demo)
                speedSceneUnits = Math.max(state.groundSpeed, 60) * 0.3;
            }

            // Ensure minimum visual movement
            speedSceneUnits = Math.max(speedSceneUnits, 18); // Minimum 18 scene units/sec

            // Calculate movement in world space based on heading
            const headingRad = THREE.MathUtils.degToRad(state.heading);
            const moveX = Math.sin(headingRad) * speedSceneUnits * deltaTime;
            const moveZ = -Math.cos(headingRad) * speedSceneUnits * deltaTime;

            // Accumulate world offset
            worldOffset.x += moveX;
            worldOffset.z += moveZ;

            // Move terrain points backwards (creating illusion of forward flight)
            const positions = terrainPoints.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] -= moveX;     // X
                positions[i + 2] -= moveZ; // Z
            }
            terrainPoints.geometry.attributes.position.needsUpdate = true;

            // Also move old terrain during transition to prevent visual jumping
            if (oldTerrainPoints && oldTerrainPoints.geometry) {
                const oldPositions = oldTerrainPoints.geometry.attributes.position.array;
                for (let i = 0; i < oldPositions.length; i += 3) {
                    oldPositions[i] -= moveX;
                    oldPositions[i + 2] -= moveZ;
                }
                oldTerrainPoints.geometry.attributes.position.needsUpdate = true;
            }

            // Move traffic, hazards, obstacles too
            trafficGroup.children.forEach(obj => {
                obj.position.x -= moveX;
                obj.position.z -= moveZ;
            });
            hazardsGroup.children.forEach(obj => {
                obj.position.x -= moveX;
                obj.position.z -= moveZ;
            });
            obstaclesGroup.children.forEach(obj => {
                obj.position.x -= moveX;
                obj.position.z -= moveZ;
            });

            // Move ground plane
            if (groundPlane) {
                groundPlane.position.x -= moveX;
                groundPlane.position.z -= moveZ;
            }

            // Move buildings
            buildingsGroup.children.forEach(obj => {
                obj.position.x -= moveX;
                obj.position.z -= moveZ;
            });

            // Move clouds
            cloudsGroup.children.forEach(obj => {
                obj.position.x -= moveX;
                obj.position.z -= moveZ;
            });

            // Move icing zones
            icingGroup.children.forEach(obj => {
                obj.position.x -= moveX;
                obj.position.z -= moveZ;
            });

            // Reset world offset and reload terrain when we've moved too far
            const totalOffset = Math.sqrt(worldOffset.x ** 2 + worldOffset.z ** 2);
            if (totalOffset > 15000) { // Reset after ~15km of visual travel (less frequent reloads)
                worldOffset.x = 0;
                worldOffset.z = 0;
                loadTerrainData(state.position.lat, state.position.lon);
                // Recreate overlays at new position
                createSimulatedTraffic();
                createSimulatedHazards();
                createSimulatedObstacles();
                // Update buildings if enabled
                if (state.overlays.buildings) {
                    updateBuildingsOverlay();
                }
                // Update clouds if enabled
                if (state.overlays.clouds) {
                    updateCloudsOverlay();
                }
                // Update icing if enabled
                if (state.overlays.icing) {
                    updateIcingOverlay();
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // THEME
        // ============================================

        function toggleTheme() {
            const isLight = document.documentElement.classList.toggle('light-mode');
            localStorage.setItem('theme', isLight ? 'light' : 'dark');

            // Update scene colors
            if (renderer) {
                renderer.setClearColor(isLight ? 0xf5f5f5 : 0x0a0a0a);
            }

            if (skyMesh) {
                skyMesh.material.uniforms.topColor.value = new THREE.Color(isLight ? 0xbfdbfe : 0x1a365d);
                skyMesh.material.uniforms.bottomColor.value = new THREE.Color(isLight ? 0xfcd34d : 0x78350f);
            }
        }

        // Always start in light mode (default)
        document.documentElement.classList.add('light-mode');

        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
