<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Weather Map - Aviation Weather API</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: rgba(255, 255, 255, 0.03);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-tertiary: rgba(255, 255, 255, 0.4);
            --border-color: rgba(255, 255, 255, 0.08);
            --accent: #6366f1;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
        }

        /* Top Navigation Bar */
        .top-navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            z-index: 9999;
        }

        .nav-brand {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
        }

        .nav-brand svg {
            width: 24px;
            height: 24px;
            color: var(--accent);
        }

        .nav-links {
            display: flex;
            gap: 4px;
        }

        .nav-link {
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            text-decoration: none;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .nav-link.active {
            background: rgba(99, 102, 241, 0.15);
            color: var(--accent);
        }

        .nav-link svg {
            width: 16px;
            height: 16px;
        }

        /* Overlay Toolbar */
        .overlay-toolbar {
            position: fixed;
            top: 48px;
            left: 0;
            right: 0;
            height: 52px;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 0 24px;
            z-index: 9998;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: var(--border-color);
            margin: 0 12px;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding-top: 100px; /* navbar + toolbar */
        }

        /* Map Container */
        .map-container {
            flex: 0 0 auto;
            height: calc(100vh - 100px - 400px); /* viewport - navbar/toolbar - profile */
            min-height: 300px;
            position: relative;
        }

        /* Resize Divider */
        .resize-divider {
            height: 8px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .resize-divider:hover {
            background: rgba(99, 102, 241, 0.2);
        }

        .resize-divider.dragging {
            background: rgba(99, 102, 241, 0.3);
        }

        .resize-handle {
            width: 40px;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
        }

        .resize-divider:hover .resize-handle {
            background: var(--accent);
        }

        #map {
            width: 100%;
            height: 100%;
            background: var(--bg-secondary);
        }

        /* Map Controls Overlay */
        .map-controls {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-panel {
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px;
            min-width: 200px;
        }

        .control-panel h3 {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: 10px;
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .layer-toggle:hover {
            opacity: 0.8;
        }

        .layer-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
        }

        .layer-toggle label {
            font-size: 13px;
            color: var(--text-secondary);
            cursor: pointer;
            flex: 1;
        }

        .layer-toggle .layer-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(34, 197, 94, 0.2);
            color: var(--success);
        }

        .layer-toggle .layer-status.loading {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }

        /* Station Info Panel */
        .station-info {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 1000;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            min-width: 280px;
            max-width: 320px;
            display: none;
        }

        .station-info.visible {
            display: block;
        }

        .station-info .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            padding: 4px;
        }

        .station-info h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .station-info .flight-rules {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .station-info .flight-rules.vfr { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .station-info .flight-rules.mvfr { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
        .station-info .flight-rules.ifr { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
        .station-info .flight-rules.lifr { background: rgba(168, 85, 247, 0.2); color: #a855f7; }

        .station-info .metar-raw {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 12px;
            word-break: break-all;
            color: var(--text-secondary);
        }

        .station-info .weather-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .station-info .weather-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 8px;
            border-radius: 6px;
        }

        .station-info .weather-item .label {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
        }

        .station-info .weather-item .value {
            font-size: 14px;
            font-weight: 600;
            margin-top: 2px;
        }

        /* Hide Leaflet attribution and radar timestamp */
        .leaflet-control-attribution,
        .radar-timestamp {
            display: none !important;
        }

        /* Trip Summary Panel - Floating within map */
        .trip-summary {
            position: absolute;
            bottom: 12px;
            right: 12px;
            z-index: 1000;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(16px);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            width: 320px;
            display: none;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .trip-summary.expanded {
            max-height: calc(100% - 24px);
        }

        .trip-summary.visible {
            display: flex;
        }

        .trip-summary-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            gap: 8px;
            flex-shrink: 0;
            cursor: pointer;
        }

        .trip-summary.expanded .trip-summary-header {
            border-bottom: 1px solid var(--border-color);
        }

        .trip-summary-header:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .trip-summary-title {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            font-size: 12px;
            color: var(--accent-color);
        }

        .trip-close-btn {
            background: none;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
        }

        .trip-close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .trip-summary-mini {
            display: flex;
            gap: 12px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .trip-summary-mini span {
            background: rgba(99, 102, 241, 0.15);
            padding: 2px 8px;
            border-radius: 4px;
        }

        .expand-icon {
            transition: transform 0.2s;
            color: var(--text-tertiary);
        }

        .expand-icon {
            transition: transform 0.2s ease;
            color: var(--text-tertiary);
        }

        .trip-summary.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .trip-summary-content {
            display: none;
            flex-direction: column;
            overflow-y: auto;
            max-height: 350px;
        }

        .trip-summary.expanded .trip-summary-content {
            display: flex;
        }

        /* Scrollbar styling for trip summary */
        .trip-summary-content::-webkit-scrollbar {
            width: 6px;
        }

        .trip-summary-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .trip-summary-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .trip-summary-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .trip-overview {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            background: rgba(99, 102, 241, 0.05);
        }

        .trip-route-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .trip-airport {
            font-size: 20px;
            font-weight: 700;
            color: var(--accent-color);
            letter-spacing: 1px;
        }

        .trip-route-display svg {
            color: var(--text-tertiary);
        }

        .trip-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .trip-stat {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .trip-stat-label {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .trip-stat-value {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .trip-section {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .trip-section:last-child {
            border-bottom: none;
        }

        .trip-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .trip-section-header.warnings {
            color: #f59e0b;
        }

        .trip-phases {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .trip-phase {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            font-size: 12px;
        }

        .trip-phase-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .trip-phase-icon.climb { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .trip-phase-icon.cruise { background: rgba(99, 102, 241, 0.2); color: #6366f1; }
        .trip-phase-icon.descent { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }

        .trip-phase-info {
            flex: 1;
        }

        .trip-phase-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .trip-phase-details {
            font-size: 10px;
            color: var(--text-tertiary);
            margin-top: 2px;
        }

        .trip-phase-distance {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .trip-hazards {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .trip-hazard {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
        }

        .trip-hazard.critical { background: rgba(239, 68, 68, 0.15); border-left: 3px solid #ef4444; }
        .trip-hazard.warning { background: rgba(245, 158, 11, 0.15); border-left: 3px solid #f59e0b; }
        .trip-hazard.caution { background: rgba(234, 179, 8, 0.1); border-left: 3px solid #eab308; }
        .trip-hazard.info { background: rgba(59, 130, 246, 0.1); border-left: 3px solid #3b82f6; }

        .trip-hazard-icon {
            font-size: 14px;
            flex-shrink: 0;
        }

        .trip-hazard-content {
            flex: 1;
        }

        .trip-hazard-title {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .trip-hazard.critical .trip-hazard-title { color: #ef4444; }
        .trip-hazard.warning .trip-hazard-title { color: #f59e0b; }
        .trip-hazard.caution .trip-hazard-title { color: #eab308; }
        .trip-hazard.info .trip-hazard-title { color: #3b82f6; }

        .trip-hazard-desc {
            font-size: 11px;
            color: var(--text-tertiary);
        }

        .trip-hazard-action {
            font-size: 10px;
            color: #22c55e;
            margin-top: 4px;
            font-weight: 500;
        }

        .no-hazards {
            text-align: center;
            padding: 16px;
            color: var(--text-tertiary);
            font-size: 12px;
            background: rgba(34, 197, 94, 0.1);
            border-radius: 6px;
            border: 1px dashed rgba(34, 197, 94, 0.3);
        }

        .trip-waypoints {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .trip-waypoint {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            font-size: 11px;
        }

        .trip-waypoint-marker {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-color);
            flex-shrink: 0;
        }

        .trip-waypoint-marker.departure { background: #22c55e; }
        .trip-waypoint-marker.destination { background: #ef4444; }
        .trip-waypoint-marker.divert { background: #ef4444; border: 2px solid #fca5a5; }
        .trip-waypoint-marker.enroute { background: #f97316; }
        .trip-waypoint-marker.enroute-airport { background: #22c55e; border: 2px solid #f97316; }

        .trip-waypoint-info {
            flex: 1;
        }

        .trip-waypoint-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .trip-waypoint-coords {
            font-size: 10px;
            color: var(--text-tertiary);
        }

        .trip-waypoint-distance {
            text-align: right;
            color: var(--text-secondary);
        }

        .trip-fuel-plan {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .fuel-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 12px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }

        .fuel-item:last-child {
            border-bottom: none;
            font-weight: 600;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }

        .fuel-item-label {
            color: var(--text-secondary);
        }

        .fuel-item-value {
            color: var(--text-primary);
        }

        .fuel-item-value.warning {
            color: #f59e0b;
        }

        .fuel-item-value.ok {
            color: #22c55e;
        }

        /* Profile View */
        .profile-container {
            height: 400px;
            min-height: 200px;
            max-height: 80vh;
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow: hidden;
        }

        .profile-header {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        .profile-header h3 {
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            position: absolute;
            left: 16px;
        }

        .profile-header .route-input {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .profile-header input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 11px;
            color: var(--text-primary);
            width: 70px;
            text-transform: uppercase;
        }

        .profile-header input::placeholder {
            color: var(--text-tertiary);
        }

        .profile-header button {
            background: var(--accent);
            border: none;
            border-radius: 4px;
            padding: 5px 12px;
            font-size: 11px;
            font-weight: 500;
            color: white;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .profile-header button:hover {
            opacity: 0.9;
        }

        .profile-header .waypoint-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .profile-header .waypoint-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
            opacity: 1;
        }

        .profile-header .waypoint-btn.active {
            background: rgba(249, 115, 22, 0.2);
            border-color: rgba(249, 115, 22, 0.5);
            color: #f97316;
        }

        .profile-header .snap-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 10px;
            padding: 5px 8px;
        }

        .profile-header .snap-btn.active {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.5);
            color: #22c55e;
        }

        /* Custom waypoint markers */
        .custom-waypoint-marker {
            width: 24px;
            height: 24px;
            background: #f97316;
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: transform 0.15s ease;
        }

        .custom-waypoint-marker:hover {
            transform: scale(1.15);
        }

        .custom-waypoint-marker.snapped {
            background: #22c55e;
        }

        .waypoint-preview-line {
            stroke-dasharray: 8, 8;
        }

        /* Waypoint mode cursor */
        .leaflet-container.waypoint-mode {
            cursor: crosshair !important;
        }

        .profile-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 12px 12px;
            position: relative;
            min-height: 0;
        }

        .profile-canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #profileCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .profile-zoom-controls {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
            z-index: 50;
        }

        .profile-zoom-btn {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-color);
            background: rgba(10, 10, 15, 0.9);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.15s ease;
        }

        .profile-zoom-btn:hover {
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--primary);
            color: var(--text-primary);
        }

        .profile-zoom-info {
            padding: 4px 8px;
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 10px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
        }

        /* Profile Hover Tooltip */
        .profile-tooltip {
            position: absolute;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 11px;
            color: var(--text-primary);
            pointer-events: none;
            z-index: 100;
            min-width: 200px;
            max-width: 280px;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .profile-tooltip.visible {
            display: block;
        }

        .profile-tooltip-header {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            gap: 24px;
        }

        .profile-tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            gap: 16px;
            color: var(--text-secondary);
        }

        .profile-tooltip-row .label {
            color: var(--text-tertiary);
            flex-shrink: 0;
        }

        .profile-tooltip-row .value {
            font-weight: 500;
            text-align: right;
            flex-shrink: 0;
        }

        .profile-tooltip-row.terrain .value { color: #d4a574; }
        .profile-tooltip-row.ceiling .value { color: #3b82f6; }
        .profile-tooltip-row.visibility .value { color: #a855f7; }
        .profile-tooltip-row.airspace .value { color: #ec4899; }
        .profile-tooltip-row.icing .value { color: #06b6d4; }
        .profile-tooltip-row.turbulence .value { color: #f97316; }
        .profile-tooltip-row.winds .value { color: #22c55e; }
        .profile-tooltip-row.clouds .value { color: #94a3b8; }

        .profile-crosshair {
            position: absolute;
            width: 1px;
            background: rgba(255, 255, 255, 0.3);
            pointer-events: none;
            display: none;
        }

        .profile-crosshair.visible {
            display: block;
        }

        .journey-marker {
            position: absolute;
            pointer-events: none;
            display: none;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .journey-marker.visible {
            display: block;
        }

        .journey-marker-dot {
            width: 12px;
            height: 12px;
            background: #6366f1;
            border: 2px solid #ffffff;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.5);
            position: relative;
            z-index: 2;
        }

        .journey-marker.climb .journey-marker-dot {
            background: #22c55e;
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.5);
        }

        .journey-marker.descent .journey-marker-dot {
            background: #f59e0b;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.5);
        }

        .journey-marker-pulse {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: rgba(99, 102, 241, 0.3);
            border-radius: 50%;
            animation: pulse 1.5s ease-out infinite;
            z-index: 1;
        }

        .journey-marker.climb .journey-marker-pulse {
            background: rgba(34, 197, 94, 0.3);
        }

        .journey-marker.descent .journey-marker-pulse {
            background: rgba(245, 158, 11, 0.3);
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0.8;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }

        /* Map Journey Marker */
        .map-journey-marker {
            background: none !important;
            border: none !important;
        }

        .map-journey-dot {
            position: relative;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .map-journey-dot-inner {
            width: 14px;
            height: 14px;
            background: #ffffff;
            border: 3px solid #6366f1;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            z-index: 2;
        }

        .map-journey-dot-pulse {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: rgba(99, 102, 241, 0.4);
            border-radius: 50%;
            animation: mapPulse 1.5s ease-out infinite;
            z-index: 1;
        }

        @keyframes mapPulse {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0.6;
            }
            100% {
                transform: translate(-50%, -50%) scale(2.5);
                opacity: 0;
            }
        }

        .map-journey-tooltip-container {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
        }

        .map-journey-tooltip-container::before {
            display: none !important;
        }

        .map-journey-tooltip {
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 100px;
        }

        .mjt-header {
            font-size: 11px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mjt-stats {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .mjt-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .mjt-label {
            font-size: 9px;
            color: var(--text-tertiary);
            text-transform: uppercase;
        }

        .mjt-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .profile-placeholder {
            text-align: center;
            color: var(--text-tertiary);
        }

        .profile-placeholder svg {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
            opacity: 0.3;
        }

        .profile-placeholder p {
            font-size: 13px;
        }

        /* Overlay Buttons */
        .overlay-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .overlay-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .overlay-btn.active {
            background: rgba(99, 102, 241, 0.2);
            border-color: rgba(99, 102, 241, 0.4);
            color: var(--accent);
        }

        .overlay-btn svg {
            width: 14px;
            height: 14px;
        }

        .overlay-btn.terrain.active {
            background: rgba(139, 92, 42, 0.3);
            border-color: rgba(139, 92, 42, 0.5);
            color: #d4a574;
        }

        .overlay-btn.clouds.active {
            background: rgba(148, 163, 184, 0.2);
            border-color: rgba(148, 163, 184, 0.4);
            color: #94a3b8;
        }

        .overlay-btn.ceiling.active {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.4);
            color: #3b82f6;
        }

        .overlay-btn.icing.active {
            background: rgba(6, 182, 212, 0.2);
            border-color: rgba(6, 182, 212, 0.4);
            color: #06b6d4;
        }

        .overlay-btn.turbulence.active {
            background: rgba(249, 115, 22, 0.2);
            border-color: rgba(249, 115, 22, 0.4);
            color: #f97316;
        }

        .overlay-btn.winds.active {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.4);
            color: #22c55e;
        }

        .overlay-btn.temperature.active {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
            color: #ef4444;
        }

        .overlay-btn.dewpoint.active {
            background: rgba(14, 165, 233, 0.2);
            border-color: rgba(14, 165, 233, 0.4);
            color: #0ea5e9;
        }

        .overlay-btn.radar.active {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.4);
            color: #22c55e;
        }

        .overlay-btn.stations.active {
            background: rgba(99, 102, 241, 0.2);
            border-color: rgba(99, 102, 241, 0.4);
            color: #6366f1;
        }

        .overlay-btn.visibility.active {
            background: rgba(168, 85, 247, 0.2);
            border-color: rgba(168, 85, 247, 0.4);
            color: #a855f7;
        }

        .overlay-btn.airspace.active {
            background: rgba(236, 72, 153, 0.2);
            border-color: rgba(236, 72, 153, 0.4);
            color: #ec4899;
        }

        /* Legend */
        .map-legend {
            position: absolute;
            bottom: 16px;
            left: 16px;
            z-index: 1000;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px 16px;
        }

        .legend-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: 8px;
        }

        .legend-items {
            display: flex;
            gap: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.vfr { background: #22c55e; }
        .legend-dot.mvfr { background: #3b82f6; }
        .legend-dot.ifr { background: #ef4444; }
        .legend-dot.lifr { background: #a855f7; }

        /* Leaflet Customization */
        .leaflet-control-zoom {
            border: none !important;
            box-shadow: none !important;
        }

        .leaflet-control-zoom a {
            background: rgba(10, 10, 15, 0.9) !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color) !important;
            backdrop-filter: blur(20px);
        }

        .leaflet-control-zoom a:hover {
            background: rgba(20, 20, 30, 0.95) !important;
        }

        .leaflet-popup-content-wrapper {
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
        }

        .leaflet-popup-tip {
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid var(--border-color);
        }

        /* Radar timestamp */
        .radar-timestamp {
            position: absolute;
            bottom: 16px;
            right: 16px;
            z-index: 1000;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .map-controls {
                top: 8px;
                right: 8px;
            }

            .control-panel {
                min-width: 160px;
                padding: 10px;
            }

            .station-info {
                left: 8px;
                right: 8px;
                max-width: none;
            }

            .profile-container {
                height: 200px;
                min-height: 200px;
            }

            .overlay-toolbar {
                flex-wrap: wrap;
                height: auto;
                padding: 8px 12px;
            }

            .toolbar-divider {
                display: none;
            }

            .nav-links {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="top-navbar">
        <div class="nav-brand">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
            </svg>
            Skytron Aero
        </div>
        <div class="nav-links">
            <a href="/" class="nav-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                </svg>
                Weather
            </a>
            <a href="/live-map" class="nav-link active">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                </svg>
                Live Map
            </a>
            <a href="/health-dashboard" class="nav-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 12h-4l-3 9L9 3l-3 9H2"/>
                </svg>
                Health
            </a>
            <a href="/compliance-dashboard" class="nav-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 11l3 3L22 4"/>
                    <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
                </svg>
                Compliance
            </a>
            <a href="/benchmarks-dashboard" class="nav-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 20V10M12 20V4M6 20v-6"/>
                </svg>
                Benchmarks
            </a>
        </div>
    </nav>

    <!-- Overlay Toolbar -->
    <div class="overlay-toolbar">
        <div class="toolbar-section">
            <button class="overlay-btn terrain" data-overlay="terrain" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M8 21l4-10 4 10M12 11l-8 10M12 11l8 10"/>
                </svg>
                Terrain
            </button>
            <button class="overlay-btn clouds" data-overlay="clouds" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 10a4 4 0 0 0-4-4 4 4 0 0 0-4 4H7a3 3 0 0 0 0 6h11a3 3 0 0 0 0-6z"/>
                </svg>
                Clouds
            </button>
            <button class="overlay-btn ceiling" data-overlay="ceiling" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 12h18M3 12v-2a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v2"/>
                </svg>
                Ceiling
            </button>
            <button class="overlay-btn visibility" data-overlay="visibility" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                    <circle cx="12" cy="12" r="3"/>
                </svg>
                Visibility
            </button>
            <button class="overlay-btn airspace" data-overlay="airspace" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                    <path d="M2 17l10 5 10-5"/>
                    <path d="M2 12l10 5 10-5"/>
                </svg>
                Airspace
            </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="toolbar-section">
            <button class="overlay-btn icing" data-overlay="icing" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2v20M8 4l4 4 4-4M8 20l4-4 4 4M2 12h4M18 12h4"/>
                </svg>
                Icing
            </button>
            <button class="overlay-btn turbulence" data-overlay="turbulence" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M2 12c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/>
                    <path d="M2 8c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/>
                    <path d="M2 16c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/>
                </svg>
                Turbulence
            </button>
            <button class="overlay-btn winds" data-overlay="winds" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 8h8.5a2.5 2.5 0 1 0-2.5-2.5M3 12h15.5a2.5 2.5 0 1 1-2.5 2.5M5 16h6.5a2.5 2.5 0 1 0-2.5 2.5"/>
                </svg>
                Winds
            </button>
            <button class="overlay-btn temperature" data-overlay="temperature" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"/>
                </svg>
                Temp
            </button>
            <button class="overlay-btn dewpoint" data-overlay="dewpoint" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/>
                </svg>
                Precip
            </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="toolbar-section">
            <button class="overlay-btn radar" data-overlay="radar" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 2v10l7 7"/>
                </svg>
                Radar
            </button>
            <button class="overlay-btn stations" data-overlay="stations" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="10" r="3"/>
                    <path d="M12 21.7C17.3 17 20 13 20 10a8 8 0 1 0-16 0c0 3 2.7 6.9 8 11.7z"/>
                </svg>
                Stations
            </button>
        </div>
    </div>

    <div class="main-container">
        <!-- Map Section -->
        <div class="map-container">
            <div id="map"></div>


            <!-- Station Info Panel -->
            <div class="station-info" id="stationInfo">
                <button class="close-btn" onclick="closeStationInfo()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                </button>
                <h2 id="stationName">KJFK</h2>
                <span class="flight-rules vfr" id="stationFlightRules">VFR</span>
                <div class="metar-raw" id="stationMetar">Loading...</div>
                <div class="weather-grid">
                    <div class="weather-item">
                        <div class="label">Wind</div>
                        <div class="value" id="stationWind">--</div>
                    </div>
                    <div class="weather-item">
                        <div class="label">Visibility</div>
                        <div class="value" id="stationVis">--</div>
                    </div>
                    <div class="weather-item">
                        <div class="label">Ceiling</div>
                        <div class="value" id="stationCeiling">--</div>
                    </div>
                    <div class="weather-item">
                        <div class="label">Altimeter</div>
                        <div class="value" id="stationAltimeter">--</div>
                    </div>
                </div>
            </div>

            <!-- Trip Summary Panel -->
            <div class="trip-summary" id="tripSummary">
                <div class="trip-summary-header" onclick="toggleTripSummary()">
                    <div class="trip-summary-title">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                        </svg>
                        <span>Trip</span>
                    </div>
                    <div class="trip-summary-mini" id="tripSummaryMini">
                        <span id="tripMiniDistance">-- NM</span>
                        <span id="tripMiniTime">-- hrs</span>
                    </div>
                    <svg class="expand-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"/>
                    </svg>
                    <button class="trip-close-btn" onclick="event.stopPropagation(); hideTripSummary()" title="Close">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 6L6 18M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
                <div class="trip-summary-content" id="tripSummaryContent">
                    <div class="trip-overview">
                        <div class="trip-route-display">
                            <span class="trip-airport" id="tripDepAirport">----</span>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                            <span class="trip-airport" id="tripDestAirport">----</span>
                        </div>
                        <div class="trip-stats-grid">
                            <div class="trip-stat">
                                <div class="trip-stat-label">Distance</div>
                                <div class="trip-stat-value" id="tripDistance">-- NM</div>
                            </div>
                            <div class="trip-stat">
                                <div class="trip-stat-label">Est. Time</div>
                                <div class="trip-stat-value" id="tripTime">--:--</div>
                            </div>
                            <div class="trip-stat">
                                <div class="trip-stat-label">Fuel Req.</div>
                                <div class="trip-stat-value" id="tripFuel">-- gal</div>
                            </div>
                            <div class="trip-stat">
                                <div class="trip-stat-label">Cruise Alt</div>
                                <div class="trip-stat-value" id="tripAltitude">-- ft</div>
                            </div>
                        </div>
                    </div>

                    <div class="trip-section">
                        <div class="trip-section-header">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
                            </svg>
                            Flight Phases
                        </div>
                        <div class="trip-phases" id="tripPhases">
                            <!-- Populated dynamically -->
                        </div>
                    </div>

                    <div class="trip-section">
                        <div class="trip-section-header warnings">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                                <line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>
                            </svg>
                            Hazards & Avoidance
                        </div>
                        <div class="trip-hazards" id="tripHazards">
                            <div class="no-hazards">No significant hazards detected</div>
                        </div>
                    </div>

                    <div class="trip-section">
                        <div class="trip-section-header">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/>
                            </svg>
                            Waypoints
                        </div>
                        <div class="trip-waypoints" id="tripWaypoints">
                            <!-- Populated dynamically -->
                        </div>
                    </div>

                    <div class="trip-section">
                        <div class="trip-section-header">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                            </svg>
                            Fuel Planning
                        </div>
                        <div class="trip-fuel-plan" id="tripFuelPlan">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                </div>
            </div>


            <!-- Radar Timestamp -->
            <div class="radar-timestamp" id="radarTimestamp">
                Radar: Loading...
            </div>
        </div>

        <!-- Resize Divider -->
        <div class="resize-divider" id="resizeDivider">
            <div class="resize-handle"></div>
        </div>

        <!-- Profile View -->
        <div class="profile-container" id="profileSection">
            <div class="profile-header">
                <h3>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
                    </svg>
                    Route Profile
                </h3>
                <div class="route-input">
                    <input type="text" id="departure" placeholder="FROM" maxlength="4">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color: var(--text-tertiary)">
                        <path d="M5 12h14M12 5l7 7-7 7"/>
                    </svg>
                    <input type="text" id="destination" placeholder="TO" maxlength="4">
                    <button onclick="loadRoute()">Load Route</button>
                    <button id="waypointModeBtn" class="waypoint-btn" onclick="toggleWaypointMode()">+ Waypoints</button>
                    <button id="snapModeBtn" class="snap-btn" onclick="toggleSnapMode()" style="display: none;">Snap: OFF</button>
                </div>
            </div>
            <div class="profile-content">
                <div class="profile-canvas-container" id="profileContainer" style="display: none;">
                    <canvas id="profileCanvas"></canvas>
                    <div class="profile-zoom-controls">
                        <button class="profile-zoom-btn" onclick="profileZoom(1.5)" title="Zoom In">+</button>
                        <button class="profile-zoom-btn" onclick="profileZoom(0.67)" title="Zoom Out"></button>
                        <button class="profile-zoom-btn" onclick="profileResetZoom()" title="Reset"></button>
                        <div class="profile-zoom-info"><span id="profileZoomLevel">1.0x</span></div>
                    </div>
                    <div class="profile-crosshair" id="profileCrosshair"></div>
                    <div class="journey-marker" id="journeyMarker">
                        <div class="journey-marker-dot"></div>
                        <div class="journey-marker-pulse"></div>
                    </div>
                    <div class="profile-tooltip" id="profileTooltip">
                        <div class="profile-tooltip-header">
                            <span id="tooltipPosition">--</span>
                            <span id="tooltipDistance">-- NM</span>
                        </div>
                        <div id="tooltipContent"></div>
                    </div>
                </div>
                <div class="profile-placeholder" id="profilePlaceholder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
                    </svg>
                    <p>Enter departure and destination airports to view weather profile</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize map centered on CONUS
        const map = L.map('map', {
            zoomControl: true
        }).setView([39.8283, -98.5795], 5);

        // Base layers
        const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; OpenStreetMap, &copy; CARTO',
            maxZoom: 19
        });

        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri',
            maxZoom: 19
        });

        const vfrLayer = L.tileLayer('https://wms.chartbundle.com/tms/1.0.0/sec/{z}/{x}/{y}.png?type=google', {
            attribution: '&copy; ChartBundle',
            maxZoom: 13,
            tms: true
        });

        // Add default base layer
        darkLayer.addTo(map);

        // Terrain overlay layer - route-aware hazard visualization
        const terrainLayer = L.layerGroup();

        // Generate terrain hazard overlay along the flight route
        function createTerrainOverlay() {
            terrainLayer.clearLayers();

            // Only show terrain if we have a route defined
            if (!currentRoute.dep || !currentRoute.dest) {
                // No route - show message marker at map center
                const center = map.getCenter();
                const noRouteIcon = L.divIcon({
                    className: 'terrain-no-route',
                    html: `<div style="
                        background: rgba(0,0,0,0.8);
                        border: 1px solid #f59e0b;
                        border-radius: 6px;
                        padding: 6px 12px;
                        color: #f59e0b;
                        font-size: 11px;
                        white-space: nowrap;
                    ">Select a route to view terrain hazards</div>`,
                    iconSize: [200, 30],
                    iconAnchor: [100, 15]
                });
                terrainLayer.addLayer(L.marker(center, { icon: noRouteIcon }));
                return;
            }

            const depStation = metarStations.find(s => s.id === currentRoute.dep);
            const destStation = metarStations.find(s => s.id === currentRoute.dest);
            if (!depStation || !destStation) return;

            // Generate terrain samples along the route corridor
            const numSamples = 30;
            const corridorWidthNM = 15; // Width of corridor to check (NM on each side)

            // Seeded random for consistent terrain
            let terrainSeed = (depStation.lat * 1000 + destStation.lon * 100) % 1000;
            function seededRandom() {
                terrainSeed = (terrainSeed * 9301 + 49297) % 233280;
                return terrainSeed / 233280;
            }

            // Get the optimized flight path altitude at each point
            const getFlightAltAtProgress = (t) => {
                // Simplified climb/cruise/descent profile
                if (t < 0.15) return 5000 + (t / 0.15) * 30000; // Climb to 35000
                if (t > 0.85) return 35000 - ((t - 0.85) / 0.15) * 30000; // Descent
                return 35000; // Cruise
            };

            // Sample terrain along route
            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples;
                const lat = depStation.lat + t * (destStation.lat - depStation.lat);
                const lon = depStation.lon + t * (destStation.lon - depStation.lon);

                // Generate terrain elevation (simulated based on position)
                const baseTerrain = Math.sin(lat * 50) * 2000 + Math.sin(lon * 40) * 1500;
                const localVariation = seededRandom() * 1500 + Math.sin(t * 25) * 1000;
                const terrainElevation = Math.max(0, baseTerrain + localVariation + 1000);

                // Get planned flight altitude at this point
                const flightAlt = getFlightAltAtProgress(t);
                const clearance = flightAlt - terrainElevation;
                const minSafeClearance = 2000; // 2000ft minimum safe clearance

                // Only show terrain that's a concern (within 5000ft of flight path or above it)
                if (clearance < 5000) {
                    // Determine hazard level
                    let color, fillOpacity, hazardLevel;
                    if (clearance < 0) {
                        // TERRAIN! Flight path goes through terrain
                        color = '#dc2626';
                        fillOpacity = 0.7;
                        hazardLevel = 'CRITICAL';
                    } else if (clearance < minSafeClearance) {
                        // Below minimum safe clearance
                        color = '#f59e0b';
                        fillOpacity = 0.5;
                        hazardLevel = 'WARNING';
                    } else if (clearance < 4000) {
                        // Caution zone
                        color = '#eab308';
                        fillOpacity = 0.35;
                        hazardLevel = 'CAUTION';
                    } else {
                        // Advisory
                        color = '#22c55e';
                        fillOpacity = 0.2;
                        hazardLevel = 'ADVISORY';
                    }

                    // Create terrain marker polygon
                    const radiusKm = 8 + (5000 - clearance) / 500; // Larger for more dangerous terrain
                    const terrainCoords = createCircularPolygonCoords(lat, lon, radiusKm, map.getZoom());

                    const polygon = L.polygon(terrainCoords, {
                        color: color,
                        fillColor: color,
                        fillOpacity: fillOpacity,
                        weight: clearance < minSafeClearance ? 2 : 1,
                        dashArray: clearance >= minSafeClearance ? '3, 3' : null
                    });

                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:${color}">Terrain ${hazardLevel}</div>
                        <div><b>Elevation:</b> ${Math.round(terrainElevation).toLocaleString()} ft MSL</div>
                        <div><b>Flight Alt:</b> ${Math.round(flightAlt).toLocaleString()} ft</div>
                        <div><b>Clearance:</b> ${Math.round(clearance).toLocaleString()} ft</div>
                        <div style="font-size:10px;opacity:0.7;margin-top:4px">Min safe: ${minSafeClearance.toLocaleString()} ft AGL</div>
                    `, { sticky: true });

                    terrainLayer.addLayer(polygon);

                    // Add elevation label for critical/warning terrain
                    if (clearance < 4000) {
                        const elevIcon = L.divIcon({
                            className: 'terrain-elev-label',
                            html: `<div style="
                                background: rgba(0,0,0,0.8);
                                border: 1px solid ${color};
                                border-radius: 3px;
                                padding: 1px 4px;
                                font-size: 9px;
                                font-weight: 600;
                                color: ${color};
                                white-space: nowrap;
                            ">${Math.round(terrainElevation / 100)}00'</div>`,
                            iconSize: [40, 16],
                            iconAnchor: [20, 8]
                        });
                        terrainLayer.addLayer(L.marker([lat, lon], { icon: elevIcon }));
                    }
                }
            }

            // Add terrain legend
            const legendLat = (depStation.lat + destStation.lat) / 2 + 0.5;
            const legendLon = Math.min(depStation.lon, destStation.lon) - 0.3;
            const legendIcon = L.divIcon({
                className: 'terrain-legend',
                html: `<div style="
                    background: rgba(0,0,0,0.85);
                    border: 1px solid #666;
                    border-radius: 6px;
                    padding: 6px 10px;
                    font-size: 10px;
                    color: #fff;
                ">
                    <div style="font-weight:600;margin-bottom:4px;color:#f59e0b">TERRAIN HAZARDS</div>
                    <div style="display:flex;align-items:center;gap:4px;margin:2px 0"><span style="width:10px;height:10px;background:#dc2626;border-radius:2px"></span> Critical (&lt;0ft)</div>
                    <div style="display:flex;align-items:center;gap:4px;margin:2px 0"><span style="width:10px;height:10px;background:#f59e0b;border-radius:2px"></span> Warning (&lt;2Kft)</div>
                    <div style="display:flex;align-items:center;gap:4px;margin:2px 0"><span style="width:10px;height:10px;background:#eab308;border-radius:2px"></span> Caution (&lt;4Kft)</div>
                    <div style="display:flex;align-items:center;gap:4px;margin:2px 0"><span style="width:10px;height:10px;background:#22c55e;border-radius:2px"></span> Advisory (&lt;5Kft)</div>
                </div>`,
                iconSize: [140, 100],
                iconAnchor: [70, 50]
            });
            terrainLayer.addLayer(L.marker([legendLat, legendLon], { icon: legendIcon }));
        }

        // Clouds/Satellite IR layer (RainViewer satellite)
        let cloudsLayer = null;

        async function loadCloudsLayer() {
            try {
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                const data = await response.json();

                if (data.satellite && data.satellite.infrared && data.satellite.infrared.length > 0) {
                    const latestFrame = data.satellite.infrared[data.satellite.infrared.length - 1];

                    if (cloudsLayer) {
                        map.removeLayer(cloudsLayer);
                    }

                    cloudsLayer = L.tileLayer(`https://tilecache.rainviewer.com${latestFrame.path}/256/{z}/{x}/{y}/0/0_0.png`, {
                        opacity: 0.5,
                        zIndex: 90
                    });

                    if (overlayState.clouds) {
                        cloudsLayer.addTo(map);
                    }
                }
            } catch (error) {
                console.error('Failed to load clouds layer:', error);
            }
        }

        // Icing zones layer (canvas overlay for visualization)
        const icingLayer = L.layerGroup();

        function createIcingOverlay() {
            icingLayer.clearLayers();
            const zoomLevel = map.getZoom();
            // Add icing zone polygons with realistic irregular shapes
            const icingZones = [
                { name: 'Northern Plains', polygon: [[46.5, -98.0], [47.2, -95.5], [46.8, -92.0], [44.5, -90.5], [42.5, -91.0], [41.8, -94.0], [42.2, -97.5], [44.0, -99.0], [46.5, -98.0]], intensity: 'Moderate', base: 8000, top: 22000, type: 'Mixed' },
                { name: 'Northeast', polygon: [[44.5, -76.0], [45.0, -73.5], [43.8, -71.0], [41.5, -72.0], [40.0, -74.5], [40.5, -77.0], [42.0, -78.5], [44.5, -76.0]], intensity: 'Light', base: 10000, top: 18000, type: 'Rime' },
                { name: 'Pacific Northwest', polygon: [[49.0, -122.5], [48.5, -119.0], [46.5, -117.5], [44.5, -118.5], [44.0, -121.0], [45.5, -123.5], [47.5, -124.0], [49.0, -122.5]], intensity: 'Light-Moderate', base: 6000, top: 20000, type: 'Mixed' },
                { name: 'Great Lakes', polygon: [[45.5, -86.0], [46.0, -83.5], [45.0, -81.0], [43.0, -80.5], [41.5, -82.5], [41.0, -85.0], [42.5, -87.5], [44.5, -87.0], [45.5, -86.0]], intensity: 'Moderate', base: 4000, top: 16000, type: 'Rime' },
                { name: 'Rocky Mountains', polygon: [[42.5, -108.5], [43.0, -105.5], [41.5, -103.5], [39.0, -104.0], [37.5, -105.5], [37.0, -108.0], [38.5, -109.5], [41.0, -109.0], [42.5, -108.5]], intensity: 'Light', base: 12000, top: 24000, type: 'Clear' },
            ];

            icingZones.forEach(zone => {
                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const polygon = L.polygon(refinedCoords, {
                    color: '#06b6d4',
                    fillColor: '#06b6d4',
                    fillOpacity: 0.15,
                    weight: 2,
                    dashArray: '5, 5'
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#06b6d4">Icing Advisory</div>
                    <div><b>Area:</b> ${zone.name}</div>
                    <div><b>Intensity:</b> ${zone.intensity}</div>
                    <div><b>Type:</b> ${zone.type}</div>
                    <div><b>Base:</b> ${zone.base.toLocaleString()} ft</div>
                    <div><b>Top:</b> ${zone.top.toLocaleString()} ft</div>
                `, { sticky: true });
                icingLayer.addLayer(polygon);
            });
        }

        // Turbulence zones layer
        const turbulenceLayer = L.layerGroup();

        function createTurbulenceOverlay() {
            turbulenceLayer.clearLayers();
            const zoomLevel = map.getZoom();
            // Add turbulence zone polygons with realistic SIGMET-style shapes
            const turbZones = [
                { name: 'Rocky Mountain Wave', polygon: [[41.0, -107.5], [41.5, -104.5], [40.0, -102.5], [37.5, -103.0], [36.0, -105.0], [36.5, -108.0], [38.5, -108.5], [41.0, -107.5]], intensity: 'Moderate-Severe', type: 'Mountain Wave', base: 15000, top: 45000 },
                { name: 'Sierra Nevada', polygon: [[38.5, -120.5], [39.0, -118.0], [37.5, -116.0], [35.0, -116.5], [34.0, -118.0], [35.0, -120.0], [37.0, -121.0], [38.5, -120.5]], intensity: 'Moderate', type: 'Mountain Wave', base: 18000, top: 40000 },
                { name: 'Appalachian Ridges', polygon: [[38.0, -82.0], [37.5, -79.5], [35.5, -80.0], [33.5, -82.5], [32.5, -85.0], [34.0, -86.5], [36.5, -85.5], [38.0, -82.0]], intensity: 'Light-Moderate', type: 'Mechanical', base: 8000, top: 25000 },
                { name: 'Great Plains Jet', polygon: [[41.0, -101.0], [41.5, -96.0], [39.5, -93.5], [36.5, -94.5], [35.0, -97.5], [36.0, -101.5], [38.5, -102.5], [41.0, -101.0]], intensity: 'Light-Moderate', type: 'Clear Air (CAT)', base: 30000, top: 42000 },
                { name: 'Gulf Coast Convective', polygon: [[32.0, -93.0], [32.5, -89.0], [31.0, -86.5], [29.0, -87.0], [28.0, -90.0], [29.0, -93.5], [31.0, -94.0], [32.0, -93.0]], intensity: 'Moderate', type: 'Convective', base: 10000, top: 35000 },
            ];

            turbZones.forEach(zone => {
                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const polygon = L.polygon(refinedCoords, {
                    color: '#f97316',
                    fillColor: '#f97316',
                    fillOpacity: 0.15,
                    weight: 2,
                    dashArray: '3, 6'
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#f97316">Turbulence SIGMET</div>
                    <div><b>Area:</b> ${zone.name}</div>
                    <div><b>Intensity:</b> ${zone.intensity}</div>
                    <div><b>Type:</b> ${zone.type}</div>
                    <div><b>Base:</b> FL${Math.round(zone.base/100)}</div>
                    <div><b>Top:</b> FL${Math.round(zone.top/100)}</div>
                `, { sticky: true });
                turbulenceLayer.addLayer(polygon);
            });
        }

        // Winds layer (wind barbs at stations)
        const windsLayer = L.layerGroup();

        function createWindsOverlay() {
            windsLayer.clearLayers();
            // Add wind indicators at each METAR station
            metarStations.forEach(station => {
                const data = metarData[station.id];
                if (data && data.wind_speed !== undefined) {
                    const windDir = data.wind_direction || 0;
                    const windSpd = data.wind_speed || 0;
                    const windGust = data.wind_gust || null;

                    // Create wind arrow marker
                    const arrowIcon = L.divIcon({
                        className: 'wind-arrow',
                        html: `<div style="transform: rotate(${windDir}deg); color: #22c55e; font-size: 20px; text-shadow: 0 0 3px rgba(0,0,0,0.5);"></div>
                               <div style="font-size: 10px; color: #22c55e; text-align: center; margin-top: -2px; font-weight: 600;">${windSpd}</div>`,
                        iconSize: [30, 35],
                        iconAnchor: [15, 17]
                    });

                    const marker = L.marker([station.lat, station.lon], { icon: arrowIcon });
                    marker.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:#22c55e">Surface Wind</div>
                        <div><b>Station:</b> ${station.id}</div>
                        <div><b>Direction:</b> ${windDir === 0 ? 'Variable' : windDir + ''}</div>
                        <div><b>Speed:</b> ${windSpd} kt</div>
                        ${windGust ? `<div><b>Gusts:</b> ${windGust} kt</div>` : ''}
                        <div><b>Category:</b> ${windSpd < 10 ? 'Light' : windSpd < 20 ? 'Moderate' : 'Strong'}</div>
                    `, { sticky: true });
                    windsLayer.addLayer(marker);
                }
            });
        }

        // Temperature layer (showing OAT at stations)
        const temperatureLayer = L.layerGroup();

        function createTemperatureOverlay() {
            temperatureLayer.clearLayers();

            // Get temperature color based on value
            const getTempColor = (temp) => {
                if (temp <= -20) return { color: '#581c87', fill: 'rgba(88, 28, 135, 0.35)' };  // Deep purple - extreme cold
                if (temp <= -10) return { color: '#7c3aed', fill: 'rgba(124, 58, 237, 0.3)' };  // Purple - very cold
                if (temp <= 0) return { color: '#3b82f6', fill: 'rgba(59, 130, 246, 0.25)' };   // Blue - cold/freezing
                if (temp <= 10) return { color: '#06b6d4', fill: 'rgba(6, 182, 212, 0.2)' };    // Cyan - cool
                if (temp <= 20) return { color: '#22c55e', fill: 'rgba(34, 197, 94, 0.2)' };    // Green - mild
                if (temp <= 30) return { color: '#f59e0b', fill: 'rgba(245, 158, 11, 0.25)' };  // Amber - warm
                if (temp <= 40) return { color: '#ef4444', fill: 'rgba(239, 68, 68, 0.3)' };    // Red - hot
                return { color: '#991b1b', fill: 'rgba(153, 27, 27, 0.35)' };                    // Dark red - extreme heat
            };

            // Get temperature category
            const getTempCategory = (temp) => {
                if (temp <= -20) return { name: 'Extreme Cold', desc: 'Severe icing risk, cold soaking concerns' };
                if (temp <= -10) return { name: 'Very Cold', desc: 'Significant icing potential' };
                if (temp <= 0) return { name: 'Freezing', desc: 'Icing conditions possible' };
                if (temp <= 10) return { name: 'Cool', desc: 'Comfortable conditions' };
                if (temp <= 20) return { name: 'Mild', desc: 'Optimal flying conditions' };
                if (temp <= 30) return { name: 'Warm', desc: 'Reduced air density' };
                if (temp <= 40) return { name: 'Hot', desc: 'High density altitude concerns' };
                return { name: 'Extreme Heat', desc: 'Significant performance reduction' };
            };

            metarStations.forEach(station => {
                const data = metarData[station.id];
                if (data && data.temperature !== null && data.temperature !== undefined) {
                    const temp = data.temperature;
                    const tempF = Math.round(temp * 9/5 + 32);
                    const colors = getTempColor(temp);
                    const category = getTempCategory(temp);

                    // Create heat map polygon - radius based on how extreme the temperature is
                    const extremity = Math.abs(temp - 15); // 15C is "normal"
                    const radiusKm = 30 + extremity * 1.5; // Larger radius for more extreme temps
                    const hexCoords = createCircularPolygonCoords(station.lat, station.lon, radiusKm, map.getZoom());
                    const refinedCoords = refinePolygon(hexCoords, map.getZoom());

                    const polygon = L.polygon(refinedCoords, {
                        color: colors.color,
                        fillColor: colors.color,
                        fillOpacity: parseFloat(colors.fill.match(/[\d.]+(?=\))/)[0]),
                        weight: 2,
                        opacity: 0.8
                    });

                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:${colors.color}">${station.id} Temperature</div>
                        <div style="font-size:10px;opacity:0.8;margin-bottom:6px">${category.desc}</div>
                        <div><b>OAT:</b> ${temp}C / ${tempF}F</div>
                        <div><b>Category:</b> ${category.name}</div>
                        ${data.dewpoint !== null ? `<div><b>Dewpoint:</b> ${data.dewpoint}C</div>` : ''}
                        ${data.dewpoint !== null ? `<div><b>Spread:</b> ${(temp - data.dewpoint).toFixed(1)}C</div>` : ''}
                        ${data.altimeter ? `<div><b>Altimeter:</b> ${data.altimeter.toFixed(2)}"</div>` : ''}
                    `, { sticky: true });
                    temperatureLayer.addLayer(polygon);

                    // Add temperature label marker at center
                    const tempIcon = L.divIcon({
                        className: 'temp-label',
                        html: `<div style="
                            background: rgba(0,0,0,0.7);
                            border: 1px solid ${colors.color};
                            border-radius: 4px;
                            padding: 1px 4px;
                            font-size: 10px;
                            font-weight: 600;
                            color: ${colors.color};
                            white-space: nowrap;
                        ">${temp}</div>`,
                        iconSize: [30, 18],
                        iconAnchor: [15, 9]
                    });
                    const marker = L.marker([station.lat, station.lon], { icon: tempIcon });
                    temperatureLayer.addLayer(marker);
                }
            });
        }

        // Dew point / Precipitation layer
        const dewpointLayer = L.layerGroup();

        function createDewpointOverlay() {
            dewpointLayer.clearLayers();
            const zoomLevel = map.getZoom();

            metarStations.forEach(station => {
                const data = metarData[station.id];
                if (data) {
                    const dewpoint = data.dewpoint;
                    const temp = data.temperature;
                    const spread = (temp !== null && dewpoint !== null) ? temp - dewpoint : null;

                    // Determine precipitation type and intensity
                    let precipType = null;
                    let precipColor = null;
                    let riskLevel = 0; // 0 = none, 1 = low, 2 = moderate, 3 = high

                    if (data.weather_string) {
                        if (data.weather_string.includes('TS')) {
                            precipType = 'Thunderstorm';
                            precipColor = '#ef4444';
                            riskLevel = 3;
                        } else if (data.weather_string.includes('+RA') || data.weather_string.includes('+SH')) {
                            precipType = 'Heavy Rain';
                            precipColor = '#3b82f6';
                            riskLevel = 3;
                        } else if (data.weather_string.includes('RA') || data.weather_string.includes('SH')) {
                            precipType = 'Rain';
                            precipColor = '#0ea5e9';
                            riskLevel = 2;
                        } else if (data.weather_string.includes('SN') || data.weather_string.includes('SG')) {
                            precipType = 'Snow';
                            precipColor = '#a855f7';
                            riskLevel = 2;
                        } else if (data.weather_string.includes('DZ')) {
                            precipType = 'Drizzle';
                            precipColor = '#06b6d4';
                            riskLevel = 1;
                        } else if (data.weather_string.includes('FG') || data.weather_string.includes('BR')) {
                            precipType = 'Fog/Mist';
                            precipColor = '#94a3b8';
                            riskLevel = 2;
                        }
                    }

                    // Show fog risk based on temp/dewpoint spread (only if no other precip)
                    if (spread !== null && spread <= 3 && !precipType) {
                        precipType = spread <= 1 ? 'Fog Likely' : 'Fog Risk';
                        precipColor = '#94a3b8';
                        riskLevel = spread <= 1 ? 2 : 1;
                    }

                    // Only show stations with actual risks
                    if (!precipType || riskLevel === 0) return;

                    // Create high-resolution polygon outline
                    const radiusKm = 40 + riskLevel * 15; // Larger radius for higher risk
                    const sides = Math.min(48, Math.max(24, Math.floor(24 * Math.pow(1.2, zoomLevel - 4))));
                    const coords = [];
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * 2 * Math.PI;
                        const latOffset = (radiusKm / 111) * Math.cos(angle);
                        const lonOffset = (radiusKm / (111 * Math.cos(station.lat * Math.PI / 180))) * Math.sin(angle);
                        coords.push([station.lat + latOffset, station.lon + lonOffset]);
                    }

                    const polygon = L.polygon(coords, {
                        color: precipColor,
                        fillColor: precipColor,
                        fillOpacity: 0.08 + riskLevel * 0.04,
                        weight: riskLevel >= 2 ? 2.5 : 1.5,
                        opacity: 0.8
                    });

                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:${precipColor}">${precipType}</div>
                        <div><b>Station:</b> ${station.id}</div>
                        ${dewpoint !== null ? `<div><b>Dewpoint:</b> ${dewpoint}C</div>` : ''}
                        ${spread !== null ? `<div><b>Temp/DP Spread:</b> ${spread}C</div>` : ''}
                        ${data.weather_string ? `<div><b>Weather:</b> ${data.weather_string}</div>` : ''}
                        ${spread !== null && spread <= 3 ? `<div style="color:#f59e0b;font-size:10px;margin-top:4px"> Low spread - fog/moisture risk</div>` : ''}
                    `, { sticky: true });
                    dewpointLayer.addLayer(polygon);
                }
            });
        }

        // Helper function to create circular polygon with zoom-responsive vertex count
        function createCircularPolygonCoords(lat, lon, radiusKm, zoomLevel = 5) {
            // Sides scale with zoom: 6 at zoom 4, up to 72 at zoom 14+
            const baseSides = 6;
            const sides = Math.min(72, Math.max(baseSides, Math.floor(baseSides * Math.pow(1.3, zoomLevel - 4))));
            const coords = [];
            const earthRadius = 6371; // km
            const angleStep = 360 / sides;
            for (let i = 0; i < sides; i++) {
                const angle = (i * angleStep) * Math.PI / 180;
                const dLat = (radiusKm / earthRadius) * Math.cos(angle) * (180 / Math.PI);
                const dLon = (radiusKm / earthRadius) * Math.sin(angle) * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
                coords.push([lat + dLat, lon + dLon]);
            }
            coords.push(coords[0]); // Close the polygon
            return coords;
        }

        // Refine existing polygon with interpolated points based on zoom level
        function refinePolygon(coords, zoomLevel = 5) {
            // At low zoom, return original. At high zoom, add intermediate points for smooth curves
            const refinementFactor = Math.max(1, Math.floor(Math.pow(1.4, zoomLevel - 6)));
            if (refinementFactor <= 1) return coords;

            const refined = [];
            for (let i = 0; i < coords.length - 1; i++) {
                const p1 = coords[i];
                const p2 = coords[i + 1];
                refined.push(p1);

                // Add intermediate points using spherical interpolation approximation
                for (let j = 1; j < refinementFactor; j++) {
                    const t = j / refinementFactor;
                    // Catmull-Rom-like smoothing using neighboring points
                    const prevIdx = Math.max(0, i - 1);
                    const nextIdx = Math.min(coords.length - 2, i + 1);
                    const p0 = coords[prevIdx];
                    const p3 = coords[nextIdx === i ? Math.min(coords.length - 2, i + 2) : nextIdx + 1] || p2;

                    // Cubic interpolation for smoother curves
                    const t2 = t * t;
                    const t3 = t2 * t;
                    const lat = 0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t +
                               (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t2 +
                               (-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t3);
                    const lon = 0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t +
                               (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t2 +
                               (-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t3);
                    refined.push([lat, lon]);
                }
            }
            refined.push(coords[coords.length - 1]); // Close polygon
            return refined;
        }

        // Legacy wrapper for backwards compatibility
        function createHexagonCoords(lat, lon, radiusKm, rotation = 0) {
            return createCircularPolygonCoords(lat, lon, radiusKm, map.getZoom());
        }

        // Ceiling visualization layer (color rings around stations)
        const ceilingLayer = L.layerGroup();

        function createCeilingOverlay() {
            ceilingLayer.clearLayers();
            metarStations.forEach(station => {
                const data = metarData[station.id];
                if (data) {
                    const flightRules = data.flight_rules || 'VFR';
                    const color = flightRulesColors[flightRules] || '#22c55e';
                    const ceiling = data.ceiling;

                    // Create ceiling hexagon (50km radius)
                    const hexCoords = createHexagonCoords(station.lat, station.lon, 50);
                    const ring = L.polygon(hexCoords, {
                        color: color,
                        fillColor: color,
                        fillOpacity: 0.1,
                        weight: 2
                    });

                    // Enhanced tooltip with flight rules and ceiling info
                    const ceilingText = ceiling ? `${ceiling.toLocaleString()} ft AGL` : 'Clear / Unlimited';
                    const flightRulesDesc = {
                        'VFR': 'Visual Flight Rules - Ceiling 3000 ft, Visibility 5 SM',
                        'MVFR': 'Marginal VFR - Ceiling 1000-3000 ft or Visibility 3-5 SM',
                        'IFR': 'Instrument Flight Rules - Ceiling 500-1000 ft or Visibility 1-3 SM',
                        'LIFR': 'Low IFR - Ceiling <500 ft or Visibility <1 SM'
                    };

                    ring.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:${color}">${station.id} - ${flightRules}</div>
                        <div style="font-size:10px;opacity:0.8;margin-bottom:6px">${flightRulesDesc[flightRules] || ''}</div>
                        <div><b>Ceiling:</b> ${ceilingText}</div>
                        <div><b>Visibility:</b> ${data.visibility !== null ? data.visibility + ' SM' : 'N/A'}</div>
                        ${data.wind_speed ? `<div><b>Wind:</b> ${data.wind_direction} @ ${data.wind_speed} kt</div>` : ''}
                        ${data.temperature !== null ? `<div><b>Temp/Dewpoint:</b> ${data.temperature}C / ${data.dewpoint}C</div>` : ''}
                    `, { sticky: true, className: 'ceiling-tooltip' });

                    ceilingLayer.addLayer(ring);
                }
            });
        }

        // Visibility layer (gradient circles showing visibility range)
        const visibilityLayer = L.layerGroup();

        function createVisibilityOverlay() {
            visibilityLayer.clearLayers();
            metarStations.forEach(station => {
                const data = metarData[station.id];
                if (data && data.visibility !== null) {
                    const vis = data.visibility;

                    // Color based on visibility
                    let color, fillOpacity;
                    if (vis >= 6) {
                        color = '#22c55e'; // Green - good visibility
                        fillOpacity = 0.1;
                    } else if (vis >= 3) {
                        color = '#3b82f6'; // Blue - moderate
                        fillOpacity = 0.15;
                    } else if (vis >= 1) {
                        color = '#f59e0b'; // Yellow - reduced
                        fillOpacity = 0.2;
                    } else {
                        color = '#ef4444'; // Red - poor
                        fillOpacity = 0.25;
                    }

                    // Create visibility hexagon (radius proportional to visibility)
                    const radiusKm = Math.min(vis * 10, 100); // Cap at 100km
                    const hexCoords = createHexagonCoords(station.lat, station.lon, radiusKm, 30); // 30 rotation for variety
                    const polygon = L.polygon(hexCoords, {
                        color: color,
                        fillColor: color,
                        fillOpacity: fillOpacity,
                        weight: 1,
                        dashArray: '2, 4'
                    });

                    // Determine visibility category
                    let visCategory, visDesc;
                    if (vis >= 6) {
                        visCategory = 'Good';
                        visDesc = 'VFR conditions - unrestricted visibility';
                    } else if (vis >= 3) {
                        visCategory = 'Moderate';
                        visDesc = 'MVFR conditions - marginal visibility';
                    } else if (vis >= 1) {
                        visCategory = 'Reduced';
                        visDesc = 'IFR conditions - reduced visibility';
                    } else {
                        visCategory = 'Poor';
                        visDesc = 'LIFR conditions - very low visibility';
                    }

                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:${color}">${station.id} Visibility</div>
                        <div style="font-size:10px;opacity:0.8;margin-bottom:6px">${visDesc}</div>
                        <div><b>Visibility:</b> ${vis} SM</div>
                        <div><b>Category:</b> ${visCategory}</div>
                        <div><b>Flight Rules:</b> ${data.flight_rules || 'N/A'}</div>
                        ${data.ceiling ? `<div><b>Ceiling:</b> ${data.ceiling.toLocaleString()} ft</div>` : ''}
                        ${data.weather_string ? `<div><b>Weather:</b> ${data.weather_string}</div>` : ''}
                    `, { sticky: true, className: 'visibility-tooltip' });
                    visibilityLayer.addLayer(polygon);
                }
            });
        }

        // Airspace layer
        const airspaceLayer = L.layerGroup();

        // Detailed airspace data with polygon boundaries and multiple tiers
        const airspaceData = {
            // Class B airspaces with realistic multi-tier polygon shapes
            classB: [
                {
                    name: 'New York Class B',
                    center: [40.6413, -73.7781],
                    tiers: [
                        { floor: 0, ceiling: 7000, polygon: [[40.85, -73.45], [40.90, -73.65], [40.88, -73.95], [40.75, -74.10], [40.55, -74.15], [40.40, -74.05], [40.35, -73.85], [40.40, -73.55], [40.55, -73.40], [40.70, -73.35], [40.85, -73.45]] },
                        { floor: 1500, ceiling: 7000, polygon: [[40.95, -73.30], [41.00, -73.60], [40.98, -74.05], [40.85, -74.25], [40.60, -74.35], [40.35, -74.25], [40.20, -74.00], [40.18, -73.60], [40.30, -73.25], [40.55, -73.10], [40.80, -73.15], [40.95, -73.30]] },
                        { floor: 3000, ceiling: 7000, polygon: [[41.05, -73.15], [41.15, -73.55], [41.10, -74.15], [40.90, -74.45], [40.55, -74.55], [40.20, -74.40], [40.00, -74.05], [39.98, -73.50], [40.15, -73.05], [40.50, -72.85], [40.85, -72.95], [41.05, -73.15]] }
                    ]
                },
                {
                    name: 'Los Angeles Class B',
                    center: [33.9425, -118.4081],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[34.10, -118.20], [34.15, -118.45], [34.10, -118.70], [33.90, -118.80], [33.70, -118.75], [33.60, -118.50], [33.65, -118.20], [33.80, -118.05], [34.00, -118.05], [34.10, -118.20]] },
                        { floor: 2500, ceiling: 10000, polygon: [[34.25, -118.00], [34.35, -118.45], [34.25, -118.90], [33.95, -119.05], [33.60, -118.95], [33.45, -118.55], [33.50, -118.10], [33.75, -117.85], [34.10, -117.85], [34.25, -118.00]] },
                        { floor: 5000, ceiling: 10000, polygon: [[34.40, -117.80], [34.55, -118.40], [34.40, -119.05], [34.00, -119.25], [33.50, -119.10], [33.30, -118.55], [33.40, -117.95], [33.75, -117.60], [34.20, -117.60], [34.40, -117.80]] }
                    ]
                },
                {
                    name: 'Chicago Class B',
                    center: [41.9742, -87.9073],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[42.15, -87.70], [42.20, -87.95], [42.15, -88.20], [41.95, -88.30], [41.75, -88.25], [41.65, -88.00], [41.70, -87.70], [41.85, -87.55], [42.05, -87.55], [42.15, -87.70]] },
                        { floor: 1900, ceiling: 10000, polygon: [[42.30, -87.50], [42.40, -87.90], [42.30, -88.35], [42.00, -88.55], [41.65, -88.45], [41.45, -88.05], [41.55, -87.55], [41.85, -87.30], [42.15, -87.30], [42.30, -87.50]] },
                        { floor: 3000, ceiling: 10000, polygon: [[42.45, -87.30], [42.55, -87.85], [42.45, -88.50], [42.05, -88.75], [41.55, -88.65], [41.30, -88.10], [41.40, -87.40], [41.80, -87.10], [42.25, -87.10], [42.45, -87.30]] }
                    ]
                },
                {
                    name: 'Atlanta Class B',
                    center: [33.6407, -84.4277],
                    tiers: [
                        { floor: 0, ceiling: 12500, polygon: [[33.85, -84.25], [33.90, -84.45], [33.85, -84.65], [33.65, -84.75], [33.45, -84.70], [33.35, -84.50], [33.40, -84.25], [33.55, -84.10], [33.75, -84.10], [33.85, -84.25]] },
                        { floor: 3000, ceiling: 12500, polygon: [[34.00, -84.05], [34.10, -84.45], [34.00, -84.85], [33.70, -85.00], [33.35, -84.90], [33.20, -84.50], [33.30, -84.05], [33.55, -83.85], [33.85, -83.85], [34.00, -84.05]] },
                        { floor: 5000, ceiling: 12500, polygon: [[34.15, -83.85], [34.30, -84.40], [34.15, -85.00], [33.75, -85.20], [33.25, -85.05], [33.05, -84.45], [33.20, -83.85], [33.55, -83.55], [33.95, -83.55], [34.15, -83.85]] }
                    ]
                },
                {
                    name: 'Dallas Class B',
                    center: [32.8998, -97.0403],
                    tiers: [
                        { floor: 0, ceiling: 11000, polygon: [[33.10, -96.85], [33.15, -97.05], [33.10, -97.25], [32.90, -97.35], [32.70, -97.30], [32.60, -97.10], [32.65, -96.85], [32.80, -96.70], [33.00, -96.70], [33.10, -96.85]] },
                        { floor: 2500, ceiling: 11000, polygon: [[33.25, -96.65], [33.35, -97.05], [33.25, -97.45], [32.95, -97.60], [32.60, -97.50], [32.45, -97.10], [32.55, -96.65], [32.80, -96.45], [33.10, -96.45], [33.25, -96.65]] },
                        { floor: 4000, ceiling: 11000, polygon: [[33.40, -96.45], [33.55, -97.00], [33.40, -97.60], [33.00, -97.85], [32.50, -97.70], [32.30, -97.10], [32.45, -96.45], [32.80, -96.15], [33.20, -96.15], [33.40, -96.45]] }
                    ]
                },
                {
                    name: 'Denver Class B',
                    center: [39.8561, -104.6737],
                    tiers: [
                        { floor: 0, ceiling: 12000, polygon: [[40.05, -104.45], [40.10, -104.70], [40.05, -104.95], [39.85, -105.05], [39.65, -105.00], [39.55, -104.75], [39.60, -104.45], [39.75, -104.30], [39.95, -104.30], [40.05, -104.45]] },
                        { floor: 3000, ceiling: 12000, polygon: [[40.20, -104.25], [40.30, -104.70], [40.20, -105.15], [39.90, -105.30], [39.55, -105.20], [39.40, -104.75], [39.50, -104.25], [39.75, -104.00], [40.05, -104.00], [40.20, -104.25]] },
                        { floor: 7000, ceiling: 12000, polygon: [[40.35, -104.00], [40.50, -104.65], [40.35, -105.35], [39.95, -105.55], [39.45, -105.40], [39.25, -104.70], [39.40, -104.00], [39.75, -103.70], [40.15, -103.70], [40.35, -104.00]] }
                    ]
                },
                {
                    name: 'San Francisco Class B',
                    center: [37.6213, -122.3790],
                    tiers: [
                        { floor: 0, ceiling: 8000, polygon: [[37.80, -122.20], [37.85, -122.40], [37.80, -122.60], [37.60, -122.70], [37.40, -122.65], [37.30, -122.45], [37.35, -122.20], [37.50, -122.05], [37.70, -122.05], [37.80, -122.20]] },
                        { floor: 1500, ceiling: 8000, polygon: [[37.95, -122.00], [38.05, -122.35], [37.95, -122.75], [37.65, -122.90], [37.30, -122.80], [37.15, -122.45], [37.25, -122.00], [37.50, -121.80], [37.80, -121.80], [37.95, -122.00]] },
                        { floor: 3000, ceiling: 8000, polygon: [[38.10, -121.80], [38.25, -122.30], [38.10, -122.90], [37.70, -123.10], [37.20, -122.95], [37.00, -122.40], [37.15, -121.80], [37.50, -121.55], [37.90, -121.55], [38.10, -121.80]] }
                    ]
                },
                {
                    name: 'Seattle Class B',
                    center: [47.4502, -122.3088],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[47.65, -122.10], [47.70, -122.35], [47.65, -122.55], [47.45, -122.65], [47.25, -122.60], [47.15, -122.40], [47.20, -122.15], [47.35, -122.00], [47.55, -122.00], [47.65, -122.10]] },
                        { floor: 2000, ceiling: 10000, polygon: [[47.80, -121.90], [47.90, -122.30], [47.80, -122.70], [47.50, -122.85], [47.15, -122.75], [47.00, -122.40], [47.10, -121.95], [47.35, -121.75], [47.65, -121.75], [47.80, -121.90]] },
                        { floor: 4000, ceiling: 10000, polygon: [[47.95, -121.70], [48.10, -122.25], [47.95, -122.85], [47.55, -123.05], [47.05, -122.90], [46.85, -122.35], [47.00, -121.75], [47.35, -121.50], [47.75, -121.50], [47.95, -121.70]] }
                    ]
                },
                {
                    name: 'Miami Class B',
                    center: [25.7959, -80.2870],
                    tiers: [
                        { floor: 0, ceiling: 7000, polygon: [[26.00, -80.10], [26.05, -80.30], [26.00, -80.50], [25.80, -80.55], [25.60, -80.50], [25.50, -80.30], [25.55, -80.10], [25.70, -79.95], [25.90, -79.95], [26.00, -80.10]] },
                        { floor: 1500, ceiling: 7000, polygon: [[26.15, -79.90], [26.25, -80.25], [26.15, -80.60], [25.85, -80.75], [25.50, -80.65], [25.35, -80.30], [25.45, -79.90], [25.70, -79.70], [26.00, -79.70], [26.15, -79.90]] },
                        { floor: 3000, ceiling: 7000, polygon: [[26.30, -79.70], [26.45, -80.20], [26.30, -80.75], [25.90, -80.95], [25.40, -80.80], [25.20, -80.25], [25.35, -79.70], [25.70, -79.45], [26.10, -79.45], [26.30, -79.70]] }
                    ]
                },
                {
                    name: 'Boston Class B',
                    center: [42.3656, -71.0096],
                    tiers: [
                        { floor: 0, ceiling: 7000, polygon: [[42.55, -70.85], [42.60, -71.05], [42.55, -71.25], [42.35, -71.35], [42.15, -71.30], [42.05, -71.10], [42.10, -70.85], [42.25, -70.70], [42.45, -70.70], [42.55, -70.85]] },
                        { floor: 1500, ceiling: 7000, polygon: [[42.70, -70.65], [42.80, -71.00], [42.70, -71.40], [42.40, -71.55], [42.05, -71.45], [41.90, -71.05], [42.00, -70.65], [42.25, -70.45], [42.55, -70.45], [42.70, -70.65]] },
                        { floor: 2500, ceiling: 7000, polygon: [[42.85, -70.45], [43.00, -70.95], [42.85, -71.55], [42.45, -71.75], [41.95, -71.60], [41.75, -71.00], [41.90, -70.45], [42.25, -70.20], [42.65, -70.20], [42.85, -70.45]] }
                    ]
                }
            ],
            // Class C with detailed polygons
            classC: [
                {
                    name: 'Phoenix Sky Harbor Class C',
                    center: [33.4373, -112.0078],
                    tiers: [
                        { floor: 0, ceiling: 5900, polygon: [[33.55, -111.90], [33.58, -112.05], [33.55, -112.20], [33.40, -112.25], [33.25, -112.18], [33.22, -112.03], [33.28, -111.88], [33.42, -111.82], [33.55, -111.90]] },
                        { floor: 2100, ceiling: 5900, polygon: [[33.65, -111.78], [33.70, -112.00], [33.65, -112.28], [33.45, -112.38], [33.22, -112.30], [33.12, -112.05], [33.20, -111.78], [33.42, -111.65], [33.65, -111.78]] }
                    ]
                },
                {
                    name: 'Minneapolis Class C',
                    center: [44.8848, -93.2223],
                    tiers: [
                        { floor: 0, ceiling: 8000, polygon: [[45.00, -93.10], [45.05, -93.25], [45.00, -93.40], [44.85, -93.45], [44.70, -93.38], [44.65, -93.22], [44.72, -93.08], [44.88, -93.00], [45.00, -93.10]] },
                        { floor: 2100, ceiling: 8000, polygon: [[45.12, -92.95], [45.18, -93.20], [45.12, -93.50], [44.90, -93.60], [44.60, -93.50], [44.52, -93.22], [44.62, -92.95], [44.88, -92.80], [45.12, -92.95]] }
                    ]
                },
                {
                    name: 'Detroit Metro Class C',
                    center: [42.2162, -83.3554],
                    tiers: [
                        { floor: 0, ceiling: 5000, polygon: [[42.35, -83.22], [42.38, -83.38], [42.32, -83.52], [42.18, -83.55], [42.05, -83.48], [42.02, -83.32], [42.10, -83.18], [42.25, -83.15], [42.35, -83.22]] },
                        { floor: 1800, ceiling: 5000, polygon: [[42.45, -83.10], [42.50, -83.35], [42.42, -83.60], [42.22, -83.68], [42.00, -83.58], [41.92, -83.32], [42.02, -83.08], [42.25, -82.98], [42.45, -83.10]] }
                    ]
                },
                {
                    name: 'Houston Hobby Class C',
                    center: [29.6454, -95.2789],
                    tiers: [
                        { floor: 0, ceiling: 4000, polygon: [[29.75, -95.18], [29.78, -95.30], [29.72, -95.42], [29.60, -95.45], [29.50, -95.38], [29.48, -95.25], [29.55, -95.15], [29.68, -95.12], [29.75, -95.18]] },
                        { floor: 1800, ceiling: 4000, polygon: [[29.82, -95.08], [29.88, -95.28], [29.80, -95.48], [29.62, -95.55], [29.45, -95.45], [29.40, -95.25], [29.50, -95.05], [29.70, -94.98], [29.82, -95.08]] }
                    ]
                },
                {
                    name: 'Las Vegas Class C',
                    center: [36.0840, -115.1537],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[36.20, -115.05], [36.25, -115.18], [36.20, -115.32], [36.05, -115.38], [35.92, -115.30], [35.88, -115.15], [35.95, -115.02], [36.10, -114.98], [36.20, -115.05]] },
                        { floor: 3000, ceiling: 10000, polygon: [[36.30, -114.92], [36.38, -115.15], [36.30, -115.42], [36.08, -115.52], [35.85, -115.40], [35.78, -115.15], [35.88, -114.90], [36.12, -114.82], [36.30, -114.92]] }
                    ]
                }
            ],
            // MOAs (Military Operating Areas)
            moa: [
                { name: 'Tombstone MOA', polygon: [[32.5, -110.5], [32.5, -109.5], [31.5, -109.5], [31.5, -110.5]], floor: 500, ceiling: 17999 },
                { name: 'Gladden MOA', polygon: [[33.0, -112.5], [33.0, -111.5], [32.0, -111.5], [32.0, -112.5]], floor: 500, ceiling: 17999 },
                { name: 'Sells MOA', polygon: [[32.5, -112.5], [32.5, -111.5], [31.5, -111.5], [31.5, -112.5]], floor: 500, ceiling: 17999 },
                { name: 'Brownwood MOA', polygon: [[32.5, -99.5], [32.5, -98.5], [31.5, -98.5], [31.5, -99.5]], floor: 8000, ceiling: 17999 },
                { name: 'Lancer MOA', polygon: [[33.0, -102.0], [33.0, -101.0], [32.0, -101.0], [32.0, -102.0]], floor: 100, ceiling: 17999 },
                { name: 'Warning W-289', polygon: [[36.5, -122.5], [36.5, -121.5], [35.5, -121.5], [35.5, -122.5]], floor: 0, ceiling: 99999 },
            ],
            // Restricted areas with polygon shapes
            restricted: [
                { name: 'R-2508 Complex', polygon: [[36.5, -118.5], [36.5, -116.5], [35.0, -116.5], [35.0, -117.5], [34.5, -117.5], [34.5, -118.5]], floor: 0, ceiling: 99999 },
                { name: 'R-4807 (Nellis Range)', polygon: [[38.0, -116.5], [38.0, -115.0], [36.5, -115.0], [36.5, -116.5]], floor: 0, ceiling: 99999 },
                { name: 'R-4809 (Nellis South)', polygon: [[36.5, -116.0], [36.5, -115.0], [35.5, -115.0], [35.5, -116.0]], floor: 0, ceiling: 50000 },
                { name: 'R-5107 (Ft Irwin)', polygon: [[35.5, -117.0], [35.5, -116.0], [34.8, -116.0], [34.8, -117.0]], floor: 0, ceiling: 30000 },
                { name: 'R-2301 (Eglin)', polygon: [[30.8, -86.8], [30.8, -85.8], [30.2, -85.8], [30.2, -86.8]], floor: 0, ceiling: 50000 },
                { name: 'R-5601 (Cherry Point)', polygon: [[35.0, -77.2], [35.0, -76.5], [34.5, -76.5], [34.5, -77.2]], floor: 0, ceiling: 50000 },
            ],
            // Prohibited areas
            prohibited: [
                { name: 'P-56A (White House)', polygon: [[38.905, -77.045], [38.905, -77.028], [38.890, -77.028], [38.890, -77.045]], floor: 0, ceiling: 18000 },
                { name: 'P-56B (Naval Observatory)', polygon: [[38.930, -77.075], [38.930, -77.058], [38.915, -77.058], [38.915, -77.075]], floor: 0, ceiling: 18000 },
                { name: 'P-40 (Camp David)', polygon: [[39.655, -77.475], [39.655, -77.445], [39.635, -77.445], [39.635, -77.475]], floor: 0, ceiling: 99999 },
                { name: 'P-49 (Mt Vernon)', polygon: [[38.715, -77.095], [38.715, -77.075], [38.700, -77.075], [38.700, -77.095]], floor: 0, ceiling: 1500 },
            ],
            // TFRs (simulated - would need real-time API) with polygon shapes
            tfr: [
                { name: 'TFR - VIP Movement', polygon: [[39.35, -77.0], [39.20, -76.55], [38.90, -76.45], [38.55, -76.60], [38.45, -77.0], [38.55, -77.40], [38.90, -77.55], [39.20, -77.45]], floor: 0, ceiling: 18000, active: true },
            ],
            // Class D airports with irregular polygon shapes (4nm radius approximated)
            classD: [
                { name: 'Teterboro (KTEB)', center: [40.8501, -74.0608], polygon: [[40.92, -74.06], [40.89, -73.98], [40.85, -73.96], [40.80, -73.99], [40.78, -74.06], [40.80, -74.13], [40.85, -74.15], [40.90, -74.12]], floor: 0, ceiling: 2500 },
                { name: 'Van Nuys (KVNY)', center: [34.2098, -118.4895], polygon: [[34.28, -118.49], [34.25, -118.41], [34.21, -118.39], [34.16, -118.42], [34.14, -118.49], [34.16, -118.56], [34.21, -118.58], [34.26, -118.55]], floor: 0, ceiling: 3500 },
                { name: 'Long Beach (KLGB)', center: [33.8177, -118.1516], polygon: [[33.88, -118.15], [33.86, -118.08], [33.82, -118.06], [33.77, -118.09], [33.75, -118.15], [33.77, -118.21], [33.82, -118.23], [33.86, -118.20]], floor: 0, ceiling: 2500 },
                { name: 'Santa Monica (KSMO)', center: [34.0158, -118.4513], polygon: [[34.08, -118.45], [34.06, -118.38], [34.02, -118.36], [33.97, -118.39], [33.95, -118.45], [33.97, -118.51], [34.02, -118.53], [34.06, -118.50]], floor: 0, ceiling: 2500 },
                { name: 'Burbank (KBUR)', center: [34.2007, -118.3585], polygon: [[34.27, -118.36], [34.24, -118.28], [34.20, -118.26], [34.15, -118.29], [34.13, -118.36], [34.15, -118.43], [34.20, -118.45], [34.25, -118.42]], floor: 0, ceiling: 3000 },
                { name: 'Oakland (KOAK)', center: [37.7213, -122.2208], polygon: [[37.79, -122.22], [37.76, -122.14], [37.72, -122.12], [37.67, -122.15], [37.65, -122.22], [37.67, -122.29], [37.72, -122.31], [37.77, -122.28]], floor: 0, ceiling: 2500 },
                { name: 'San Jose (KSJC)', center: [37.3626, -121.9291], polygon: [[37.43, -121.93], [37.40, -121.85], [37.36, -121.83], [37.31, -121.86], [37.29, -121.93], [37.31, -122.00], [37.36, -122.02], [37.41, -121.99]], floor: 0, ceiling: 2500 },
                { name: 'Midway (KMDW)', center: [41.7868, -87.7522], polygon: [[41.85, -87.75], [41.83, -87.68], [41.79, -87.66], [41.74, -87.69], [41.72, -87.75], [41.74, -87.81], [41.79, -87.83], [41.83, -87.80]], floor: 0, ceiling: 3000 },
                { name: 'Love Field (KDAL)', center: [32.8471, -96.8518], polygon: [[32.91, -96.85], [32.89, -96.78], [32.85, -96.76], [32.80, -96.79], [32.78, -96.85], [32.80, -96.91], [32.85, -96.93], [32.89, -96.90]], floor: 0, ceiling: 3500 },
                { name: 'Reagan National (KDCA)', center: [38.8512, -77.0402], polygon: [[38.92, -77.04], [38.89, -76.97], [38.85, -76.95], [38.80, -76.98], [38.78, -77.04], [38.80, -77.10], [38.85, -77.12], [38.90, -77.09]], floor: 0, ceiling: 2500 },
            ]
        };

        function createAirspaceOverlay() {
            airspaceLayer.clearLayers();
            const zoomLevel = map.getZoom();

            // Class B - Blue with multiple tiers
            airspaceData.classB.forEach(airspace => {
                airspace.tiers.forEach((tier, index) => {
                    const refinedCoords = refinePolygon(tier.polygon, zoomLevel);
                    const polygon = L.polygon(refinedCoords, {
                        color: '#3b82f6',
                        fillColor: '#3b82f6',
                        fillOpacity: 0.05 + (index * 0.03),
                        weight: index === 0 ? 2 : 1,
                        dashArray: index === 0 ? null : '4, 4'
                    });
                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:#3b82f6">${airspace.name}</div>
                        <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Class B Airspace - ATC Clearance Required</div>
                        <div><b>Tier:</b> ${index === 0 ? 'Core (Mode C Veil)' : 'Shelf ' + index}</div>
                        <div><b>Floor:</b> ${tier.floor === 0 ? 'Surface' : tier.floor.toLocaleString() + ' ft MSL'}</div>
                        <div><b>Ceiling:</b> ${tier.ceiling.toLocaleString()} ft MSL</div>
                        <div style="margin-top:4px;font-size:10px;opacity:0.9"><b>Requirements:</b> ATC clearance, Mode C transponder, two-way radio</div>
                    `, { sticky: true });
                    airspaceLayer.addLayer(polygon);
                });
            });

            // Class C - Magenta with tiers
            airspaceData.classC.forEach(airspace => {
                airspace.tiers.forEach((tier, index) => {
                    const refinedCoords = refinePolygon(tier.polygon, zoomLevel);
                    const polygon = L.polygon(refinedCoords, {
                        color: '#ec4899',
                        fillColor: '#ec4899',
                        fillOpacity: 0.08 + (index * 0.04),
                        weight: index === 0 ? 2 : 1,
                        dashArray: index === 0 ? null : '3, 3'
                    });
                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:#ec4899">${airspace.name}</div>
                        <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Class C Airspace - Two-Way Radio Required</div>
                        <div><b>Tier:</b> ${index === 0 ? 'Core (5 NM radius)' : 'Shelf (10 NM radius)'}</div>
                        <div><b>Floor:</b> ${tier.floor === 0 ? 'Surface' : tier.floor.toLocaleString() + ' ft MSL'}</div>
                        <div><b>Ceiling:</b> ${tier.ceiling.toLocaleString()} ft MSL</div>
                        <div style="margin-top:4px;font-size:10px;opacity:0.9"><b>Requirements:</b> Radio contact, Mode C transponder</div>
                    `, { sticky: true });
                    airspaceLayer.addLayer(polygon);
                });
            });

            // Class D - Dashed blue polygons
            airspaceData.classD.forEach(zone => {
                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const polygon = L.polygon(refinedCoords, {
                    color: '#60a5fa',
                    fillColor: '#60a5fa',
                    fillOpacity: 0.05,
                    weight: 2,
                    dashArray: '6, 4'
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#60a5fa">${zone.name}</div>
                    <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Class D Airspace - Control Tower Active</div>
                    <div><b>Radius:</b> ~4 NM</div>
                    <div><b>Floor:</b> Surface</div>
                    <div><b>Ceiling:</b> ${zone.ceiling.toLocaleString()} ft AGL</div>
                    <div style="margin-top:4px;font-size:10px;opacity:0.9"><b>Requirements:</b> Two-way radio, establish communication</div>
                `, { sticky: true });
                airspaceLayer.addLayer(polygon);
            });

            // MOAs - Orange/Brown
            airspaceData.moa.forEach(zone => {
                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const polygon = L.polygon(refinedCoords, {
                    color: '#d97706',
                    fillColor: '#d97706',
                    fillOpacity: 0.1,
                    weight: 2,
                    dashArray: '8, 4'
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#d97706">${zone.name}</div>
                    <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Military Operations Area - Caution Advised</div>
                    <div><b>Floor:</b> ${zone.floor.toLocaleString()} ft MSL</div>
                    <div><b>Ceiling:</b> ${zone.ceiling.toLocaleString()} ft MSL</div>
                    <div style="margin-top:4px;font-size:10px;opacity:0.9"><b>Note:</b> VFR flight permitted but exercise extreme caution. Contact FSS for activity status.</div>
                `, { sticky: true });
                airspaceLayer.addLayer(polygon);
            });

            // Restricted - Red hatched
            airspaceData.restricted.forEach(zone => {
                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const polygon = L.polygon(refinedCoords, {
                    color: '#ef4444',
                    fillColor: '#ef4444',
                    fillOpacity: 0.12,
                    weight: 2,
                    dashArray: '6, 3'
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#ef4444">${zone.name}</div>
                    <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Restricted Area - Authorization Required</div>
                    <div><b>Floor:</b> Surface</div>
                    <div><b>Ceiling:</b> ${zone.ceiling >= 99999 ? 'Unlimited' : zone.ceiling.toLocaleString() + ' ft MSL'}</div>
                    <div style="margin-top:4px;font-size:10px;opacity:0.9;color:#fca5a5"><b> Warning:</b> Flight prohibited without authorization from controlling agency.</div>
                `, { sticky: true });
                airspaceLayer.addLayer(polygon);
            });

            // Prohibited - Solid red
            airspaceData.prohibited.forEach(zone => {
                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const polygon = L.polygon(refinedCoords, {
                    color: '#dc2626',
                    fillColor: '#dc2626',
                    fillOpacity: 0.25,
                    weight: 3
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#dc2626">${zone.name}</div>
                    <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Prohibited Area - NO ENTRY</div>
                    <div><b>Floor:</b> Surface</div>
                    <div><b>Ceiling:</b> ${zone.ceiling >= 99999 ? 'Unlimited' : zone.ceiling.toLocaleString() + ' ft MSL'}</div>
                    <div style="margin-top:4px;font-size:10px;opacity:0.9;color:#fca5a5"><b> PROHIBITED:</b> Flight is strictly forbidden. Interception/prosecution possible.</div>
                `, { sticky: true });
                airspaceLayer.addLayer(polygon);
            });

            // TFRs - Red polygons with warning
            airspaceData.tfr.forEach(zone => {
                if (zone.active) {
                    const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                    const polygon = L.polygon(refinedCoords, {
                        color: '#ff0000',
                        fillColor: '#ff0000',
                        fillOpacity: 0.2,
                        weight: 3,
                        dashArray: '5, 5'
                    });
                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:#ff0000"> ${zone.name}</div>
                        <div style="font-size:10px;opacity:0.8;margin-bottom:6px;color:#fca5a5">TEMPORARY FLIGHT RESTRICTION - ACTIVE</div>
                        <div><b>Floor:</b> Surface</div>
                        <div><b>Ceiling:</b> ${zone.ceiling.toLocaleString()} ft AGL</div>
                        <div style="margin-top:4px;font-size:10px;opacity:0.9;color:#fca5a5"><b> ACTIVE TFR:</b> Check NOTAMs for specific times and requirements. Interception likely.</div>
                    `, { sticky: true });
                    airspaceLayer.addLayer(polygon);
                }
            });
        }

        // Initialize airspace
        createAirspaceOverlay();

        // Initialize overlay layers
        createIcingOverlay();
        createTurbulenceOverlay();

        // Refresh polygon overlays when zoom changes for higher fidelity at close zoom
        let zoomRefreshTimeout = null;
        function refreshPolygonOverlays() {
            // Refresh all polygon-based overlays to show higher detail at current zoom
            if (overlayState.terrain) {
                createTerrainOverlay();
            }
            if (overlayState.airspace) {
                createAirspaceOverlay();
            }
            if (overlayState.icing) {
                createIcingOverlay();
            }
            if (overlayState.turbulence) {
                createTurbulenceOverlay();
            }
            if (overlayState.ceiling) {
                createCeilingOverlay();
            }
            if (overlayState.visibility) {
                createVisibilityOverlay();
            }
            if (overlayState.temperature) {
                createTemperatureOverlay();
            }
            if (overlayState.dewpoint) {
                createDewpointOverlay();
            }
        }

        // Debounced zoom handler for performance
        map.on('zoomend', function() {
            if (zoomRefreshTimeout) clearTimeout(zoomRefreshTimeout);
            zoomRefreshTimeout = setTimeout(refreshPolygonOverlays, 150);
        });

        // Radar layer (RainViewer API - free weather radar)
        let radarLayer = null;
        let radarTimestamp = null;

        async function loadRadarLayer() {
            try {

                // Get radar timestamps from RainViewer
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                const data = await response.json();

                if (data.radar && data.radar.past && data.radar.past.length > 0) {
                    // Get the most recent radar frame
                    const latestFrame = data.radar.past[data.radar.past.length - 1];
                    radarTimestamp = new Date(latestFrame.time * 1000);

                    // Remove old layer if exists
                    if (radarLayer) {
                        map.removeLayer(radarLayer);
                    }

                    // Add new radar layer
                    radarLayer = L.tileLayer(`https://tilecache.rainviewer.com${latestFrame.path}/256/{z}/{x}/{y}/4/1_1.png`, {
                        opacity: 0.7,
                        zIndex: 100
                    });

                    if (overlayState.radar) {
                        radarLayer.addTo(map);
                    }

                    // Update timestamp display
                    document.getElementById('radarTimestamp').textContent =
                        `Radar: ${radarTimestamp.toLocaleTimeString()} UTC`;
                }
            } catch (error) {
                console.error('Failed to load radar:', error);
                document.getElementById('radarTimestamp').textContent = 'Radar: Error';
            }
        }

        // METAR stations layer
        let metarMarkers = L.layerGroup();
        const metarStations = [
            // Major Hubs
            { id: 'KJFK', name: 'New York JFK', lat: 40.6413, lon: -73.7781 },
            { id: 'KLAX', name: 'Los Angeles', lat: 33.9425, lon: -118.4081 },
            { id: 'KORD', name: 'Chicago O\'Hare', lat: 41.9742, lon: -87.9073 },
            { id: 'KATL', name: 'Atlanta', lat: 33.6407, lon: -84.4277 },
            { id: 'KDFW', name: 'Dallas/Fort Worth', lat: 32.8998, lon: -97.0403 },
            { id: 'KDEN', name: 'Denver', lat: 39.8561, lon: -104.6737 },
            { id: 'KSFO', name: 'San Francisco', lat: 37.6213, lon: -122.3790 },
            { id: 'KSEA', name: 'Seattle', lat: 47.4502, lon: -122.3088 },
            { id: 'KMIA', name: 'Miami', lat: 25.7959, lon: -80.2870 },
            { id: 'KBOS', name: 'Boston', lat: 42.3656, lon: -71.0096 },
            { id: 'KPHX', name: 'Phoenix', lat: 33.4373, lon: -112.0078 },
            { id: 'KMSP', name: 'Minneapolis', lat: 44.8848, lon: -93.2223 },
            { id: 'KDTW', name: 'Detroit', lat: 42.2162, lon: -83.3554 },
            { id: 'KIAH', name: 'Houston Intercontinental', lat: 29.9902, lon: -95.3368 },
            { id: 'KLGA', name: 'LaGuardia', lat: 40.7769, lon: -73.8740 },
            { id: 'KEWR', name: 'Newark', lat: 40.6895, lon: -74.1745 },
            { id: 'KPHL', name: 'Philadelphia', lat: 39.8744, lon: -75.2424 },
            { id: 'KDCA', name: 'Washington Reagan', lat: 38.8512, lon: -77.0402 },
            { id: 'KIAD', name: 'Washington Dulles', lat: 38.9531, lon: -77.4565 },
            { id: 'KLAS', name: 'Las Vegas', lat: 36.0840, lon: -115.1537 },
            // California
            { id: 'KSAN', name: 'San Diego', lat: 32.7336, lon: -117.1897 },
            { id: 'KOAK', name: 'Oakland', lat: 37.7213, lon: -122.2208 },
            { id: 'KSJC', name: 'San Jose', lat: 37.3626, lon: -121.9291 },
            { id: 'KONT', name: 'Ontario', lat: 34.0560, lon: -117.6012 },
            { id: 'KBUR', name: 'Burbank', lat: 34.2007, lon: -118.3585 },
            { id: 'KSNA', name: 'John Wayne Orange County', lat: 33.6757, lon: -117.8682 },
            { id: 'KPSP', name: 'Palm Springs', lat: 33.8303, lon: -116.5067 },
            { id: 'KSMF', name: 'Sacramento', lat: 38.6954, lon: -121.5908 },
            { id: 'KFAT', name: 'Fresno', lat: 36.7762, lon: -119.7181 },
            { id: 'KSBP', name: 'San Luis Obispo', lat: 35.2368, lon: -120.6424 },
            { id: 'KMRY', name: 'Monterey', lat: 36.5870, lon: -121.8430 },
            { id: 'KCRQ', name: 'Carlsbad', lat: 33.1283, lon: -117.2803 },
            { id: 'KSBA', name: 'Santa Barbara', lat: 34.4262, lon: -119.8404 },
            { id: 'KLGB', name: 'Long Beach', lat: 33.8177, lon: -118.1516 },
            // Southwest
            { id: 'KTUS', name: 'Tucson', lat: 32.1161, lon: -110.9410 },
            { id: 'KABQ', name: 'Albuquerque', lat: 35.0402, lon: -106.6094 },
            { id: 'KELP', name: 'El Paso', lat: 31.8072, lon: -106.3778 },
            { id: 'KSLC', name: 'Salt Lake City', lat: 40.7884, lon: -111.9778 },
            // Texas
            { id: 'KHOU', name: 'Houston Hobby', lat: 29.6454, lon: -95.2789 },
            { id: 'KAUS', name: 'Austin', lat: 30.1975, lon: -97.6664 },
            { id: 'KSAT', name: 'San Antonio', lat: 29.5337, lon: -98.4698 },
            { id: 'KDAL', name: 'Dallas Love Field', lat: 32.8471, lon: -96.8518 },
            { id: 'KMAF', name: 'Midland', lat: 31.9425, lon: -102.2019 },
            { id: 'KLBB', name: 'Lubbock', lat: 33.6636, lon: -101.8228 },
            { id: 'KAMA', name: 'Amarillo', lat: 35.2194, lon: -101.7059 },
            { id: 'KCRP', name: 'Corpus Christi', lat: 27.7704, lon: -97.5012 },
            // Florida
            { id: 'KTPA', name: 'Tampa', lat: 27.9755, lon: -82.5332 },
            { id: 'KMCO', name: 'Orlando', lat: 28.4294, lon: -81.3090 },
            { id: 'KFLL', name: 'Fort Lauderdale', lat: 26.0726, lon: -80.1527 },
            { id: 'KPBI', name: 'Palm Beach', lat: 26.6832, lon: -80.0956 },
            { id: 'KJAX', name: 'Jacksonville', lat: 30.4941, lon: -81.6879 },
            { id: 'KRSW', name: 'Fort Myers', lat: 26.5362, lon: -81.7552 },
            { id: 'KSRQ', name: 'Sarasota', lat: 27.3954, lon: -82.5544 },
            { id: 'KPNS', name: 'Pensacola', lat: 30.4734, lon: -87.1866 },
            { id: 'KEYW', name: 'Key West', lat: 24.5561, lon: -81.7596 },
            // Southeast
            { id: 'KCLT', name: 'Charlotte', lat: 35.2140, lon: -80.9431 },
            { id: 'KRDU', name: 'Raleigh-Durham', lat: 35.8776, lon: -78.7875 },
            { id: 'KBNA', name: 'Nashville', lat: 36.1245, lon: -86.6782 },
            { id: 'KMEM', name: 'Memphis', lat: 35.0424, lon: -89.9767 },
            { id: 'KBHM', name: 'Birmingham', lat: 33.5629, lon: -86.7535 },
            { id: 'KMSY', name: 'New Orleans', lat: 29.9934, lon: -90.2580 },
            { id: 'KSAV', name: 'Savannah', lat: 32.1276, lon: -81.2021 },
            { id: 'KCHS', name: 'Charleston', lat: 32.8986, lon: -80.0405 },
            // Midwest
            { id: 'KSTL', name: 'St. Louis', lat: 38.7487, lon: -90.3700 },
            { id: 'KMCI', name: 'Kansas City', lat: 39.2976, lon: -94.7139 },
            { id: 'KOMA', name: 'Omaha', lat: 41.3032, lon: -95.8941 },
            { id: 'KDSM', name: 'Des Moines', lat: 41.5340, lon: -93.6631 },
            { id: 'KIND', name: 'Indianapolis', lat: 39.7173, lon: -86.2944 },
            { id: 'KCMH', name: 'Columbus', lat: 39.9980, lon: -82.8919 },
            { id: 'KCLE', name: 'Cleveland', lat: 41.4117, lon: -81.8498 },
            { id: 'KCVG', name: 'Cincinnati', lat: 39.0489, lon: -84.6678 },
            { id: 'KPIT', name: 'Pittsburgh', lat: 40.4915, lon: -80.2329 },
            { id: 'KMDW', name: 'Chicago Midway', lat: 41.7868, lon: -87.7522 },
            { id: 'KMKE', name: 'Milwaukee', lat: 42.9472, lon: -87.8966 },
            { id: 'KOSH', name: 'Oshkosh', lat: 43.9844, lon: -88.5570 },
            // Northeast
            { id: 'KBWI', name: 'Baltimore', lat: 39.1754, lon: -76.6683 },
            { id: 'KBDL', name: 'Hartford', lat: 41.9389, lon: -72.6832 },
            { id: 'KPVD', name: 'Providence', lat: 41.7267, lon: -71.4284 },
            { id: 'KMHT', name: 'Manchester NH', lat: 42.9326, lon: -71.4357 },
            { id: 'KPWM', name: 'Portland ME', lat: 43.6462, lon: -70.3093 },
            { id: 'KBTV', name: 'Burlington VT', lat: 44.4720, lon: -73.1533 },
            { id: 'KSYR', name: 'Syracuse', lat: 43.1112, lon: -76.1063 },
            { id: 'KBUF', name: 'Buffalo', lat: 42.9405, lon: -78.7322 },
            { id: 'KROC', name: 'Rochester', lat: 43.1189, lon: -77.6724 },
            { id: 'KALB', name: 'Albany', lat: 42.7483, lon: -73.8017 },
            // Northwest
            { id: 'KPDX', name: 'Portland OR', lat: 45.5898, lon: -122.5951 },
            { id: 'KBOI', name: 'Boise', lat: 43.5644, lon: -116.2228 },
            { id: 'KGEG', name: 'Spokane', lat: 47.6199, lon: -117.5338 },
            { id: 'KBZN', name: 'Bozeman', lat: 45.7775, lon: -111.1530 },
            { id: 'KMSO', name: 'Missoula', lat: 46.9163, lon: -114.0906 },
            { id: 'KBIL', name: 'Billings', lat: 45.8077, lon: -108.5429 },
            // Mountain/West
            { id: 'KCOS', name: 'Colorado Springs', lat: 38.8058, lon: -104.7007 },
            { id: 'KASE', name: 'Aspen', lat: 39.2232, lon: -106.8689 },
            { id: 'KEGE', name: 'Eagle/Vail', lat: 39.6426, lon: -106.9176 },
            { id: 'KGJT', name: 'Grand Junction', lat: 39.1224, lon: -108.5267 },
            { id: 'KRAP', name: 'Rapid City', lat: 44.0453, lon: -103.0574 },
            { id: 'KFSD', name: 'Sioux Falls', lat: 43.5820, lon: -96.7419 },
            { id: 'KJAC', name: 'Jackson Hole', lat: 43.6073, lon: -110.7377 },
            { id: 'KRNO', name: 'Reno', lat: 39.4991, lon: -119.7681 },
            // Alaska & Hawaii
            { id: 'PANC', name: 'Anchorage', lat: 61.1744, lon: -149.9964 },
            { id: 'PAFA', name: 'Fairbanks', lat: 64.8151, lon: -147.8561 },
            { id: 'PAJN', name: 'Juneau', lat: 58.3549, lon: -134.5762 },
            { id: 'PHNL', name: 'Honolulu', lat: 21.3187, lon: -157.9225 },
            { id: 'PHOG', name: 'Maui/Kahului', lat: 20.8986, lon: -156.4305 },
            { id: 'PHKO', name: 'Kona', lat: 19.7388, lon: -156.0456 },
            { id: 'PHLI', name: 'Lihue', lat: 21.9760, lon: -159.3390 },
            // Additional Regional
            { id: 'KICT', name: 'Wichita', lat: 37.6499, lon: -97.4331 },
            { id: 'KTUL', name: 'Tulsa', lat: 36.1984, lon: -95.8881 },
            { id: 'KOKC', name: 'Oklahoma City', lat: 35.3931, lon: -97.6007 },
            { id: 'KLIT', name: 'Little Rock', lat: 34.7294, lon: -92.2243 },
            { id: 'KSGF', name: 'Springfield MO', lat: 37.2457, lon: -93.3886 },
            { id: 'KLEX', name: 'Lexington', lat: 38.0365, lon: -84.6059 },
            { id: 'KSDF', name: 'Louisville', lat: 38.1740, lon: -85.7360 },
            { id: 'KGRR', name: 'Grand Rapids', lat: 42.8808, lon: -85.5228 },
            { id: 'KLAN', name: 'Lansing', lat: 42.7787, lon: -84.5874 },
            { id: 'KFNT', name: 'Flint', lat: 42.9655, lon: -83.7436 },
            { id: 'KGSO', name: 'Greensboro', lat: 36.0978, lon: -79.9373 },
            { id: 'KAVL', name: 'Asheville', lat: 35.4362, lon: -82.5418 },
            { id: 'KMYR', name: 'Myrtle Beach', lat: 33.6797, lon: -78.9283 },
            { id: 'KILM', name: 'Wilmington NC', lat: 34.2706, lon: -77.9026 },
            { id: 'KRIC', name: 'Richmond', lat: 37.5052, lon: -77.3197 },
            { id: 'KORF', name: 'Norfolk', lat: 36.8946, lon: -76.2012 },
            { id: 'KROA', name: 'Roanoke', lat: 37.3255, lon: -79.9754 }
        ];

        // Flight rules colors
        const flightRulesColors = {
            'VFR': '#22c55e',
            'MVFR': '#3b82f6',
            'IFR': '#ef4444',
            'LIFR': '#a855f7'
        };

        // Store METAR data
        const metarData = {};

        // Overlay states (for both map and profile)
        const overlayState = {
            terrain: false,
            clouds: false,
            ceiling: false,
            visibility: false,
            airspace: false,
            icing: false,
            turbulence: false,
            winds: false,
            temperature: false,
            dewpoint: false,
            radar: false,
            stations: false
        };

        // Alias for profile drawing compatibility
        const profileOverlays = overlayState;

        // Current route for redrawing
        let currentRoute = { dep: null, dest: null };

        // Custom waypoint state
        let waypointMode = false;
        let snapMode = false;
        let customWaypoints = [];
        let waypointMarkers = [];
        let waypointPreviewLine = null;
        let waypointCounter = 0;

        // Profile zoom and pan state
        const profileView = {
            zoom: 1,
            panX: 0,  // Pan offset in pixels (horizontal)
            panY: 0,  // Pan offset in pixels (vertical)
            isDragging: false,
            lastMouseX: 0,
            lastMouseY: 0
        };

        // Constrain pan to keep content visible within viewport
        function constrainPan() {
            const canvas = document.getElementById('profileCanvas');
            if (!canvas) return;

            const width = canvas.width;
            const height = canvas.height;
            const zoom = profileView.zoom;
            const padding = 50; // Match the profile drawing padding
            const paddingBottom = 80; // Match the profile drawing padding

            // At zoom 1, no panning (everything fits)
            if (zoom <= 1) {
                profileView.panX = 0;
                profileView.panY = 0;
                return;
            }

            // Calculate the visible canvas coordinate range for current pan
            // Screen coords 0 to width map to canvas coords based on transform:
            // screenX = (canvasX - centerX) * zoom + centerX + panX
            // So: canvasX = (screenX - centerX - panX) / zoom + centerX

            const centerX = width / 2;
            const centerY = height / 2;

            // Content bounds in canvas coordinates
            const contentLeft = padding;
            const contentRight = width - padding;
            const contentTop = padding;
            const contentBottom = height - paddingBottom;

            // Calculate max pan to keep content edges within view
            // We want: when panned max right, content left edge is at screen left (+ small margin)
            // And: when panned max left, content right edge is at screen right (- small margin)

            // Content left edge on screen: (contentLeft - centerX) * zoom + centerX + panX
            // For this to be <= some margin (e.g., width * 0.1): panX <= margin - (contentLeft - centerX) * zoom - centerX

            // Content right edge on screen: (contentRight - centerX) * zoom + centerX + panX
            // For this to be >= width - margin: panX >= width - margin - (contentRight - centerX) * zoom - centerX

            const margin = width * 0.15; // Keep at least 15% content visible

            // Max pan right (content shifts left): content left edge should stay at least at margin
            const maxPanRight = margin - (contentLeft - centerX) * zoom - centerX;

            // Max pan left (content shifts right): content right edge should stay at least at width - margin
            const maxPanLeft = (width - margin) - (contentRight - centerX) * zoom - centerX;

            // Vertical constraints (similar logic)
            const marginY = height * 0.15;
            const maxPanDown = marginY - (contentTop - centerY) * zoom - centerY;
            const maxPanUp = (height - marginY) - (contentBottom - centerY) * zoom - centerY;

            // Apply constraints
            profileView.panX = Math.max(maxPanLeft, Math.min(maxPanRight, profileView.panX));
            profileView.panY = Math.max(maxPanUp, Math.min(maxPanDown, profileView.panY));
        }

        // Zoom functions
        function profileZoom(factor) {
            const oldZoom = profileView.zoom;
            profileView.zoom = Math.max(1, Math.min(10, profileView.zoom * factor));

            // Scale pan proportionally when zooming
            if (oldZoom !== profileView.zoom) {
                const zoomRatio = profileView.zoom / oldZoom;
                profileView.panX *= zoomRatio;
                profileView.panY *= zoomRatio;
            }

            constrainPan();
            updateZoomDisplay();
            if (currentRoute.dep && currentRoute.dest) {
                drawProfile(currentRoute.dep, currentRoute.dest);
            }
        }

        function profileResetZoom() {
            profileView.zoom = 1;
            profileView.panX = 0;
            profileView.panY = 0;
            updateZoomDisplay();
            if (currentRoute.dep && currentRoute.dest) {
                drawProfile(currentRoute.dep, currentRoute.dest);
            }
        }

        function updateZoomDisplay() {
            document.getElementById('profileZoomLevel').textContent = profileView.zoom.toFixed(1) + 'x';
        }

        // Setup profile zoom/pan events
        function setupProfileZoomPan() {
            const canvas = document.getElementById('profileCanvas');

            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const oldZoom = profileView.zoom;
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                profileView.zoom = Math.max(1, Math.min(10, profileView.zoom * zoomFactor));

                if (oldZoom !== profileView.zoom) {
                    // Zoom toward mouse position
                    // Calculate offset from center
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const offsetX = mouseX - centerX;
                    const offsetY = mouseY - centerY;

                    // Adjust pan to keep mouse position stable
                    const zoomRatio = profileView.zoom / oldZoom;
                    profileView.panX = profileView.panX * zoomRatio - offsetX * (zoomRatio - 1);
                    profileView.panY = profileView.panY * zoomRatio - offsetY * (zoomRatio - 1);

                    constrainPan();
                    updateZoomDisplay();
                    if (currentRoute.dep && currentRoute.dest) {
                        drawProfile(currentRoute.dep, currentRoute.dest);
                    }
                }
            }, { passive: false });

            // Mouse drag pan
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0 && profileView.zoom > 1) { // Left click and zoomed in
                    profileView.isDragging = true;
                    profileView.lastMouseX = e.clientX;
                    profileView.lastMouseY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (profileView.isDragging) {
                    const dx = e.clientX - profileView.lastMouseX;
                    const dy = e.clientY - profileView.lastMouseY;
                    profileView.panX += dx;
                    profileView.panY += dy;
                    profileView.lastMouseX = e.clientX;
                    profileView.lastMouseY = e.clientY;

                    constrainPan();
                    if (currentRoute.dep && currentRoute.dest) {
                        drawProfile(currentRoute.dep, currentRoute.dest);
                    }
                }
            });

            canvas.addEventListener('mouseup', () => {
                profileView.isDragging = false;
                canvas.style.cursor = 'crosshair';
            });

            canvas.addEventListener('mouseleave', () => {
                profileView.isDragging = false;
                canvas.style.cursor = 'crosshair';
            });
        }

        // Helper function to remove an overlay layer from the map
        function removeOverlayLayer(overlay) {
            switch (overlay) {
                case 'terrain':
                    map.removeLayer(terrainLayer);
                    break;
                case 'clouds':
                    if (cloudsLayer) map.removeLayer(cloudsLayer);
                    break;
                case 'ceiling':
                    map.removeLayer(ceilingLayer);
                    break;
                case 'visibility':
                    map.removeLayer(visibilityLayer);
                    break;
                case 'airspace':
                    map.removeLayer(airspaceLayer);
                    break;
                case 'icing':
                    map.removeLayer(icingLayer);
                    break;
                case 'turbulence':
                    map.removeLayer(turbulenceLayer);
                    break;
                case 'winds':
                    map.removeLayer(windsLayer);
                    break;
                case 'temperature':
                    map.removeLayer(temperatureLayer);
                    break;
                case 'dewpoint':
                    map.removeLayer(dewpointLayer);
                    break;
            }
        }

        // Toggle overlay (affects both map and profile)
        function toggleOverlay(btn) {
            const overlay = btn.dataset.overlay;

            // Define overlay categories - only one active per category
            const category1 = ['terrain', 'clouds', 'ceiling', 'visibility', 'airspace']; // Environment/Airspace
            const category2 = ['icing', 'turbulence', 'winds', 'temperature', 'dewpoint']; // Weather/Conditions

            // Determine which category this overlay belongs to
            const isCategory1 = category1.includes(overlay);
            const isCategory2 = category2.includes(overlay);

            // If turning ON this overlay, turn OFF others in the same category
            if (!overlayState[overlay]) {
                const categoryOverlays = isCategory1 ? category1 : (isCategory2 ? category2 : []);

                categoryOverlays.forEach(otherOverlay => {
                    if (otherOverlay !== overlay && overlayState[otherOverlay]) {
                        // Turn off the other overlay
                        overlayState[otherOverlay] = false;

                        // Remove active class from button
                        const otherBtn = document.querySelector(`[data-overlay="${otherOverlay}"]`);
                        if (otherBtn) otherBtn.classList.remove('active');

                        // Remove the layer from map
                        removeOverlayLayer(otherOverlay);
                    }
                });
            }

            overlayState[overlay] = !overlayState[overlay];
            btn.classList.toggle('active');

            // Handle map layers
            switch (overlay) {
                case 'terrain':
                    if (overlayState.terrain) {
                        createTerrainOverlay();
                        terrainLayer.addTo(map);
                    } else {
                        map.removeLayer(terrainLayer);
                    }
                    break;

                case 'clouds':
                    if (overlayState.clouds && cloudsLayer) {
                        cloudsLayer.addTo(map);
                    } else if (cloudsLayer) {
                        map.removeLayer(cloudsLayer);
                    }
                    break;

                case 'ceiling':
                    if (overlayState.ceiling) {
                        createCeilingOverlay();
                        ceilingLayer.addTo(map);
                    } else {
                        map.removeLayer(ceilingLayer);
                    }
                    break;

                case 'visibility':
                    if (overlayState.visibility) {
                        createVisibilityOverlay();
                        visibilityLayer.addTo(map);
                    } else {
                        map.removeLayer(visibilityLayer);
                    }
                    break;

                case 'airspace':
                    if (overlayState.airspace) {
                        createAirspaceOverlay(); // Recreate with current zoom level
                        airspaceLayer.addTo(map);
                    } else {
                        map.removeLayer(airspaceLayer);
                    }
                    break;

                case 'icing':
                    if (overlayState.icing) {
                        createIcingOverlay(); // Recreate with current zoom level
                        icingLayer.addTo(map);
                    } else {
                        map.removeLayer(icingLayer);
                    }
                    break;

                case 'turbulence':
                    if (overlayState.turbulence) {
                        createTurbulenceOverlay(); // Recreate with current zoom level
                        turbulenceLayer.addTo(map);
                    } else {
                        map.removeLayer(turbulenceLayer);
                    }
                    break;

                case 'winds':
                    if (overlayState.winds) {
                        createWindsOverlay();
                        windsLayer.addTo(map);
                    } else {
                        map.removeLayer(windsLayer);
                    }
                    break;

                case 'temperature':
                    if (overlayState.temperature) {
                        createTemperatureOverlay();
                        temperatureLayer.addTo(map);
                    } else {
                        map.removeLayer(temperatureLayer);
                    }
                    break;

                case 'dewpoint':
                    if (overlayState.dewpoint) {
                        createDewpointOverlay();
                        dewpointLayer.addTo(map);
                    } else {
                        map.removeLayer(dewpointLayer);
                    }
                    break;

                case 'radar':
                    if (overlayState.radar && radarLayer) {
                        radarLayer.addTo(map);
                    } else if (radarLayer) {
                        map.removeLayer(radarLayer);
                    }
                    break;

                case 'stations':
                    if (overlayState.stations) {
                        metarMarkers.addTo(map);
                    } else {
                        map.removeLayer(metarMarkers);
                    }
                    break;
            }

            // Redraw profile if route is loaded
            if (currentRoute.dep && currentRoute.dest) {
                drawProfile(currentRoute.dep, currentRoute.dest);
            }
        }

        async function loadMetarStations() {
            metarMarkers.clearLayers();

            // Fetch all stations in parallel for much faster loading
            const fetchPromises = metarStations.map(async (station) => {
                try {
                    const response = await fetch(`/api/aviation/metar/${station.id}`);
                    if (response.ok) {
                        const data = await response.json();
                        return { station, data, success: true };
                    }
                    return { station, success: false };
                } catch (error) {
                    console.error(`Failed to load METAR for ${station.id}:`, error);
                    return { station, success: false };
                }
            });

            const results = await Promise.all(fetchPromises);

            // Process results and create markers
            results.forEach(({ station, data, success }) => {
                if (success && data) {
                    metarData[station.id] = data;

                    const flightRules = data.flight_rules || 'VFR';
                    const color = flightRulesColors[flightRules] || '#22c55e';

                    const marker = L.circleMarker([station.lat, station.lon], {
                        radius: 8,
                        fillColor: color,
                        color: '#ffffff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    });

                    marker.on('click', (e) => {
                        // In waypoint mode, let the click pass through to add waypoint
                        if (waypointMode) {
                            return; // Don't show station info, let waypoint handler work
                        }
                        L.DomEvent.stopPropagation(e);
                        showStationInfo(station.id, data);
                    });
                    marker.bindTooltip(station.id, {
                        permanent: false,
                        direction: 'top',
                        className: 'station-tooltip'
                    });

                    metarMarkers.addLayer(marker);
                }
            });

            if (overlayState.stations) {
                metarMarkers.addTo(map);
            }

            // Update ceiling, visibility, and winds overlays with new METAR data
            if (overlayState.ceiling) {
                createCeilingOverlay();
                if (!map.hasLayer(ceilingLayer)) {
                    ceilingLayer.addTo(map);
                }
            }

            if (overlayState.visibility) {
                createVisibilityOverlay();
                if (!map.hasLayer(visibilityLayer)) {
                    visibilityLayer.addTo(map);
                }
            }

            if (overlayState.winds) {
                createWindsOverlay();
                if (!map.hasLayer(windsLayer)) {
                    windsLayer.addTo(map);
                }
            }

            if (overlayState.temperature) {
                createTemperatureOverlay();
                if (!map.hasLayer(temperatureLayer)) {
                    temperatureLayer.addTo(map);
                }
            }

            if (overlayState.dewpoint) {
                createDewpointOverlay();
                if (!map.hasLayer(dewpointLayer)) {
                    dewpointLayer.addTo(map);
                }
            }
        }

        // Show station info panel
        function showStationInfo(stationId, data) {
            const panel = document.getElementById('stationInfo');
            const station = metarStations.find(s => s.id === stationId);

            document.getElementById('stationName').textContent = `${stationId} - ${station?.name || ''}`;

            const flightRules = data.flight_rules || 'VFR';
            const frElement = document.getElementById('stationFlightRules');
            frElement.textContent = flightRules;
            frElement.className = `flight-rules ${flightRules.toLowerCase()}`;

            document.getElementById('stationMetar').textContent = data.raw_text || 'No METAR available';

            // Wind
            const windDir = data.wind_direction !== null ? `${data.wind_direction}` : '--';
            const windSpd = data.wind_speed !== null ? `${data.wind_speed}kt` : '--';
            const windGust = data.wind_gust ? `G${data.wind_gust}` : '';
            document.getElementById('stationWind').textContent = `${windDir} ${windSpd}${windGust}`;

            // Visibility
            document.getElementById('stationVis').textContent =
                data.visibility !== null ? `${data.visibility} SM` : '--';

            // Ceiling
            document.getElementById('stationCeiling').textContent =
                data.ceiling !== null ? `${data.ceiling} ft` : 'CLR';

            // Altimeter
            document.getElementById('stationAltimeter').textContent =
                data.altimeter !== null ? `${data.altimeter.toFixed(2)}"` : '--';

            panel.classList.add('visible');
        }

        function closeStationInfo() {
            document.getElementById('stationInfo').classList.remove('visible');
        }

        // Close station info when clicking on map (but not on markers)
        map.on('click', function(e) {
            // Don't close if in waypoint mode (that has its own handler)
            if (!waypointMode) {
                closeStationInfo();
            }
        });

        // Trip Summary Panel Functions
        function toggleTripSummary() {
            const panel = document.getElementById('tripSummary');
            panel.classList.toggle('expanded');
        }

        function showTripSummary() {
            const panel = document.getElementById('tripSummary');
            panel.classList.add('visible');
            // Start minimized - user can click to expand
        }

        function hideTripSummary() {
            const panel = document.getElementById('tripSummary');
            panel.classList.remove('visible');
            panel.classList.remove('expanded');
        }

        // Calculate avoidance waypoints around a restricted polygon
        function calculateAvoidanceWaypoints(entryLat, entryLon, exitLat, exitLon, polygon, zoneName) {
            if (!polygon || polygon.length < 3) return [];

            // Calculate polygon centroid
            let centroidLat = 0, centroidLon = 0;
            polygon.forEach(p => {
                centroidLat += p[0];
                centroidLon += p[1];
            });
            centroidLat /= polygon.length;
            centroidLon /= polygon.length;

            // Calculate route direction vector
            const routeDirLat = exitLat - entryLat;
            const routeDirLon = exitLon - entryLon;

            // Calculate perpendicular vector (rotated 90 degrees)
            const perpLat = -routeDirLon;
            const perpLon = routeDirLat;

            // Determine which side of the route the centroid is on
            const toCentroidLat = centroidLat - entryLat;
            const toCentroidLon = centroidLon - entryLon;
            const dot = toCentroidLat * perpLat + toCentroidLon * perpLon;

            // Calculate polygon bounding box for offset distance
            let minLat = Infinity, maxLat = -Infinity;
            let minLon = Infinity, maxLon = -Infinity;
            polygon.forEach(p => {
                minLat = Math.min(minLat, p[0]);
                maxLat = Math.max(maxLat, p[0]);
                minLon = Math.min(minLon, p[1]);
                maxLon = Math.max(maxLon, p[1]);
            });

            const polyWidth = maxLon - minLon;
            const polyHeight = maxLat - minLat;
            const offsetDist = Math.max(polyWidth, polyHeight) * 0.6 + 0.15; // Buffer distance

            // Go around on the opposite side of the centroid
            const offsetDir = dot > 0 ? -1 : 1;

            // Normalize perpendicular vector
            const perpLen = Math.sqrt(perpLat * perpLat + perpLon * perpLon);
            const normPerpLat = perpLat / perpLen;
            const normPerpLon = perpLon / perpLen;

            // Create two waypoints: one before and one after the polygon
            const midLat = (entryLat + exitLat) / 2;
            const midLon = (entryLon + exitLon) / 2;

            // First waypoint: before entering restricted area, offset perpendicular
            const wp1Lat = entryLat + normPerpLat * offsetDist * offsetDir;
            const wp1Lon = entryLon + normPerpLon * offsetDist * offsetDir;

            // Middle waypoint: at midpoint, maximum offset
            const wpMidLat = midLat + normPerpLat * offsetDist * offsetDir * 1.2;
            const wpMidLon = midLon + normPerpLon * offsetDist * offsetDir * 1.2;

            // Last waypoint: after exiting restricted area, offset perpendicular
            const wp2Lat = exitLat + normPerpLat * offsetDist * offsetDir;
            const wp2Lon = exitLon + normPerpLon * offsetDist * offsetDir;

            return [
                { lat: wp1Lat, lon: wp1Lon, name: `DVT-${zoneName.substring(0, 3)}1` },
                { lat: wpMidLat, lon: wpMidLon, name: `DVT-${zoneName.substring(0, 3)}2` },
                { lat: wp2Lat, lon: wp2Lon, name: `DVT-${zoneName.substring(0, 3)}3` }
            ];
        }

        // Check if direct route intersects any restricted/prohibited airspace
        function findRestrictedIntersections(depStation, destStation, cruiseAltitude) {
            const intersections = [];
            const numPoints = 50;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const lat = depStation.lat + t * (destStation.lat - depStation.lat);
                const lon = depStation.lon + t * (destStation.lon - depStation.lon);

                // Calculate altitude at this point
                let altitude = cruiseAltitude;
                if (t < 0.15) altitude = (t / 0.15) * cruiseAltitude;
                else if (t > 0.85) altitude = ((1 - t) / 0.15) * cruiseAltitude;

                // Check restricted airspace
                airspaceData.restricted.forEach(zone => {
                    if (pointInPolygon(lat, lon, zone.polygon)) {
                        if (altitude >= (zone.floor || 0) && altitude <= zone.ceiling) {
                            const existing = intersections.find(x => x.zone.name === zone.name);
                            if (!existing) {
                                intersections.push({
                                    zone: zone,
                                    type: 'restricted',
                                    entryT: t,
                                    exitT: t,
                                    entryLat: lat,
                                    entryLon: lon,
                                    exitLat: lat,
                                    exitLon: lon
                                });
                            } else {
                                existing.exitT = t;
                                existing.exitLat = lat;
                                existing.exitLon = lon;
                            }
                        }
                    }
                });

                // Check prohibited airspace
                airspaceData.prohibited.forEach(zone => {
                    if (pointInPolygon(lat, lon, zone.polygon)) {
                        const existing = intersections.find(x => x.zone.name === zone.name);
                        if (!existing) {
                            intersections.push({
                                zone: zone,
                                type: 'prohibited',
                                entryT: t,
                                exitT: t,
                                entryLat: lat,
                                entryLon: lon,
                                exitLat: lat,
                                exitLon: lon
                            });
                        } else {
                            existing.exitT = t;
                            existing.exitLat = lat;
                            existing.exitLon = lon;
                        }
                    }
                });
            }

            return intersections;
        }

        // Calculate comprehensive route with hazard avoidance
        function calculateEnhancedRoute(depStation, destStation, distance, customWaypointsInput = []) {
            const routeData = {
                departure: depStation,
                destination: destStation,
                distance: distance,
                waypoints: [],
                customWaypoints: customWaypointsInput, // Store custom waypoints
                phases: [],
                hazards: [],
                avoidanceManeuvers: [],
                fuelPlan: {},
                cruiseAltitude: 35000,
                estimatedTime: 0
            };

            // Aircraft performance assumptions (typical jet)
            const cruiseSpeed = 450; // knots
            const climbRate = 2500; // ft/min
            const descentRate = 1500; // ft/min
            const fuelBurnClimb = 250; // gal/hr
            const fuelBurnCruise = 180; // gal/hr
            const fuelBurnDescent = 100; // gal/hr
            const fuelReserve = 45; // minutes reserve

            // Calculate phases
            const climbDistance = Math.min(distance * 0.15, 150); // ~15% or max 150nm for climb
            const descentDistance = Math.min(distance * 0.12, 120); // ~12% or max 120nm for descent
            const cruiseDistance = distance - climbDistance - descentDistance;

            // Time calculations
            const climbTime = (routeData.cruiseAltitude / climbRate) / 60; // hours
            const cruiseTime = cruiseDistance / cruiseSpeed; // hours
            const descentTime = (routeData.cruiseAltitude / descentRate) / 60; // hours
            routeData.estimatedTime = climbTime + cruiseTime + descentTime;

            // Fuel calculations
            const climbFuel = climbTime * fuelBurnClimb;
            const cruiseFuel = cruiseTime * fuelBurnCruise;
            const descentFuel = descentTime * fuelBurnDescent;
            const reserveFuel = (fuelReserve / 60) * fuelBurnCruise;
            const totalFuel = climbFuel + cruiseFuel + descentFuel + reserveFuel;

            routeData.fuelPlan = {
                climb: Math.round(climbFuel),
                cruise: Math.round(cruiseFuel),
                descent: Math.round(descentFuel),
                reserve: Math.round(reserveFuel),
                total: Math.round(totalFuel),
                tankCapacity: 2000, // gallons assumed
                fuelStopRequired: totalFuel > 1800
            };

            // Add flight phases
            routeData.phases = [
                {
                    name: 'Climb',
                    type: 'climb',
                    startAlt: 0,
                    endAlt: routeData.cruiseAltitude,
                    distance: Math.round(climbDistance),
                    time: Math.round(climbTime * 60)
                },
                {
                    name: 'Cruise',
                    type: 'cruise',
                    startAlt: routeData.cruiseAltitude,
                    endAlt: routeData.cruiseAltitude,
                    distance: Math.round(cruiseDistance),
                    time: Math.round(cruiseTime * 60)
                },
                {
                    name: 'Descent',
                    type: 'descent',
                    startAlt: routeData.cruiseAltitude,
                    endAlt: 0,
                    distance: Math.round(descentDistance),
                    time: Math.round(descentTime * 60)
                }
            ];

            // Generate waypoints along route
            routeData.waypoints.push({
                name: depStation.id,
                type: 'departure',
                lat: depStation.lat,
                lon: depStation.lon,
                distance: 0
            });

            // Find all restricted/prohibited airspace intersections first
            const restrictedIntersections = findRestrictedIntersections(depStation, destStation, routeData.cruiseAltitude);

            // Generate avoidance waypoints for each intersection
            const avoidanceWaypointsAdded = new Set();
            restrictedIntersections.forEach(intersection => {
                const zone = intersection.zone;

                // Add hazard record
                routeData.hazards.push({
                    type: intersection.type,
                    severity: 'critical',
                    name: zone.name,
                    description: `${intersection.type === 'prohibited' ? 'Prohibited' : 'Restricted'} airspace ${zone.name}`,
                    location: Math.round(intersection.entryT * distance),
                    action: 'Route deviation required'
                });

                // Calculate proper avoidance waypoints
                if (!avoidanceWaypointsAdded.has(zone.name)) {
                    const avoidWaypoints = calculateAvoidanceWaypoints(
                        intersection.entryLat, intersection.entryLon,
                        intersection.exitLat, intersection.exitLon,
                        zone.polygon, zone.name
                    );

                    avoidWaypoints.forEach((wp, idx) => {
                        const wpDist = Math.round((intersection.entryT + idx * (intersection.exitT - intersection.entryT) / (avoidWaypoints.length - 1 || 1)) * distance);
                        routeData.waypoints.push({
                            name: wp.name,
                            type: 'divert',
                            lat: wp.lat,
                            lon: wp.lon,
                            distance: wpDist,
                            reason: `Avoiding ${zone.name}`
                        });
                    });

                    routeData.avoidanceManeuvers.push({
                        type: 'lateral',
                        reason: zone.name,
                        distance: Math.round(intersection.entryT * distance),
                        waypointsAdded: avoidWaypoints.length
                    });

                    avoidanceWaypointsAdded.add(zone.name);
                }
            });

            // Check for other hazards along the route
            const numCheckPoints = 20;
            for (let i = 1; i < numCheckPoints; i++) {
                const t = i / numCheckPoints;
                const lat = depStation.lat + t * (destStation.lat - depStation.lat);
                const lon = depStation.lon + t * (destStation.lon - depStation.lon);
                const pointDistance = Math.round(t * distance);

                // Determine altitude at this point
                let altitude = routeData.cruiseAltitude;
                if (t < 0.15) altitude = (t / 0.15) * routeData.cruiseAltitude;
                else if (t > 0.85) altitude = ((1 - t) / 0.15) * routeData.cruiseAltitude;

                // Check for turbulence
                flightHazards.turbulenceZones.forEach(zone => {
                    if (pointInPolygon(lat, lon, zone.polygon)) {
                        if (altitude >= zone.base && altitude <= zone.top) {
                            const existing = routeData.hazards.find(h => h.name === zone.name && h.type === 'turbulence');
                            if (!existing) {
                                routeData.hazards.push({
                                    type: 'turbulence',
                                    severity: zone.intensity.toLowerCase().includes('severe') ? 'critical' :
                                              zone.intensity.toLowerCase().includes('moderate') ? 'warning' : 'caution',
                                    name: zone.name,
                                    description: `${zone.intensity} turbulence: ${zone.base.toLocaleString()}-${zone.top.toLocaleString()} ft`,
                                    location: pointDistance,
                                    action: zone.intensity.toLowerCase().includes('severe') ? 'Altitude change recommended' : 'Expect bumps'
                                });
                            }
                        }
                    }
                });

                // Check for icing
                flightHazards.icingZones.forEach(zone => {
                    if (pointInPolygon(lat, lon, zone.polygon)) {
                        if (altitude >= zone.base && altitude <= zone.top) {
                            const existing = routeData.hazards.find(h => h.name === zone.name && h.type === 'icing');
                            if (!existing) {
                                routeData.hazards.push({
                                    type: 'icing',
                                    severity: zone.intensity.toLowerCase().includes('severe') ? 'critical' :
                                              zone.intensity.toLowerCase().includes('moderate') ? 'warning' : 'caution',
                                    name: zone.name,
                                    description: `${zone.intensity} icing: ${zone.base.toLocaleString()}-${zone.top.toLocaleString()} ft`,
                                    location: pointDistance,
                                    action: 'Monitor and use anti-ice'
                                });
                            }
                        }
                    }
                });
            }

            // Check weather at departure and destination
            const depMetar = metarData[depStation.id];
            const destMetar = metarData[destStation.id];

            if (depMetar) {
                if (depMetar.visibility && depMetar.visibility < 3) {
                    routeData.hazards.push({
                        type: 'weather',
                        severity: depMetar.visibility < 1 ? 'critical' : 'warning',
                        name: 'Low Visibility - Departure',
                        description: `${depStation.id}: ${depMetar.visibility} SM visibility`,
                        location: 0,
                        action: 'IFR procedures required'
                    });
                }
                if (depMetar.ceiling && depMetar.ceiling < 1000) {
                    routeData.hazards.push({
                        type: 'weather',
                        severity: depMetar.ceiling < 500 ? 'critical' : 'warning',
                        name: 'Low Ceiling - Departure',
                        description: `${depStation.id}: ${depMetar.ceiling} ft ceiling`,
                        location: 0,
                        action: 'Check alternate minimums'
                    });
                }
            }

            if (destMetar) {
                if (destMetar.visibility && destMetar.visibility < 3) {
                    routeData.hazards.push({
                        type: 'weather',
                        severity: destMetar.visibility < 1 ? 'critical' : 'warning',
                        name: 'Low Visibility - Destination',
                        description: `${destStation.id}: ${destMetar.visibility} SM visibility`,
                        location: distance,
                        action: 'File alternate airport'
                    });
                }
                if (destMetar.ceiling && destMetar.ceiling < 1000) {
                    routeData.hazards.push({
                        type: 'weather',
                        severity: destMetar.ceiling < 500 ? 'critical' : 'warning',
                        name: 'Low Ceiling - Destination',
                        description: `${destStation.id}: ${destMetar.ceiling} ft ceiling`,
                        location: distance,
                        action: 'Prepare for missed approach'
                    });
                }
            }

            // Add mid-route waypoint if long flight
            if (distance > 500) {
                const midLat = (depStation.lat + destStation.lat) / 2;
                const midLon = (depStation.lon + destStation.lon) / 2;
                routeData.waypoints.push({
                    name: 'MIDPT',
                    type: 'enroute',
                    lat: midLat,
                    lon: midLon,
                    distance: Math.round(distance / 2)
                });
            }

            // Add custom waypoints
            if (customWaypointsInput && customWaypointsInput.length > 0) {
                let cumulativeDist = 0;
                let lastPoint = { lat: depStation.lat, lon: depStation.lon };
                const R = 3440.065;

                customWaypointsInput.forEach((wp, idx) => {
                    // Calculate distance from last point
                    const lat1 = lastPoint.lat * Math.PI / 180;
                    const lat2 = wp.lat * Math.PI / 180;
                    const dLat = (wp.lat - lastPoint.lat) * Math.PI / 180;
                    const dLon = (wp.lon - lastPoint.lon) * Math.PI / 180;
                    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                              Math.cos(lat1) * Math.cos(lat2) *
                              Math.sin(dLon/2) * Math.sin(dLon/2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    cumulativeDist += R * c;

                    routeData.waypoints.push({
                        name: wp.name,
                        type: wp.isSnapped ? 'enroute-airport' : 'enroute',
                        lat: wp.lat,
                        lon: wp.lon,
                        distance: Math.round(cumulativeDist),
                        isCustom: true
                    });

                    lastPoint = { lat: wp.lat, lon: wp.lon };
                });
            }

            // Add destination
            routeData.waypoints.push({
                name: destStation.id,
                type: 'destination',
                lat: destStation.lat,
                lon: destStation.lon,
                distance: Math.round(distance)
            });

            // Sort waypoints by distance
            routeData.waypoints.sort((a, b) => a.distance - b.distance);

            // Add fuel stop warning if needed
            if (routeData.fuelPlan.fuelStopRequired) {
                routeData.hazards.push({
                    type: 'fuel',
                    severity: 'warning',
                    name: 'Fuel Stop Required',
                    description: `Total fuel required (${routeData.fuelPlan.total} gal) exceeds safe capacity`,
                    location: Math.round(distance * 0.6),
                    action: 'Plan intermediate fuel stop'
                });
            }

            return routeData;
        }

        // Update trip summary panel with route data
        function updateTripSummary(routeData) {
            // Calculate actual route distance including diversions
            let actualDistance = 0;
            const R = 3440.065; // Earth radius in nautical miles
            for (let i = 0; i < routeData.waypoints.length - 1; i++) {
                const wp1 = routeData.waypoints[i];
                const wp2 = routeData.waypoints[i + 1];
                const lat1 = wp1.lat * Math.PI / 180;
                const lat2 = wp2.lat * Math.PI / 180;
                const dLat = (wp2.lat - wp1.lat) * Math.PI / 180;
                const dLon = (wp2.lon - wp1.lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1) * Math.cos(lat2) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                actualDistance += R * c;
            }

            // Check if there are diversions
            const hasDiversions = routeData.avoidanceManeuvers && routeData.avoidanceManeuvers.length > 0;
            const diversionCount = routeData.waypoints.filter(wp => wp.type === 'divert').length;
            const directDistance = routeData.distance;
            const displayDistance = hasDiversions ? Math.round(actualDistance) : Math.round(directDistance);
            const extraDistance = hasDiversions ? Math.round(actualDistance - directDistance) : 0;

            // Recalculate time based on actual distance if there are diversions
            const cruiseSpeed = 450;
            const cruiseTime = displayDistance / cruiseSpeed;
            const adjustedTime = hasDiversions ? cruiseTime * 1.1 : routeData.estimatedTime; // Add 10% for diversions
            const hours = Math.floor(adjustedTime);
            const mins = Math.round((adjustedTime - hours) * 60);

            // Update mini display
            document.getElementById('tripMiniDistance').textContent = `${displayDistance} NM`;
            document.getElementById('tripMiniTime').textContent = `${hours}h ${mins}m`;

            // Update overview
            document.getElementById('tripDepAirport').textContent = routeData.departure.id;
            document.getElementById('tripDestAirport').textContent = routeData.destination.id;
            document.getElementById('tripDistance').textContent = hasDiversions
                ? `${displayDistance} NM (+${extraDistance})`
                : `${displayDistance} NM`;
            document.getElementById('tripTime').textContent = `${hours}:${mins.toString().padStart(2, '0')}`;
            document.getElementById('tripFuel').textContent = `${routeData.fuelPlan.total} gal`;
            document.getElementById('tripAltitude').textContent = `FL${Math.round(routeData.cruiseAltitude / 100)}`;

            // Update phases
            const phasesDiv = document.getElementById('tripPhases');
            phasesDiv.innerHTML = routeData.phases.map(phase => `
                <div class="trip-phase">
                    <div class="trip-phase-icon ${phase.type}">
                        ${phase.type === 'climb' ? '' : phase.type === 'descent' ? '' : ''}
                    </div>
                    <div class="trip-phase-info">
                        <div class="trip-phase-name">${phase.name}</div>
                        <div class="trip-phase-details">${phase.startAlt.toLocaleString()}  ${phase.endAlt.toLocaleString()} ft  ${phase.time} min</div>
                    </div>
                    <div class="trip-phase-distance">${phase.distance} NM</div>
                </div>
            `).join('');

            // Update hazards
            const hazardsDiv = document.getElementById('tripHazards');
            if (routeData.hazards.length === 0) {
                hazardsDiv.innerHTML = '<div class="no-hazards">No significant hazards detected</div>';
            } else {
                hazardsDiv.innerHTML = routeData.hazards.map(hazard => `
                    <div class="trip-hazard ${hazard.severity}">
                        <div class="trip-hazard-icon">
                            ${hazard.type === 'restricted' ? '' :
                              hazard.type === 'prohibited' ? '' :
                              hazard.type === 'turbulence' ? '' :
                              hazard.type === 'icing' ? '' :
                              hazard.type === 'weather' ? '' :
                              hazard.type === 'fuel' ? '' : ''}
                        </div>
                        <div class="trip-hazard-content">
                            <div class="trip-hazard-title">${hazard.name}</div>
                            <div class="trip-hazard-desc">${hazard.description}</div>
                            <div class="trip-hazard-action"> ${hazard.action}</div>
                        </div>
                    </div>
                `).join('');
            }

            // Update waypoints
            const waypointsDiv = document.getElementById('tripWaypoints');
            waypointsDiv.innerHTML = routeData.waypoints.map(wp => `
                <div class="trip-waypoint">
                    <div class="trip-waypoint-marker ${wp.type}"></div>
                    <div class="trip-waypoint-info">
                        <div class="trip-waypoint-name">${wp.name}</div>
                        <div class="trip-waypoint-coords">${wp.lat.toFixed(2)}, ${wp.lon.toFixed(2)}${wp.reason ? ' - ' + wp.reason : ''}</div>
                    </div>
                    <div class="trip-waypoint-distance">${wp.distance} NM</div>
                </div>
            `).join('');

            // Update fuel plan
            const fuelDiv = document.getElementById('tripFuelPlan');
            fuelDiv.innerHTML = `
                <div class="fuel-item">
                    <span class="fuel-item-label">Climb</span>
                    <span class="fuel-item-value">${routeData.fuelPlan.climb} gal</span>
                </div>
                <div class="fuel-item">
                    <span class="fuel-item-label">Cruise</span>
                    <span class="fuel-item-value">${routeData.fuelPlan.cruise} gal</span>
                </div>
                <div class="fuel-item">
                    <span class="fuel-item-label">Descent</span>
                    <span class="fuel-item-value">${routeData.fuelPlan.descent} gal</span>
                </div>
                <div class="fuel-item">
                    <span class="fuel-item-label">Reserve (45 min)</span>
                    <span class="fuel-item-value">${routeData.fuelPlan.reserve} gal</span>
                </div>
                <div class="fuel-item">
                    <span class="fuel-item-label">Total Required</span>
                    <span class="fuel-item-value ${routeData.fuelPlan.fuelStopRequired ? 'warning' : 'ok'}">${routeData.fuelPlan.total} gal</span>
                </div>
            `;

            // Show the panel
            showTripSummary();
        }

        // Point in polygon helper
        function pointInPolygon(lat, lon, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];
                if (((yi > lon) !== (yj > lon)) && (lat < (xj - xi) * (lon - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }


        // Route profile
        let routeLine = null;
        let routeSegments = [];
        let fuelStopMarkers = L.layerGroup().addTo(map);

        // ============================================
        // CUSTOM WAYPOINT DRAWING FUNCTIONS
        // ============================================

        function toggleWaypointMode() {
            const btn = document.getElementById('waypointModeBtn');
            const snapBtn = document.getElementById('snapModeBtn');
            const mapContainer = document.getElementById('map');

            // Check if route is loaded first
            if (!waypointMode && (!currentRoute.dep || !currentRoute.dest)) {
                alert('Please load a route first (enter FROM/TO airports and click Load Route)');
                return;
            }

            waypointMode = !waypointMode;

            if (waypointMode) {
                btn.classList.add('active');
                btn.textContent = 'Done';
                snapBtn.style.display = 'inline-block';
                mapContainer.classList.add('waypoint-mode');
                map.on('click', onMapClickWaypoint);
            } else {
                btn.classList.remove('active');
                btn.textContent = '+ Waypoints';
                snapBtn.style.display = 'none';
                mapContainer.classList.remove('waypoint-mode');
                map.off('click', onMapClickWaypoint);

                // Rebuild route with custom waypoints if any were added
                if (customWaypoints.length > 0) {
                    rebuildRouteWithWaypoints();
                }
            }
        }

        function toggleSnapMode() {
            const btn = document.getElementById('snapModeBtn');
            snapMode = !snapMode;

            if (snapMode) {
                btn.classList.add('active');
                btn.textContent = 'Snap: ON';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Snap: OFF';
            }
        }

        function onMapClickWaypoint(e) {
            let waypointLat = e.latlng.lat;
            let waypointLon = e.latlng.lng;
            let waypointName = `WPT${++waypointCounter}`;
            let isSnapped = false;

            // If snap mode is on, find nearest GA airport
            if (snapMode) {
                const nearestAirport = findNearestGAAirport(waypointLat, waypointLon);
                if (nearestAirport) {
                    waypointLat = nearestAirport.lat;
                    waypointLon = nearestAirport.lon;
                    waypointName = nearestAirport.id;
                    isSnapped = true;
                }
            }

            // Create waypoint object
            const waypoint = {
                name: waypointName,
                lat: waypointLat,
                lon: waypointLon,
                isSnapped: isSnapped,
                index: customWaypoints.length + 1
            };

            // Add to array
            customWaypoints.push(waypoint);

            // Create marker
            const markerIcon = L.divIcon({
                html: `<div class="custom-waypoint-marker ${isSnapped ? 'snapped' : ''}">${waypoint.index}</div>`,
                className: 'custom-waypoint-icon',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });

            const marker = L.marker([waypointLat, waypointLon], {
                icon: markerIcon,
                draggable: false
            }).addTo(map);

            // Add tooltip
            marker.bindTooltip(`${waypointName}<br>${waypointLat.toFixed(3)}, ${waypointLon.toFixed(3)}`, {
                direction: 'top',
                className: 'waypoint-tooltip'
            });

            // Click to remove waypoint
            marker.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
                removeWaypoint(waypoint, marker);
            });

            waypointMarkers.push({ waypoint, marker });

            // Update preview line
            updateWaypointPreviewLine();
        }

        function findNearestGAAirport(lat, lon) {
            let nearest = null;
            let nearestDist = Infinity;
            const maxDist = 0.75; // ~50nm threshold

            metarStations.forEach(station => {
                const dist = Math.sqrt(
                    Math.pow(station.lat - lat, 2) +
                    Math.pow(station.lon - lon, 2)
                );
                if (dist < nearestDist && dist < maxDist) {
                    nearestDist = dist;
                    nearest = station;
                }
            });

            return nearest;
        }

        function removeWaypoint(waypoint, marker) {
            // Remove from array
            const idx = customWaypoints.findIndex(w => w.name === waypoint.name && w.index === waypoint.index);
            if (idx > -1) {
                customWaypoints.splice(idx, 1);
            }

            // Remove marker
            map.removeLayer(marker);
            waypointMarkers = waypointMarkers.filter(m => m.waypoint !== waypoint);

            // Re-index remaining waypoints
            customWaypoints.forEach((wp, i) => {
                wp.index = i + 1;
            });

            // Update markers with new indices
            waypointMarkers.forEach((m, i) => {
                const newIcon = L.divIcon({
                    html: `<div class="custom-waypoint-marker ${m.waypoint.isSnapped ? 'snapped' : ''}">${i + 1}</div>`,
                    className: 'custom-waypoint-icon',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                m.marker.setIcon(newIcon);
                m.waypoint.index = i + 1;
            });

            // Update preview line
            updateWaypointPreviewLine();
        }

        function clearCustomWaypoints() {
            // Remove all markers
            waypointMarkers.forEach(m => map.removeLayer(m.marker));
            waypointMarkers = [];
            customWaypoints = [];
            waypointCounter = 0;

            // Remove preview line
            if (waypointPreviewLine) {
                map.removeLayer(waypointPreviewLine);
                waypointPreviewLine = null;
            }
        }

        function updateWaypointPreviewLine() {
            // Remove existing preview
            if (waypointPreviewLine) {
                map.removeLayer(waypointPreviewLine);
            }

            if (!currentRoute.dep || !currentRoute.dest) return;

            // Build coordinate array: dep -> waypoints -> dest
            const coords = [
                [currentRoute.dep.lat, currentRoute.dep.lon],
                ...customWaypoints.map(wp => [wp.lat, wp.lon]),
                [currentRoute.dest.lat, currentRoute.dest.lon]
            ];

            // Draw dashed preview line
            waypointPreviewLine = L.polyline(coords, {
                color: '#ffffff',
                weight: 2,
                opacity: 0.6,
                dashArray: '8, 8',
                className: 'waypoint-preview-line'
            }).addTo(map);

            // Bring waypoint markers to front
            waypointMarkers.forEach(m => m.marker.bringToFront());
        }

        function rebuildRouteWithWaypoints() {
            if (!currentRoute.dep || !currentRoute.dest) return;

            // Sort waypoints by distance from departure
            const depLat = currentRoute.dep.lat;
            const depLon = currentRoute.dep.lon;

            customWaypoints.sort((a, b) => {
                const distA = Math.sqrt(Math.pow(a.lat - depLat, 2) + Math.pow(a.lon - depLon, 2));
                const distB = Math.sqrt(Math.pow(b.lat - depLat, 2) + Math.pow(b.lon - depLon, 2));
                return distA - distB;
            });

            // Calculate total distance through all waypoints
            let totalDistance = 0;
            const R = 3440.065; // Earth radius in NM

            const allPoints = [
                currentRoute.dep,
                ...customWaypoints.map(wp => ({ lat: wp.lat, lon: wp.lon, name: wp.name })),
                currentRoute.dest
            ];

            for (let i = 0; i < allPoints.length - 1; i++) {
                const p1 = allPoints[i];
                const p2 = allPoints[i + 1];
                const lat1 = p1.lat * Math.PI / 180;
                const lat2 = p2.lat * Math.PI / 180;
                const dLat = (p2.lat - p1.lat) * Math.PI / 180;
                const dLon = (p2.lon - p1.lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1) * Math.cos(lat2) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                totalDistance += R * c;
            }

            // Redraw with custom waypoints
            drawProfile(currentRoute.dep, currentRoute.dest);

            // Calculate enhanced route with custom waypoints
            const routeData = calculateEnhancedRoute(currentRoute.dep, currentRoute.dest, totalDistance, customWaypoints);

            // Update displays
            updateTripSummary(routeData);
            drawEnhancedRoute(routeData, currentRoute.dep, currentRoute.dest, totalDistance, customWaypoints);

            // Remove preview line since actual route is now drawn
            if (waypointPreviewLine) {
                map.removeLayer(waypointPreviewLine);
                waypointPreviewLine = null;
            }
        }

        // ============================================
        // END WAYPOINT FUNCTIONS
        // ============================================

        async function loadRoute() {
            const departure = document.getElementById('departure').value.toUpperCase();
            const destination = document.getElementById('destination').value.toUpperCase();

            if (!departure || !destination) return;

            // Clear any custom waypoints from previous route
            clearCustomWaypoints();

            // Reset waypoint mode UI if active
            if (waypointMode) {
                waypointMode = false;
                const btn = document.getElementById('waypointModeBtn');
                const snapBtn = document.getElementById('snapModeBtn');
                btn.classList.remove('active');
                btn.textContent = '+ Waypoints';
                snapBtn.style.display = 'none';
                document.getElementById('map').classList.remove('waypoint-mode');
                map.off('click', onMapClickWaypoint);
            }

            // Find station coordinates
            const depStation = metarStations.find(s => s.id === departure || s.id === 'K' + departure);
            const destStation = metarStations.find(s => s.id === destination || s.id === 'K' + destination);

            if (!depStation || !destStation) {
                alert('Station not found. Try major airports like JFK, LAX, ORD, etc.');
                return;
            }

            // Store current route and draw profile
            currentRoute.dep = depStation;
            currentRoute.dest = destStation;
            drawProfile(depStation, destStation);

            // Refresh terrain overlay if active (now route-aware)
            if (overlayState.terrain) {
                createTerrainOverlay();
            }

            // Calculate distance for trip summary
            const R = 3440.065; // Earth radius in nautical miles
            const dLat = (destStation.lat - depStation.lat) * Math.PI / 180;
            const dLon = (destStation.lon - depStation.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(depStation.lat * Math.PI / 180) * Math.cos(destStation.lat * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const distance = R * c;

            // Calculate enhanced route and update trip summary
            const routeData = calculateEnhancedRoute(depStation, destStation, distance);
            updateTripSummary(routeData);

            // Draw the enhanced route on map
            drawEnhancedRoute(routeData, depStation, destStation, distance);
        }

        // Draw enhanced route with high-resolution line and optional fuel stops
        function drawEnhancedRoute(routeData, depStation, destStation, distance, customWaypointsInput = []) {
            // Clear existing route elements
            if (routeLine) {
                map.removeLayer(routeLine);
            }
            routeSegments.forEach(seg => map.removeLayer(seg));
            routeSegments = [];
            fuelStopMarkers.clearLayers();

            // Bring custom waypoint markers to front after clearing
            if (waypointMarkers && waypointMarkers.length > 0) {
                setTimeout(() => {
                    waypointMarkers.forEach(m => m.marker.bringToFront());
                }, 100);
            }

            const waypoints = routeData.waypoints;
            if (!waypoints || waypoints.length < 2) return;

            // Generate high-resolution route coordinates through waypoints
            const highResCoords = [];
            const segmentInfo = []; // Store info for each segment

            for (let i = 0; i < waypoints.length - 1; i++) {
                const wp1 = waypoints[i];
                const wp2 = waypoints[i + 1];

                // Calculate segment distance
                const segDist = Math.sqrt(
                    Math.pow(wp2.lat - wp1.lat, 2) + Math.pow(wp2.lon - wp1.lon, 2)
                );

                // More points for longer segments (high resolution)
                const numPoints = Math.max(20, Math.floor(segDist * 50));

                for (let j = 0; j <= numPoints; j++) {
                    const t = j / numPoints;
                    const lat = wp1.lat + t * (wp2.lat - wp1.lat);
                    const lon = wp1.lon + t * (wp2.lon - wp1.lon);
                    highResCoords.push([lat, lon]);

                    // Store segment info for hover
                    const progressAlongRoute = (wp1.distance + t * (wp2.distance - wp1.distance)) / distance;
                    segmentInfo.push({
                        lat, lon,
                        distance: Math.round(wp1.distance + t * (wp2.distance - wp1.distance)),
                        fromWaypoint: wp1.name,
                        toWaypoint: wp2.name,
                        progress: progressAlongRoute
                    });
                }
            }

            // Determine flight phase colors for the route
            const climbEnd = 0.15;
            const descentStart = 0.85;

            // Draw route as colored segments by phase
            let currentPhase = 'climb';
            let segmentCoords = [];
            let lastPhase = 'climb';

            highResCoords.forEach((coord, idx) => {
                const progress = idx / highResCoords.length;

                // Determine current phase
                if (progress < climbEnd) {
                    currentPhase = 'climb';
                } else if (progress > descentStart) {
                    currentPhase = 'descent';
                } else {
                    currentPhase = 'cruise';
                }

                segmentCoords.push(coord);

                // When phase changes or at end, draw segment
                if (currentPhase !== lastPhase || idx === highResCoords.length - 1) {
                    const phaseColor = lastPhase === 'climb' ? '#22c55e' :
                                      lastPhase === 'descent' ? '#f59e0b' : '#6366f1';

                    const segment = L.polyline(segmentCoords, {
                        color: phaseColor,
                        weight: 4,
                        opacity: 0.9,
                        lineCap: 'round',
                        lineJoin: 'round'
                    }).addTo(map);

                    routeSegments.push(segment);
                    segmentCoords = [coord]; // Start new segment with current point
                    lastPhase = currentPhase;
                }
            });

            // Fit map to route
            const bounds = L.latLngBounds(highResCoords);
            map.fitBounds(bounds, { padding: [50, 50] });

            // Add diversion waypoint markers for restricted airspace avoidance
            const diversionWaypoints = waypoints.filter(wp => wp.type === 'divert');
            diversionWaypoints.forEach((wp, idx) => {
                const diversionIcon = L.divIcon({
                    html: `<div style="
                        background: rgba(239, 68, 68, 0.9);
                        color: white;
                        width: 20px;
                        height: 20px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 9px;
                        font-weight: bold;
                        border: 2px solid #fca5a5;
                        box-shadow: 0 2px 6px rgba(239, 68, 68, 0.5);
                    ">D${idx + 1}</div>`,
                    className: 'diversion-marker',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });

                const marker = L.marker([wp.lat, wp.lon], { icon: diversionIcon }).addTo(map);
                marker.bindTooltip(`
                    <div style="font-family: system-ui; font-size: 11px;">
                        <div style="font-weight: 600; color: #ef4444; margin-bottom: 4px;">
                            Diversion Waypoint
                        </div>
                        <div><b>${wp.name}</b></div>
                        <div style="font-size: 10px; color: #9ca3af; margin-top: 2px;">${wp.reason || 'Airspace avoidance'}</div>
                    </div>
                `, { direction: 'top', offset: [0, -10] });
                fuelStopMarkers.addLayer(marker); // Reuse fuel stop layer for cleanup
            });

            // Add optional fuel stop markers (only if fuel stop required)
            if (routeData.fuelPlan.fuelStopRequired) {
                // Find potential fuel stop location (around 60% of route)
                const fuelStopProgress = 0.6;
                const fuelStopLat = depStation.lat + fuelStopProgress * (destStation.lat - depStation.lat);
                const fuelStopLon = depStation.lon + fuelStopProgress * (destStation.lon - depStation.lon);

                // Find nearest airport to this location
                let nearestAirport = null;
                let nearestDist = Infinity;
                metarStations.forEach(station => {
                    const dist = Math.sqrt(
                        Math.pow(station.lat - fuelStopLat, 2) +
                        Math.pow(station.lon - fuelStopLon, 2)
                    );
                    if (dist < nearestDist && dist < 2) { // Within ~2 degrees
                        nearestDist = dist;
                        nearestAirport = station;
                    }
                });

                if (nearestAirport) {
                    const fuelIcon = L.divIcon({
                        html: `<div style="
                            background: rgba(59, 130, 246, 0.9);
                            color: white;
                            width: 20px;
                            height: 20px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 10px;
                            border: 2px solid white;
                            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
                            cursor: pointer;
                        ">F</div>`,
                        className: 'fuel-stop-marker',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });

                    const fuelMarker = L.marker([nearestAirport.lat, nearestAirport.lon], { icon: fuelIcon });
                    fuelMarker.bindTooltip(`
                        <div style="font-family: system-ui; font-size: 11px;">
                            <div style="font-weight: 600; color: #3b82f6; margin-bottom: 4px;">
                                Optional Fuel Stop
                            </div>
                            <div><b>Airport:</b> ${nearestAirport.id}</div>
                            <div><b>${nearestAirport.name}</b></div>
                            <div style="font-size: 10px; color: #f59e0b; margin-top: 4px;">
                                 Recommended for this route
                            </div>
                        </div>
                    `, { sticky: true });
                    fuelStopMarkers.addLayer(fuelMarker);
                }
            }

            // Setup journey marker hover for the route
            setupRouteHover(routeData, highResCoords, segmentInfo);
        }

        // Helper: Find nearest point index in coords array
        function findNearestPointIndex(latlng, coords) {
            let nearestIdx = 0;
            let nearestDist = Infinity;
            coords.forEach((coord, idx) => {
                const dist = Math.sqrt(
                    Math.pow(coord[0] - latlng.lat, 2) +
                    Math.pow(coord[1] - latlng.lng, 2)
                );
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestIdx = idx;
                }
            });
            return nearestIdx;
        }

        // Helper: Get altitude at route progress
        function getAltitudeAtProgress(progress, cruiseAlt) {
            if (progress < 0.15) {
                return (progress / 0.15) * cruiseAlt;
            } else if (progress > 0.85) {
                return ((1 - progress) / 0.15) * cruiseAlt;
            }
            return cruiseAlt;
        }

        // Journey marker for map (follows cursor along route)
        let mapJourneyMarker = null;
        let mapJourneyTooltip = null;
        let currentRouteData = null;
        let currentHighResCoords = null;
        let currentSegmentInfo = null;

        function initMapJourneyMarker(phaseColor, pulseColor) {
            // Create the journey marker dot with phase-appropriate colors
            const markerIcon = L.divIcon({
                html: `<div class="map-journey-dot">
                    <div class="map-journey-dot-inner" style="border-color: ${phaseColor}"></div>
                    <div class="map-journey-dot-pulse" style="background: ${pulseColor}"></div>
                </div>`,
                className: 'map-journey-marker',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            mapJourneyMarker = L.marker([0, 0], {
                icon: markerIcon,
                interactive: false,
                zIndexOffset: 1000
            });
        }

        // Update journey marker on route hover
        function updateMapJourneyMarker(latlng, routeData, highResCoords, segmentInfo) {
            // Find nearest point on route
            const nearestIdx = findNearestPointIndex(latlng, highResCoords);
            const nearestCoord = highResCoords[nearestIdx];
            const info = segmentInfo[nearestIdx];

            if (!info) return;

            // Check if cursor is close enough to route (within ~0.5 degrees)
            const distToRoute = Math.sqrt(
                Math.pow(nearestCoord[0] - latlng.lat, 2) +
                Math.pow(nearestCoord[1] - latlng.lng, 2)
            );

            if (distToRoute > 0.5) {
                hideMapJourneyMarker();
                return;
            }

            // Calculate flight info
            const altitude = getAltitudeAtProgress(info.progress, routeData.cruiseAltitude);
            const phase = info.progress < 0.15 ? 'Climb' :
                         info.progress > 0.85 ? 'Descent' : 'Cruise';
            const phaseColor = phase === 'Climb' ? '#22c55e' :
                              phase === 'Descent' ? '#f59e0b' : '#6366f1';
            const pulseColor = phase === 'Climb' ? 'rgba(34, 197, 94, 0.4)' :
                              phase === 'Descent' ? 'rgba(245, 158, 11, 0.4)' : 'rgba(99, 102, 241, 0.4)';

            // Create or update marker with phase-appropriate color
            if (!mapJourneyMarker) {
                initMapJourneyMarker(phaseColor, pulseColor);
            } else {
                // Update marker icon with new color
                const markerIcon = L.divIcon({
                    html: `<div class="map-journey-dot">
                        <div class="map-journey-dot-inner" style="border-color: ${phaseColor}"></div>
                        <div class="map-journey-dot-pulse" style="background: ${pulseColor}"></div>
                    </div>`,
                    className: 'map-journey-marker',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                mapJourneyMarker.setIcon(markerIcon);
            }

            // Position marker at nearest route point
            mapJourneyMarker.setLatLng(nearestCoord);
            if (!map.hasLayer(mapJourneyMarker)) {
                mapJourneyMarker.addTo(map);
            }

            // Update or create tooltip
            const tooltipContent = `
                <div class="map-journey-tooltip">
                    <div class="mjt-header" style="color: ${phaseColor}">${phase}</div>
                    <div class="mjt-stats">
                        <div class="mjt-stat">
                            <span class="mjt-label">Alt</span>
                            <span class="mjt-value">FL${Math.round(altitude / 100)}</span>
                        </div>
                        <div class="mjt-stat">
                            <span class="mjt-label">Dist</span>
                            <span class="mjt-value">${info.distance} NM</span>
                        </div>
                    </div>
                </div>
            `;

            if (mapJourneyMarker.getTooltip()) {
                mapJourneyMarker.setTooltipContent(tooltipContent);
            } else {
                mapJourneyMarker.bindTooltip(tooltipContent, {
                    permanent: true,
                    direction: 'top',
                    offset: [0, -15],
                    className: 'map-journey-tooltip-container'
                });
            }
        }

        function hideMapJourneyMarker() {
            if (mapJourneyMarker && map.hasLayer(mapJourneyMarker)) {
                map.removeLayer(mapJourneyMarker);
            }
        }

        // Enhanced route drawing with journey marker support
        function setupRouteHover(routeData, highResCoords, segmentInfo) {
            currentRouteData = routeData;
            currentHighResCoords = highResCoords;
            currentSegmentInfo = segmentInfo;

            // Add mousemove handler to map for journey marker
            map.off('mousemove', onMapMouseMove);
            map.on('mousemove', onMapMouseMove);

            map.off('mouseout', onMapMouseOut);
            map.on('mouseout', onMapMouseOut);
        }

        function onMapMouseMove(e) {
            if (currentRouteData && currentHighResCoords && currentSegmentInfo) {
                updateMapJourneyMarker(e.latlng, currentRouteData, currentHighResCoords, currentSegmentInfo);
            }
        }

        function onMapMouseOut() {
            hideMapJourneyMarker();
        }

        // ==================== FLIGHT PATH OPTIMIZER ====================
        // Hazard data for flight path optimization (accessible globally)
        const flightHazards = {
            icingZones: [
                { name: 'Northern Plains', polygon: [[46.5, -98.0], [47.2, -95.5], [46.8, -92.0], [44.5, -90.5], [42.5, -91.0], [41.8, -94.0], [42.2, -97.5], [44.0, -99.0]], intensity: 'Moderate', base: 8000, top: 22000 },
                { name: 'Northeast', polygon: [[44.5, -76.0], [45.0, -73.5], [43.8, -71.0], [41.5, -72.0], [40.0, -74.5], [40.5, -77.0], [42.0, -78.5]], intensity: 'Light', base: 10000, top: 18000 },
                { name: 'Pacific Northwest', polygon: [[49.0, -122.5], [48.5, -119.0], [46.5, -117.5], [44.5, -118.5], [44.0, -121.0], [45.5, -123.5], [47.5, -124.0]], intensity: 'Light-Moderate', base: 6000, top: 20000 },
                { name: 'Great Lakes', polygon: [[45.5, -86.0], [46.0, -83.5], [45.0, -81.0], [43.0, -80.5], [41.5, -82.5], [41.0, -85.0], [42.5, -87.5], [44.5, -87.0]], intensity: 'Moderate', base: 4000, top: 16000 },
                { name: 'Rocky Mountains', polygon: [[42.5, -108.5], [43.0, -105.5], [41.5, -103.5], [39.0, -104.0], [37.5, -105.5], [37.0, -108.0], [38.5, -109.5], [41.0, -109.0]], intensity: 'Light', base: 12000, top: 24000 },
            ],
            turbulenceZones: [
                { name: 'Rocky Mountain Wave', polygon: [[41.0, -107.5], [41.5, -104.5], [40.0, -102.5], [37.5, -103.0], [36.0, -105.0], [36.5, -108.0], [38.5, -108.5]], intensity: 'Moderate-Severe', base: 15000, top: 45000 },
                { name: 'Sierra Nevada', polygon: [[38.5, -120.5], [39.0, -118.0], [37.5, -116.0], [35.0, -116.5], [34.0, -118.0], [35.0, -120.0], [37.0, -121.0]], intensity: 'Moderate', base: 18000, top: 40000 },
                { name: 'Appalachian Ridges', polygon: [[38.0, -82.0], [37.5, -79.5], [35.5, -80.0], [33.5, -82.5], [32.5, -85.0], [34.0, -86.5], [36.5, -85.5]], intensity: 'Light-Moderate', base: 8000, top: 25000 },
                { name: 'Great Plains Jet', polygon: [[41.0, -101.0], [41.5, -96.0], [39.5, -93.5], [36.5, -94.5], [35.0, -97.5], [36.0, -101.5], [38.5, -102.5]], intensity: 'Light-Moderate', base: 30000, top: 42000 },
                { name: 'Gulf Coast Convective', polygon: [[32.0, -93.0], [32.5, -89.0], [31.0, -86.5], [29.0, -87.0], [28.0, -90.0], [29.0, -93.5], [31.0, -94.0]], intensity: 'Moderate', base: 10000, top: 35000 },
            ],
            restrictedAreas: [
                { name: 'R-2508 Complex', polygon: [[36.5, -118.5], [36.5, -116.5], [35.0, -116.5], [35.0, -117.5], [34.5, -117.5], [34.5, -118.5]], floor: 0, ceiling: 99999 },
                { name: 'R-4807 (Nellis Range)', polygon: [[38.0, -116.5], [38.0, -115.0], [36.5, -115.0], [36.5, -116.5]], floor: 0, ceiling: 99999 },
                { name: 'R-4809 (Nellis South)', polygon: [[36.5, -116.0], [36.5, -115.0], [35.5, -115.0], [35.5, -116.0]], floor: 0, ceiling: 50000 },
                { name: 'P-56A (White House)', polygon: [[38.905, -77.045], [38.905, -77.028], [38.890, -77.028], [38.890, -77.045]], floor: 0, ceiling: 18000 },
                { name: 'P-56B (Naval Observatory)', polygon: [[38.930, -77.075], [38.930, -77.058], [38.915, -77.058], [38.915, -77.075]], floor: 0, ceiling: 18000 },
            ]
        };

        // Point-in-polygon test using ray casting algorithm
        function pointInPolygon(lat, lon, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];
                if (((yi > lon) !== (yj > lon)) && (lat < (xj - xi) * (lon - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Calculate optimal flight path considering all hazards
        function calculateOptimalFlightPath(depStation, destStation, distance, terrainProfile) {
            const numSamples = 50; // Number of waypoints along route
            const altitudeOptions = []; // Available altitudes to evaluate
            for (let alt = 5000; alt <= 45000; alt += 1000) {
                altitudeOptions.push(alt);
            }

            // Preferred cruise altitude range (most fuel efficient)
            const optimalCruiseMin = 30000;
            const optimalCruiseMax = 38000;

            // Sample points along the route
            const waypoints = [];
            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples;
                const lat = depStation.lat + t * (destStation.lat - depStation.lat);
                const lon = depStation.lon + t * (destStation.lon - depStation.lon);
                const distNM = t * distance;

                // Get terrain elevation at this point (from profile)
                const terrainIdx = Math.floor(t * (terrainProfile.length - 1));
                const terrainAlt = terrainProfile[terrainIdx] || 0;
                const minSafeAlt = Math.max(terrainAlt + 2000, 5000); // 2000ft AGL minimum

                // Evaluate each altitude option
                let bestAlt = optimalCruiseMin;
                let bestCost = Infinity;

                for (const alt of altitudeOptions) {
                    if (alt < minSafeAlt) continue; // Skip altitudes below terrain

                    let cost = 0;

                    // Base cost - prefer optimal cruise range
                    if (alt >= optimalCruiseMin && alt <= optimalCruiseMax) {
                        cost += 0; // Optimal range
                    } else if (alt < optimalCruiseMin) {
                        cost += (optimalCruiseMin - alt) / 1000 * 5; // Penalty for flying too low
                    } else {
                        cost += (alt - optimalCruiseMax) / 1000 * 3; // Smaller penalty for too high
                    }

                    // Check turbulence zones
                    for (const zone of flightHazards.turbulenceZones) {
                        if (pointInPolygon(lat, lon, zone.polygon) && alt >= zone.base && alt <= zone.top) {
                            if (zone.intensity.includes('Severe')) {
                                cost += 100; // Severe turbulence - heavy penalty
                            } else if (zone.intensity.includes('Moderate')) {
                                cost += 50; // Moderate turbulence
                            } else {
                                cost += 20; // Light turbulence
                            }
                        }
                    }

                    // Check icing zones
                    for (const zone of flightHazards.icingZones) {
                        if (pointInPolygon(lat, lon, zone.polygon) && alt >= zone.base && alt <= zone.top) {
                            if (zone.intensity.includes('Moderate')) {
                                cost += 40;
                            } else {
                                cost += 15;
                            }
                        }
                    }

                    // Check restricted/prohibited airspace
                    for (const zone of flightHazards.restrictedAreas) {
                        if (pointInPolygon(lat, lon, zone.polygon) && alt >= zone.floor && alt <= zone.ceiling) {
                            cost += 500; // Very high penalty - avoid at all costs
                        }
                    }

                    // Altitude change penalty (smoother is better)
                    if (waypoints.length > 0) {
                        const prevAlt = waypoints[waypoints.length - 1].altitude;
                        const altChange = Math.abs(alt - prevAlt);
                        cost += altChange / 1000 * 2; // Penalty for altitude changes
                    }

                    if (cost < bestCost) {
                        bestCost = cost;
                        bestAlt = alt;
                    }
                }

                waypoints.push({
                    t,
                    lat,
                    lon,
                    distNM,
                    altitude: bestAlt,
                    terrainAlt,
                    cost: bestCost
                });
            }

            // Smooth the altitude profile to avoid jagged changes
            const smoothedWaypoints = smoothAltitudeProfile(waypoints);

            // Add climb and descent phases
            return addClimbDescentPhases(smoothedWaypoints, distance);
        }

        // Smooth altitude profile using weighted moving average
        function smoothAltitudeProfile(waypoints) {
            const smoothed = [...waypoints];
            const windowSize = 5;

            for (let i = windowSize; i < waypoints.length - windowSize; i++) {
                let sum = 0;
                let weight = 0;
                for (let j = -windowSize; j <= windowSize; j++) {
                    const w = windowSize - Math.abs(j) + 1;
                    sum += waypoints[i + j].altitude * w;
                    weight += w;
                }
                smoothed[i] = { ...waypoints[i], altitude: Math.round(sum / weight / 1000) * 1000 };
            }

            return smoothed;
        }

        // Add realistic climb and descent phases
        function addClimbDescentPhases(waypoints, distance) {
            if (waypoints.length === 0) return waypoints;

            // Climb rate: ~2000 ft/min at ~250 kts = ~8 NM per 1000ft
            // Descent rate: ~1500 ft/min at ~300 kts = ~12 NM per 1000ft
            const climbRateNMPerFt = 8 / 1000;
            const descentRateNMPerFt = 12 / 1000;

            // Find target cruise altitude (most common altitude in middle section)
            const middleStart = Math.floor(waypoints.length * 0.2);
            const middleEnd = Math.floor(waypoints.length * 0.8);
            const cruiseAlt = waypoints.slice(middleStart, middleEnd)
                .reduce((sum, wp) => sum + wp.altitude, 0) / (middleEnd - middleStart);

            // Calculate climb and descent distances
            const climbDist = cruiseAlt * climbRateNMPerFt;
            const descentDist = cruiseAlt * descentRateNMPerFt;

            // Apply climb phase
            for (const wp of waypoints) {
                if (wp.distNM < climbDist) {
                    // Climbing phase - linear climb from 0 to cruise
                    const climbProgress = wp.distNM / climbDist;
                    wp.altitude = Math.round(climbProgress * cruiseAlt / 1000) * 1000;
                    wp.phase = 'climb';
                } else if (wp.distNM > distance - descentDist) {
                    // Descent phase - linear descent from cruise to 0
                    const descentProgress = (distance - wp.distNM) / descentDist;
                    wp.altitude = Math.round(descentProgress * cruiseAlt / 1000) * 1000;
                    wp.phase = 'descent';
                } else {
                    wp.phase = 'cruise';
                }
            }

            return waypoints;
        }

        function drawProfile(depStation, destStation) {
            document.getElementById('profilePlaceholder').style.display = 'none';
            document.getElementById('profileContainer').style.display = 'block';

            const canvas = document.getElementById('profileCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.parentElement.offsetWidth;
            canvas.height = canvas.parentElement.offsetHeight;

            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            const paddingBottom = 80; // Extra space for distance labels and 0ft baseline

            // Clear canvas
            ctx.fillStyle = '#12121a';
            ctx.fillRect(0, 0, width, height);

            // Get METAR data for both stations
            const depMetar = metarData[depStation.id] || {};
            const destMetar = metarData[destStation.id] || {};

            // Calculate distance (rough approximation)
            const R = 3440.065; // Earth radius in nautical miles
            const lat1 = depStation.lat * Math.PI / 180;
            const lat2 = destStation.lat * Math.PI / 180;
            const dLat = (destStation.lat - depStation.lat) * Math.PI / 180;
            const dLon = (destStation.lon - depStation.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1) * Math.cos(lat2) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const distance = R * c;

            // Dynamic unit calculation based on zoom level AND available space
            const zoom = profileView.zoom;

            // Calculate available pixel space for labels
            const availableHeight = (height - padding - paddingBottom) * zoom;
            const availableWidth = (width - 2 * padding) * zoom;

            // Minimum pixel spacing between labels to prevent overlap
            const minAltLabelSpacing = 25; // pixels between altitude labels
            const minDistLabelSpacing = 45; // pixels between distance labels

            // Calculate max number of labels that fit
            const maxAltLabels = Math.floor(availableHeight / minAltLabelSpacing);
            const maxDistLabels = Math.floor(availableWidth / minDistLabelSpacing);

            // Available step sizes (must divide evenly into sensible intervals)
            const altStepOptions = [1000, 2000, 5000, 10000, 20000];
            const distStepOptions = [5, 10, 25, 50, 100];

            // Find the smallest step that doesn't create too many labels
            let altStep = altStepOptions[altStepOptions.length - 1];
            for (const step of altStepOptions) {
                if (40000 / step <= maxAltLabels) {
                    altStep = step;
                    break;
                }
            }

            let distStep = distStepOptions[distStepOptions.length - 1];
            for (const step of distStepOptions) {
                if (distance / step <= maxDistLabels) {
                    distStep = step;
                    break;
                }
            }

            // Apply zoom and pan transform with clipping for content area
            ctx.save();

            // Clip to the profile content area (inside padding)
            ctx.beginPath();
            ctx.rect(padding, padding, width - 2 * padding, height - padding - paddingBottom);
            ctx.clip();

            // Apply zoom centered on canvas center, then apply pan
            ctx.translate(width / 2 + profileView.panX, height / 2 + profileView.panY);
            ctx.scale(profileView.zoom, profileView.zoom);
            ctx.translate(-width / 2, -height / 2);

            // Draw grid lines (these zoom with content)
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1 / zoom; // Keep line width consistent when zoomed

            // Horizontal grid lines (altitude) - dynamic based on zoom
            for (let alt = 0; alt <= 40000; alt += altStep) {
                const y = height - padding - (alt / 40000) * (height - 2 * padding);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            // Vertical grid lines (distance) - dynamic based on zoom
            const numDistLines = Math.ceil(distance / distStep);
            for (let i = 0; i <= numDistLines; i++) {
                const distNM = i * distStep;
                if (distNM > distance) break;
                const x = padding + (distNM / distance) * (width - 2 * padding);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }

            // Seed for consistent random terrain
            let seed = (depStation.lat * 1000 + destStation.lon * 100) % 1000;
            function seededRandom() {
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            }

            // Generate terrain profile data (always needed for flight path optimization)
            const terrainProfile = [];
            const terrainSamplePoints = 50;
            // Reset seed for consistent terrain calculation
            let terrainSeed = (depStation.lat * 1000 + destStation.lon * 100) % 1000;
            function terrainSeededRandom() {
                terrainSeed = (terrainSeed * 9301 + 49297) % 233280;
                return terrainSeed / 233280;
            }
            for (let i = 0; i <= terrainSamplePoints; i++) {
                const positionSeed = i / terrainSamplePoints;
                const terrainHeight = Math.sin(positionSeed * 10) * 2000 +
                                     Math.sin(positionSeed * 25) * 800 +
                                     Math.sin(positionSeed * 50) * 400 +
                                     terrainSeededRandom() * 500 + 500;
                terrainProfile.push(terrainHeight);
            }

            // Calculate optimal flight path based on hazards
            const optimizedPath = calculateOptimalFlightPath(depStation, destStation, distance, terrainProfile);

            // Draw terrain profile (simulated) - granularity scales with zoom
            if (profileOverlays.terrain) {
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);

                // More terrain points when zoomed in for smoother detail
                const terrainPoints = Math.floor(50 * Math.max(1, zoom));
                for (let i = 0; i <= terrainPoints; i++) {
                    const x = padding + (i / terrainPoints) * (width - 2 * padding);
                    // Use consistent seeding based on position for stable terrain
                    const positionSeed = i / terrainPoints;
                    const terrainHeight = Math.sin(positionSeed * 10) * 2000 +
                                         Math.sin(positionSeed * 25) * 800 +
                                         Math.sin(positionSeed * 50) * 400 +
                                         seededRandom() * 500 + 500;
                    const y = height - padding - (terrainHeight / 40000) * (height - 2 * padding);
                    ctx.lineTo(x, y);
                }

                ctx.lineTo(width - padding, height - padding);
                ctx.closePath();
                ctx.fillStyle = 'rgba(139, 92, 42, 0.4)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(139, 92, 42, 0.8)';
                ctx.lineWidth = 1 / zoom;
                ctx.stroke();
            }

            // Draw ceiling/weather blocks
            const depCeiling = depMetar.ceiling || 25000;
            const destCeiling = destMetar.ceiling || 25000;

            // Weather gradient
            const gradient = ctx.createLinearGradient(padding, 0, width - padding, 0);
            const depColor = flightRulesColors[depMetar.flight_rules || 'VFR'];
            const destColor = flightRulesColors[destMetar.flight_rules || 'VFR'];
            gradient.addColorStop(0, depColor + '40');
            gradient.addColorStop(1, destColor + '40');

            // Draw ceiling overlay
            if (profileOverlays.ceiling) {
                // Draw ceiling line
                ctx.beginPath();
                ctx.moveTo(padding, height - padding - (depCeiling / 40000) * (height - 2 * padding));
                ctx.lineTo(width - padding, height - padding - (destCeiling / 40000) * (height - 2 * padding));
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2 / zoom;
                ctx.stroke();

                // Fill area below ceiling
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);
                ctx.lineTo(padding, height - padding - (depCeiling / 40000) * (height - 2 * padding));
                ctx.lineTo(width - padding, height - padding - (destCeiling / 40000) * (height - 2 * padding));
                ctx.lineTo(width - padding, height - padding);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // Draw visibility overlay - block visualization at different elevations
            if (profileOverlays.visibility) {
                const depVis = depMetar.visibility || 10;
                const destVis = destMetar.visibility || 10;

                // Define elevation bands (floor, ceiling in feet)
                const elevationBands = [
                    { floor: 0, ceiling: 2000, label: 'SFC-2K' },
                    { floor: 2000, ceiling: 5000, label: '2K-5K' },
                    { floor: 5000, ceiling: 10000, label: '5K-10K' },
                    { floor: 10000, ceiling: 18000, label: '10K-18K' },
                    { floor: 18000, ceiling: 40000, label: 'FL180+' }
                ];

                // Calculate visibility at altitude based on surface visibility
                // Visibility generally improves with altitude above obscuration layer
                const getVisAtAltitude = (surfaceVis, altitude) => {
                    if (surfaceVis >= 6) {
                        // Good surface vis = good at all altitudes
                        return surfaceVis;
                    } else if (surfaceVis >= 3) {
                        // Moderate surface vis - improves above 3000ft
                        if (altitude >= 5000) return 10;
                        if (altitude >= 3000) return 6;
                        return surfaceVis;
                    } else if (surfaceVis >= 1) {
                        // Poor surface vis - fog/haze layer up to ~5000ft
                        if (altitude >= 10000) return 10;
                        if (altitude >= 5000) return 6;
                        if (altitude >= 2000) return 3;
                        return surfaceVis;
                    } else {
                        // Very poor surface vis - deep obscuration
                        if (altitude >= 18000) return 10;
                        if (altitude >= 10000) return 6;
                        if (altitude >= 5000) return 3;
                        if (altitude >= 2000) return 1;
                        return surfaceVis;
                    }
                };

                // Color based on visibility value
                const getVisColor = (vis) => {
                    if (vis >= 6) return { r: 34, g: 197, b: 94, a: 0.25 };   // Green - good
                    if (vis >= 3) return { r: 59, g: 130, b: 246, a: 0.35 };  // Blue - moderate
                    if (vis >= 1) return { r: 245, g: 158, b: 11, a: 0.45 };  // Amber - reduced
                    return { r: 239, g: 68, b: 68, a: 0.55 };                  // Red - poor
                };

                // Number of horizontal slices along the route
                const numSlices = 40;

                // Draw blocks for each slice and elevation band
                for (let i = 0; i < numSlices; i++) {
                    const progress = i / numSlices;
                    const nextProgress = (i + 1) / numSlices;
                    const x = padding + progress * (width - 2 * padding);
                    const nextX = padding + nextProgress * (width - 2 * padding);
                    const sliceWidth = nextX - x;

                    // Interpolate surface visibility along route
                    const surfaceVis = depVis + progress * (destVis - depVis);

                    // Draw each elevation band
                    elevationBands.forEach(band => {
                        const midAlt = (band.floor + band.ceiling) / 2;
                        const visAtBand = getVisAtAltitude(surfaceVis, midAlt);
                        const color = getVisColor(visAtBand);

                        const yTop = height - padding - (band.ceiling / 40000) * (height - 2 * padding);
                        const yBottom = height - padding - (band.floor / 40000) * (height - 2 * padding);
                        const blockHeight = yBottom - yTop;

                        // Fill block
                        ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
                        ctx.fillRect(x, yTop, sliceWidth + 0.5, blockHeight);
                    });
                }

                // Draw elevation band boundaries (horizontal lines)
                ctx.strokeStyle = 'rgba(168, 85, 247, 0.4)';
                ctx.lineWidth = 1 / zoom;
                ctx.setLineDash([3 / zoom, 3 / zoom]);
                elevationBands.forEach(band => {
                    if (band.ceiling < 40000) {
                        const y = height - padding - (band.ceiling / 40000) * (height - 2 * padding);
                        ctx.beginPath();
                        ctx.moveTo(padding, y);
                        ctx.lineTo(width - padding, y);
                        ctx.stroke();
                    }
                });
                ctx.setLineDash([]);

                // Draw elevation band labels on the left side
                ctx.font = `${8 / zoom}px sans-serif`;
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(168, 85, 247, 0.9)';
                elevationBands.forEach(band => {
                    const yMid = height - padding - ((band.floor + band.ceiling) / 2 / 40000) * (height - 2 * padding);
                    ctx.fillText(band.label, padding + 3 / zoom, yMid + 3 / zoom);
                });

                // Add visibility legend at bottom
                const legendY = height - padding + 15 / zoom;
                const legendItems = [
                    { label: '>6 SM', color: 'rgba(34, 197, 94, 0.7)' },
                    { label: '3-6 SM', color: 'rgba(59, 130, 246, 0.7)' },
                    { label: '1-3 SM', color: 'rgba(245, 158, 11, 0.7)' },
                    { label: '<1 SM', color: 'rgba(239, 68, 68, 0.7)' }
                ];

                ctx.font = `${9 / zoom}px sans-serif`;
                ctx.textAlign = 'left';
                let legendX = padding;
                legendItems.forEach(item => {
                    // Color box
                    ctx.fillStyle = item.color;
                    ctx.fillRect(legendX, legendY - 8 / zoom, 12 / zoom, 8 / zoom);
                    ctx.strokeStyle = 'rgba(168, 85, 247, 0.5)';
                    ctx.lineWidth = 0.5 / zoom;
                    ctx.strokeRect(legendX, legendY - 8 / zoom, 12 / zoom, 8 / zoom);

                    // Label
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillText(item.label, legendX + 15 / zoom, legendY);
                    legendX += 60 / zoom;
                });

                // Add "VISIBILITY" title
                ctx.textAlign = 'right';
                ctx.fillStyle = 'rgba(168, 85, 247, 0.9)';
                ctx.font = `bold ${9 / zoom}px sans-serif`;
                ctx.fillText('VISIBILITY', width - padding, legendY);
            }

            // Draw temperature overlay - shows OAT gradient across altitude and route
            if (profileOverlays.temperature) {
                // Safely get temperatures with fallback to standard 15C
                const depTemp = (depMetar && depMetar.temperature != null) ? depMetar.temperature : 15;
                const destTemp = (destMetar && destMetar.temperature != null) ? destMetar.temperature : 15;

                // Standard lapse rate: approximately -2C per 1000ft (or -6.5C per 1000m)
                const lapseRate = -2; // C per 1000ft

                // Get temperature color based on value
                const getTempColor = (temp) => {
                    if (temp <= -40) return { r: 88, g: 28, b: 135, a: 0.5 };   // Deep purple - extreme cold
                    if (temp <= -20) return { r: 124, g: 58, b: 237, a: 0.4 };  // Purple - very cold
                    if (temp <= -10) return { r: 59, g: 130, b: 246, a: 0.35 }; // Blue - cold
                    if (temp <= 0) return { r: 6, g: 182, b: 212, a: 0.3 };     // Cyan - freezing
                    if (temp <= 10) return { r: 34, g: 197, b: 94, a: 0.25 };   // Green - cool
                    if (temp <= 20) return { r: 132, g: 204, b: 22, a: 0.25 };  // Lime - mild
                    if (temp <= 30) return { r: 245, g: 158, b: 11, a: 0.3 };   // Amber - warm
                    if (temp <= 40) return { r: 239, g: 68, b: 68, a: 0.35 };   // Red - hot
                    return { r: 153, g: 27, b: 27, a: 0.4 };                     // Dark red - extreme
                };

                // Define altitude bands for temperature visualization
                const tempBands = [
                    { floor: 0, ceiling: 5000 },
                    { floor: 5000, ceiling: 10000 },
                    { floor: 10000, ceiling: 18000 },
                    { floor: 18000, ceiling: 25000 },
                    { floor: 25000, ceiling: 35000 },
                    { floor: 35000, ceiling: 40000 }
                ];

                // Number of horizontal slices along the route
                const numSlices = 40;

                // Draw temperature blocks for each slice and altitude band
                for (let i = 0; i < numSlices; i++) {
                    const progress = i / numSlices;
                    const nextProgress = (i + 1) / numSlices;
                    const x = padding + progress * (width - 2 * padding);
                    const nextX = padding + nextProgress * (width - 2 * padding);
                    const sliceWidth = nextX - x;

                    // Interpolate surface temperature along route
                    const surfaceTemp = depTemp + progress * (destTemp - depTemp);

                    // Draw each altitude band
                    tempBands.forEach(band => {
                        const midAlt = (band.floor + band.ceiling) / 2;
                        // Calculate temperature at this altitude using lapse rate
                        const tempAtAlt = surfaceTemp + (midAlt / 1000) * lapseRate;
                        const color = getTempColor(tempAtAlt);

                        const yTop = height - padding - (band.ceiling / 40000) * (height - 2 * padding);
                        const yBottom = height - padding - (band.floor / 40000) * (height - 2 * padding);
                        const blockHeight = yBottom - yTop;

                        // Fill block
                        ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
                        ctx.fillRect(x, yTop, sliceWidth + 0.5, blockHeight);
                    });
                }

                // Draw freezing level line (0C isotherm)
                const depFreezingAlt = depTemp > 0 ? (depTemp / Math.abs(lapseRate)) * 1000 : 0;
                const destFreezingAlt = destTemp > 0 ? (destTemp / Math.abs(lapseRate)) * 1000 : 0;

                if (depFreezingAlt > 0 || destFreezingAlt > 0) {
                    ctx.beginPath();
                    ctx.setLineDash([4 / zoom, 4 / zoom]);
                    ctx.strokeStyle = '#06b6d4';
                    ctx.lineWidth = 2 / zoom;

                    for (let i = 0; i <= 30; i++) {
                        const progress = i / 30;
                        const x = padding + progress * (width - 2 * padding);
                        const freezingAlt = depFreezingAlt + progress * (destFreezingAlt - depFreezingAlt);
                        const y = height - padding - (Math.min(freezingAlt, 40000) / 40000) * (height - 2 * padding);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Label freezing level
                    ctx.font = `bold ${9 / zoom}px sans-serif`;
                    ctx.fillStyle = '#06b6d4';
                    ctx.textAlign = 'left';
                    const freezeMidY = height - padding - ((depFreezingAlt + destFreezingAlt) / 2 / 40000) * (height - 2 * padding);
                    ctx.fillText('0C', padding + 3 / zoom, freezeMidY - 3 / zoom);
                }

                // Draw altitude band boundaries
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.3)';
                ctx.lineWidth = 0.5 / zoom;
                ctx.setLineDash([2 / zoom, 4 / zoom]);
                tempBands.forEach(band => {
                    if (band.ceiling < 40000) {
                        const y = height - padding - (band.ceiling / 40000) * (height - 2 * padding);
                        ctx.beginPath();
                        ctx.moveTo(padding, y);
                        ctx.lineTo(width - padding, y);
                        ctx.stroke();
                    }
                });
                ctx.setLineDash([]);

                // Add compact temperature indicator at top center of profile
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';

                // Position at top center
                const tempBoxY = padding + 8;
                const centerX = width / 2;

                // Calculate total width needed for both boxes
                const tempBoxWidth = 110;
                const freezingBoxWidth = 95;
                const gap = 8;
                const hasFreezingLevel = depFreezingAlt > 0 || destFreezingAlt > 0;
                const totalWidth = hasFreezingLevel ? tempBoxWidth + gap + freezingBoxWidth : tempBoxWidth;
                const startX = centerX - totalWidth / 2;

                // Temperature range box
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(startX, tempBoxY, tempBoxWidth, 18);
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(startX, tempBoxY, tempBoxWidth, 18);

                ctx.fillStyle = '#ef4444';
                ctx.textAlign = 'center';
                ctx.fillText(`OAT: ${depTemp}C  ${destTemp}C`, startX + tempBoxWidth / 2, tempBoxY + 13);

                // Add freezing level indicator if applicable
                if (hasFreezingLevel) {
                    const avgFreezingAlt = Math.round((depFreezingAlt + destFreezingAlt) / 2);
                    const freezingX = startX + tempBoxWidth + gap;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(freezingX, tempBoxY, freezingBoxWidth, 18);
                    ctx.strokeStyle = 'rgba(6, 182, 212, 0.6)';
                    ctx.strokeRect(freezingX, tempBoxY, freezingBoxWidth, 18);
                    ctx.fillStyle = '#06b6d4';
                    ctx.fillText(`0C: ${avgFreezingAlt.toLocaleString()}ft`, freezingX + freezingBoxWidth / 2, tempBoxY + 13);
                }
            }

            // Draw airspace overlay
            if (profileOverlays.airspace) {
                // Find airspaces along the route
                const routeMidLat = (depStation.lat + destStation.lat) / 2;
                const routeMidLon = (depStation.lon + destStation.lon) / 2;

                // Check which airspaces the route might pass through
                const relevantAirspaces = [];

                // Check Class B (using center from first tier)
                airspaceData.classB.forEach(airspace => {
                    const center = airspace.center;
                    const distToDep = Math.sqrt(Math.pow(center[0] - depStation.lat, 2) + Math.pow(center[1] - depStation.lon, 2));
                    const distToDest = Math.sqrt(Math.pow(center[0] - destStation.lat, 2) + Math.pow(center[1] - destStation.lon, 2));
                    const distToMid = Math.sqrt(Math.pow(center[0] - routeMidLat, 2) + Math.pow(center[1] - routeMidLon, 2));

                    if (distToDep < 1 || distToDest < 1 || distToMid < 3) {
                        // Get the innermost tier's ceiling (highest restriction)
                        const maxCeiling = Math.max(...airspace.tiers.map(t => t.ceiling));
                        relevantAirspaces.push({ name: airspace.name, center, floor: 0, ceiling: maxCeiling, type: 'B', color: '#3b82f6' });
                    }
                });

                // Check Class C
                airspaceData.classC.forEach(airspace => {
                    const center = airspace.center;
                    const distToDep = Math.sqrt(Math.pow(center[0] - depStation.lat, 2) + Math.pow(center[1] - depStation.lon, 2));
                    const distToDest = Math.sqrt(Math.pow(center[0] - destStation.lat, 2) + Math.pow(center[1] - destStation.lon, 2));

                    if (distToDep < 0.5 || distToDest < 0.5) {
                        const maxCeiling = Math.max(...airspace.tiers.map(t => t.ceiling));
                        relevantAirspaces.push({ name: airspace.name, center, floor: 0, ceiling: maxCeiling, type: 'C', color: '#ec4899' });
                    }
                });

                // Check MOAs
                airspaceData.moa.forEach(zone => {
                    const centerLat = zone.polygon.reduce((sum, p) => sum + p[0], 0) / zone.polygon.length;
                    const centerLon = zone.polygon.reduce((sum, p) => sum + p[1], 0) / zone.polygon.length;
                    const distToMid = Math.sqrt(Math.pow(centerLat - routeMidLat, 2) + Math.pow(centerLon - routeMidLon, 2));

                    if (distToMid < 4) {
                        relevantAirspaces.push({ ...zone, type: 'MOA', color: '#d97706' });
                    }
                });

                // Check Restricted
                airspaceData.restricted.forEach(zone => {
                    const centerLat = zone.polygon.reduce((sum, p) => sum + p[0], 0) / zone.polygon.length;
                    const centerLon = zone.polygon.reduce((sum, p) => sum + p[1], 0) / zone.polygon.length;
                    const distToMid = Math.sqrt(Math.pow(centerLat - routeMidLat, 2) + Math.pow(centerLon - routeMidLon, 2));

                    if (distToMid < 4) {
                        relevantAirspaces.push({ ...zone, type: 'R', color: '#ef4444' });
                    }
                });

                // Draw departure and destination Class B shelves
                const depAirspace = airspaceData.classB.find(a =>
                    Math.sqrt(Math.pow(a.center[0] - depStation.lat, 2) + Math.pow(a.center[1] - depStation.lon, 2)) < 0.5
                );
                const destAirspace = airspaceData.classB.find(a =>
                    Math.sqrt(Math.pow(a.center[0] - destStation.lat, 2) + Math.pow(a.center[1] - destStation.lon, 2)) < 0.5
                );

                // Draw departure Class B tiers - high resolution wedding cake structure
                if (depAirspace && depAirspace.tiers && depAirspace.tiers.length > 0) {
                    try {
                    // Calculate distance-based width for each tier (in NM from airport)
                    // Outer tiers extend further horizontally
                    const tierRadii = [10, 20, 30]; // NM radius for each tier
                    const distancePerPixel = Math.max(0.01, distance / (width - 2 * padding));

                    // Sort tiers by floor (outer tiers have higher floors)
                    const sortedTiers = [...depAirspace.tiers].sort((a, b) => a.floor - b.floor);

                    // Draw from outer to inner for proper layering
                    for (let i = sortedTiers.length - 1; i >= 0; i--) {
                        const tier = sortedTiers[i];
                        const tierRadius = tierRadii[Math.min(i, tierRadii.length - 1)] || 30;
                        const xWidth = Math.max(20, tierRadius / distancePerPixel) * zoom;

                        const yTop = height - padding - (tier.ceiling / 40000) * (height - 2 * padding);
                        const yBottom = height - padding - (tier.floor / 40000) * (height - 2 * padding);

                        // Gradient fill for depth effect
                        const gradient = ctx.createLinearGradient(padding, 0, padding + xWidth, 0);
                        const alpha = 0.15 + (sortedTiers.length - 1 - i) * 0.1;
                        gradient.addColorStop(0, `rgba(59, 130, 246, ${alpha + 0.15})`);
                        gradient.addColorStop(1, `rgba(59, 130, 246, ${alpha})`);

                        ctx.fillStyle = gradient;
                        ctx.fillRect(padding, yTop, xWidth, yBottom - yTop);

                        // Border - thicker for inner tiers, zoom responsive
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = (i === 0 ? 2.5 : 1.5) / zoom;
                        ctx.setLineDash(i === 0 ? [] : [4 / zoom, 2 / zoom]);
                        ctx.strokeRect(padding, yTop, xWidth, yBottom - yTop);

                        // Altitude labels on each shelf - zoom responsive font
                        const fontSize = Math.max(7, 10 / zoom);
                        ctx.font = `${fontSize}px sans-serif`;
                        ctx.fillStyle = 'rgba(59, 130, 246, 0.9)';
                        ctx.textAlign = 'left';

                        // Floor label
                        const floorLabel = tier.floor === 0 ? 'SFC' : `${(tier.floor / 1000).toFixed(1)}K`;
                        ctx.fillText(floorLabel, padding + xWidth + 3 / zoom, yBottom - 2 / zoom);

                        // Ceiling label (only for innermost tier)
                        if (i === 0) {
                            ctx.fillText(`${(tier.ceiling / 1000).toFixed(1)}K`, padding + xWidth + 3 / zoom, yTop + fontSize);
                        }

                        // Horizontal shelf line for visual clarity
                        if (i < sortedTiers.length - 1 && tier.floor > 0) {
                            ctx.beginPath();
                            ctx.moveTo(padding, yBottom);
                            ctx.lineTo(padding + xWidth + 5 / zoom, yBottom);
                            ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
                            ctx.lineWidth = 1 / zoom;
                            ctx.setLineDash([]);
                            ctx.stroke();
                        }
                    }
                    ctx.setLineDash([]);

                    // Main label with enhanced styling
                    const labelFontSize = Math.max(10, 14 / zoom);
                    ctx.font = `bold ${labelFontSize}px sans-serif`;
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'left';
                    const labelY = height - padding - (sortedTiers[0].ceiling / 40000) * (height - 2 * padding) - 8 / zoom;
                    ctx.fillText('Class B', padding + 2 / zoom, labelY);

                    // Airport identifier
                    ctx.font = `${Math.max(8, 11 / zoom)}px sans-serif`;
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                    ctx.fillText(depAirspace.name.split(' ')[0], padding + 2 / zoom, labelY + labelFontSize);
                    } catch (e) { console.error('Dep airspace draw error:', e); }
                }

                // Draw destination Class B tiers - high resolution wedding cake structure
                if (destAirspace && destAirspace.tiers && destAirspace.tiers.length > 0) {
                    try {
                    const tierRadii = [10, 20, 30];
                    const distancePerPixel = Math.max(0.01, distance / (width - 2 * padding));

                    const sortedTiers = [...destAirspace.tiers].sort((a, b) => a.floor - b.floor);

                    for (let i = sortedTiers.length - 1; i >= 0; i--) {
                        const tier = sortedTiers[i];
                        const tierRadius = tierRadii[Math.min(i, tierRadii.length - 1)] || 30;
                        const xWidth = Math.max(20, tierRadius / distancePerPixel) * zoom;

                        const yTop = height - padding - (tier.ceiling / 40000) * (height - 2 * padding);
                        const yBottom = height - padding - (tier.floor / 40000) * (height - 2 * padding);

                        // Gradient fill for depth effect
                        const gradient = ctx.createLinearGradient(width - padding - xWidth, 0, width - padding, 0);
                        const alpha = 0.15 + (sortedTiers.length - 1 - i) * 0.1;
                        gradient.addColorStop(0, `rgba(59, 130, 246, ${alpha})`);
                        gradient.addColorStop(1, `rgba(59, 130, 246, ${alpha + 0.15})`);

                        ctx.fillStyle = gradient;
                        ctx.fillRect(width - padding - xWidth, yTop, xWidth, yBottom - yTop);

                        // Border
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = (i === 0 ? 2.5 : 1.5) / zoom;
                        ctx.setLineDash(i === 0 ? [] : [4 / zoom, 2 / zoom]);
                        ctx.strokeRect(width - padding - xWidth, yTop, xWidth, yBottom - yTop);

                        // Altitude labels
                        const fontSize = Math.max(7, 10 / zoom);
                        ctx.font = `${fontSize}px sans-serif`;
                        ctx.fillStyle = 'rgba(59, 130, 246, 0.9)';
                        ctx.textAlign = 'right';

                        const floorLabel = tier.floor === 0 ? 'SFC' : `${(tier.floor / 1000).toFixed(1)}K`;
                        ctx.fillText(floorLabel, width - padding - xWidth - 3 / zoom, yBottom - 2 / zoom);

                        if (i === 0) {
                            ctx.fillText(`${(tier.ceiling / 1000).toFixed(1)}K`, width - padding - xWidth - 3 / zoom, yTop + fontSize);
                        }

                        // Horizontal shelf line
                        if (i < sortedTiers.length - 1 && tier.floor > 0) {
                            ctx.beginPath();
                            ctx.moveTo(width - padding - xWidth - 5 / zoom, yBottom);
                            ctx.lineTo(width - padding, yBottom);
                            ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
                            ctx.lineWidth = 1 / zoom;
                            ctx.setLineDash([]);
                            ctx.stroke();
                        }
                    }
                    ctx.setLineDash([]);

                    // Main label
                    const labelFontSize = Math.max(10, 14 / zoom);
                    ctx.font = `bold ${labelFontSize}px sans-serif`;
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'right';
                    const labelY = height - padding - (sortedTiers[0].ceiling / 40000) * (height - 2 * padding) - 8 / zoom;
                    ctx.fillText('Class B', width - padding - 2 / zoom, labelY);

                    ctx.font = `${Math.max(8, 11 / zoom)}px sans-serif`;
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                    ctx.fillText(destAirspace.name.split(' ')[0], width - padding - 2 / zoom, labelY + labelFontSize);
                    } catch (e) { console.error('Dest airspace draw error:', e); }
                }

                // Also check for Class C airports at departure/destination
                const depClassC = airspaceData.classC.find(a =>
                    Math.sqrt(Math.pow(a.center[0] - depStation.lat, 2) + Math.pow(a.center[1] - depStation.lon, 2)) < 0.3
                );
                const destClassC = airspaceData.classC.find(a =>
                    Math.sqrt(Math.pow(a.center[0] - destStation.lat, 2) + Math.pow(a.center[1] - destStation.lon, 2)) < 0.3
                );

                // Draw Class C if present and no Class B
                if (depClassC && !depAirspace && depClassC.tiers && depClassC.tiers.length > 0) {
                    try {
                    const distancePerPixel = Math.max(0.01, distance / (width - 2 * padding));
                    const sortedTiers = [...depClassC.tiers].sort((a, b) => a.floor - b.floor);

                    for (let i = sortedTiers.length - 1; i >= 0; i--) {
                        const tier = sortedTiers[i];
                        const tierRadius = [5, 10][Math.min(i, 1)] || 10;
                        const xWidth = Math.max(15, tierRadius / distancePerPixel) * zoom;

                        const yTop = height - padding - (tier.ceiling / 40000) * (height - 2 * padding);
                        const yBottom = height - padding - (tier.floor / 40000) * (height - 2 * padding);

                        const gradient = ctx.createLinearGradient(padding, 0, padding + xWidth, 0);
                        const alpha = 0.12 + (sortedTiers.length - 1 - i) * 0.08;
                        gradient.addColorStop(0, `rgba(236, 72, 153, ${alpha + 0.1})`);
                        gradient.addColorStop(1, `rgba(236, 72, 153, ${alpha})`);

                        ctx.fillStyle = gradient;
                        ctx.fillRect(padding, yTop, xWidth, yBottom - yTop);

                        ctx.strokeStyle = '#ec4899';
                        ctx.lineWidth = (i === 0 ? 2 : 1.5) / zoom;
                        ctx.setLineDash(i === 0 ? [] : [3 / zoom, 2 / zoom]);
                        ctx.strokeRect(padding, yTop, xWidth, yBottom - yTop);
                    }
                    ctx.setLineDash([]);

                    const labelFontSize = Math.max(9, 12 / zoom);
                    ctx.font = `bold ${labelFontSize}px sans-serif`;
                    ctx.fillStyle = '#ec4899';
                    ctx.textAlign = 'left';
                    ctx.fillText('Class C', padding + 2 / zoom, height - padding - (sortedTiers[0].ceiling / 40000) * (height - 2 * padding) - 5 / zoom);
                    } catch (e) { console.error('Dep Class C draw error:', e); }
                }

                if (destClassC && !destAirspace && destClassC.tiers && destClassC.tiers.length > 0) {
                    try {
                    const distancePerPixel = Math.max(0.01, distance / (width - 2 * padding));
                    const sortedTiers = [...destClassC.tiers].sort((a, b) => a.floor - b.floor);

                    for (let i = sortedTiers.length - 1; i >= 0; i--) {
                        const tier = sortedTiers[i];
                        const tierRadius = [5, 10][Math.min(i, 1)] || 10;
                        const xWidth = Math.max(15, tierRadius / distancePerPixel) * zoom;

                        const yTop = height - padding - (tier.ceiling / 40000) * (height - 2 * padding);
                        const yBottom = height - padding - (tier.floor / 40000) * (height - 2 * padding);

                        const gradient = ctx.createLinearGradient(width - padding - xWidth, 0, width - padding, 0);
                        const alpha = 0.12 + (sortedTiers.length - 1 - i) * 0.08;
                        gradient.addColorStop(0, `rgba(236, 72, 153, ${alpha})`);
                        gradient.addColorStop(1, `rgba(236, 72, 153, ${alpha + 0.1})`);

                        ctx.fillStyle = gradient;
                        ctx.fillRect(width - padding - xWidth, yTop, xWidth, yBottom - yTop);

                        ctx.strokeStyle = '#ec4899';
                        ctx.lineWidth = (i === 0 ? 2 : 1.5) / zoom;
                        ctx.setLineDash(i === 0 ? [] : [3 / zoom, 2 / zoom]);
                        ctx.strokeRect(width - padding - xWidth, yTop, xWidth, yBottom - yTop);
                    }
                    ctx.setLineDash([]);

                    const labelFontSize = Math.max(9, 12 / zoom);
                    ctx.font = `bold ${labelFontSize}px sans-serif`;
                    ctx.fillStyle = '#ec4899';
                    ctx.textAlign = 'right';
                    ctx.fillText('Class C', width - padding - 2 / zoom, height - padding - (sortedTiers[0].ceiling / 40000) * (height - 2 * padding) - 5 / zoom);
                    } catch (e) { console.error('Dest Class C draw error:', e); }
                }

                // Point-in-polygon helper for route intersection
                const pointInPoly = (lat, lon, polygon) => {
                    let inside = false;
                    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                        const xi = polygon[i][0], yi = polygon[i][1];
                        const xj = polygon[j][0], yj = polygon[j][1];
                        if (((yi > lon) !== (yj > lon)) && (lat < (xj - xi) * (lon - yi) / (yj - yi) + xi)) {
                            inside = !inside;
                        }
                    }
                    return inside;
                };

                // Find where route crosses each airspace
                const routeAirspaces = [];

                // Dynamic step size for route intersection - more granular when zoomed
                const routeStep = 0.02 / Math.max(1, zoom);

                // Check Restricted areas along route
                airspaceData.restricted.forEach(zone => {
                    let entryProgress = null, exitProgress = null;
                    for (let p = 0; p <= 1; p += routeStep) {
                        const lat = depStation.lat + p * (destStation.lat - depStation.lat);
                        const lon = depStation.lon + p * (destStation.lon - depStation.lon);
                        const inside = pointInPoly(lat, lon, zone.polygon);
                        if (inside && entryProgress === null) entryProgress = p;
                        if (!inside && entryProgress !== null && exitProgress === null) exitProgress = p;
                    }
                    if (entryProgress !== null) {
                        exitProgress = exitProgress || 1;
                        routeAirspaces.push({
                            ...zone, type: 'R', color: '#ef4444',
                            entry: entryProgress, exit: exitProgress,
                            floor: zone.floor || 0
                        });
                    }
                });

                // Check Prohibited areas along route
                airspaceData.prohibited.forEach(zone => {
                    let entryProgress = null, exitProgress = null;
                    for (let p = 0; p <= 1; p += routeStep) {
                        const lat = depStation.lat + p * (destStation.lat - depStation.lat);
                        const lon = depStation.lon + p * (destStation.lon - depStation.lon);
                        const inside = pointInPoly(lat, lon, zone.polygon);
                        if (inside && entryProgress === null) entryProgress = p;
                        if (!inside && entryProgress !== null && exitProgress === null) exitProgress = p;
                    }
                    if (entryProgress !== null) {
                        exitProgress = exitProgress || 1;
                        routeAirspaces.push({
                            ...zone, type: 'P', color: '#dc2626',
                            entry: entryProgress, exit: exitProgress,
                            floor: zone.floor || 0
                        });
                    }
                });

                // Check MOAs along route
                airspaceData.moa.forEach(zone => {
                    let entryProgress = null, exitProgress = null;
                    for (let p = 0; p <= 1; p += routeStep) {
                        const lat = depStation.lat + p * (destStation.lat - depStation.lat);
                        const lon = depStation.lon + p * (destStation.lon - depStation.lon);
                        const inside = pointInPoly(lat, lon, zone.polygon);
                        if (inside && entryProgress === null) entryProgress = p;
                        if (!inside && entryProgress !== null && exitProgress === null) exitProgress = p;
                    }
                    if (entryProgress !== null) {
                        exitProgress = exitProgress || 1;
                        routeAirspaces.push({
                            ...zone, type: 'MOA', color: '#d97706',
                            entry: entryProgress, exit: exitProgress
                        });
                    }
                });

                // Draw each airspace at its actual position along route
                routeAirspaces.forEach(zone => {
                    const xStart = padding + zone.entry * (width - 2 * padding);
                    const xEnd = padding + zone.exit * (width - 2 * padding);
                    const yTop = height - padding - (Math.min(zone.ceiling, 50000) / 40000) * (height - 2 * padding);
                    const yBottom = height - padding - ((zone.floor || 0) / 40000) * (height - 2 * padding);

                    // Fill
                    ctx.fillStyle = zone.color + '30';
                    ctx.fillRect(xStart, yTop, xEnd - xStart, yBottom - yTop);

                    // Border with dashed line
                    ctx.strokeStyle = zone.color;
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 3 / zoom]);
                    ctx.strokeRect(xStart, yTop, xEnd - xStart, yBottom - yTop);
                    ctx.setLineDash([]);

                    // Label with name - scale font size for zoom
                    ctx.fillStyle = zone.color;
                    const fontSize = Math.max(6, 9 / zoom);
                    ctx.font = `bold ${fontSize}px sans-serif`;
                    ctx.textAlign = 'center';
                    const labelText = zone.type === 'R' ? zone.name : (zone.type === 'P' ? ` ${zone.name}` : zone.name);
                    ctx.fillText(labelText, (xStart + xEnd) / 2, yTop - 4 / zoom);

                    // Floor/Ceiling label
                    ctx.font = `${Math.max(5, 8 / zoom)}px sans-serif`;
                    const floorStr = (zone.floor || 0) === 0 ? 'SFC' : `${(zone.floor / 1000).toFixed(0)}k`;
                    const ceilStr = zone.ceiling >= 99999 ? 'UNL' : `${(zone.ceiling / 1000).toFixed(0)}k`;
                    ctx.fillText(`${floorStr}-${ceilStr}`, (xStart + xEnd) / 2, yTop + 10 / zoom);
                });
            }

            // Draw clouds overlay
            if (profileOverlays.clouds) {
                // Simulate scattered cloud layers - more detail when zoomed
                const cloudLayers = [
                    { base: 8000, top: 12000, coverage: 0.4 },
                    { base: 18000, top: 22000, coverage: 0.6 },
                    { base: 28000, top: 32000, coverage: 0.3 }
                ];

                // Add intermediate layers when zoomed
                if (zoom >= 2) {
                    cloudLayers.push(
                        { base: 5000, top: 7000, coverage: 0.3 },
                        { base: 14000, top: 16000, coverage: 0.35 },
                        { base: 24000, top: 26000, coverage: 0.25 }
                    );
                }

                cloudLayers.forEach(layer => {
                    const baseY = height - padding - (layer.base / 40000) * (height - 2 * padding);
                    const topY = height - padding - (layer.top / 40000) * (height - 2 * padding);

                    // Draw more cloud shapes when zoomed
                    ctx.fillStyle = 'rgba(148, 163, 184, 0.25)';
                    const numClouds = Math.floor(15 * Math.max(1, zoom));
                    for (let i = 0; i < numClouds; i++) {
                        const x = padding + seededRandom() * (width - 2 * padding);
                        const cloudWidth = (30 + seededRandom() * 60) / zoom;
                        const cloudHeight = (baseY - topY) * 0.7;

                        if (seededRandom() < layer.coverage) {
                            ctx.beginPath();
                            ctx.ellipse(x, (baseY + topY) / 2, cloudWidth, cloudHeight / 2, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
            }

            // Draw icing overlay
            if (profileOverlays.icing) {
                // Icing typically occurs between freezing level and -20C (roughly 10k-25k ft)
                const icingBase = 10000;
                const icingTop = 25000;
                const baseY = height - padding - (icingBase / 40000) * (height - 2 * padding);
                const topY = height - padding - (icingTop / 40000) * (height - 2 * padding);

                // Light blue gradient for icing zone
                const icingGradient = ctx.createLinearGradient(0, topY, 0, baseY);
                icingGradient.addColorStop(0, 'rgba(6, 182, 212, 0.3)');
                icingGradient.addColorStop(0.5, 'rgba(6, 182, 212, 0.15)');
                icingGradient.addColorStop(1, 'rgba(6, 182, 212, 0.05)');

                ctx.fillStyle = icingGradient;
                ctx.fillRect(padding, topY, width - 2 * padding, baseY - topY);

                // Draw ice crystal symbols - more when zoomed in
                ctx.strokeStyle = 'rgba(6, 182, 212, 0.6)';
                ctx.lineWidth = 1 / zoom;
                const numIceSymbols = Math.floor(8 * Math.max(1, zoom));
                for (let i = 0; i < numIceSymbols; i++) {
                    const x = padding + 40 + i * ((width - 2 * padding - 80) / (numIceSymbols - 1));
                    const y = (topY + baseY) / 2 + (seededRandom() - 0.5) * 20;

                    // Draw snowflake
                    const flakeSize = 6 / zoom;
                    ctx.beginPath();
                    for (let j = 0; j < 6; j++) {
                        const angle = (j * Math.PI) / 3;
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + Math.cos(angle) * flakeSize, y + Math.sin(angle) * flakeSize);
                    }
                    ctx.stroke();
                }
            }

            // Draw turbulence overlay
            if (profileOverlays.turbulence) {
                // Turbulence zones at different altitudes
                const turbZones = [
                    { alt: 5000, intensity: 'light' },
                    { alt: 18000, intensity: 'moderate' },
                    { alt: 35000, intensity: 'light' }
                ];

                turbZones.forEach(zone => {
                    const zoneY = height - padding - (zone.alt / 40000) * (height - 2 * padding);
                    const opacity = zone.intensity === 'moderate' ? 0.4 : 0.2;

                    // Draw wavy turbulence line - more detail when zoomed
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(249, 115, 22, ${opacity})`;
                    ctx.lineWidth = (zone.intensity === 'moderate' ? 3 : 2) / zoom;

                    const step = Math.max(1, 2 / zoom);
                    for (let x = padding; x <= width - padding; x += step) {
                        const progress = (x - padding) / (width - 2 * padding);
                        const wave = Math.sin(x / 8) * 4 + Math.sin(x / 15) * 3 + Math.sin(x / 4) * 1.5;
                        const y = zoneY + wave;

                        if (x === padding) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                });

                // Add turbulence zone indicator
                ctx.fillStyle = 'rgba(249, 115, 22, 0.15)';
                const turbBase = height - padding - (15000 / 40000) * (height - 2 * padding);
                const turbTop = height - padding - (21000 / 40000) * (height - 2 * padding);
                ctx.fillRect(padding + (width - 2 * padding) * 0.3, turbTop, (width - 2 * padding) * 0.4, turbBase - turbTop);
            }

            // Draw winds overlay
            if (profileOverlays.winds) {
                // Wind barbs at different altitudes - more levels when zoomed
                const baseWindLevels = [
                    { alt: 3000, speed: 15, dir: 270 },
                    { alt: 9000, speed: 35, dir: 280 },
                    { alt: 18000, speed: 65, dir: 290 },
                    { alt: 30000, speed: 120, dir: 285 },
                    { alt: 39000, speed: 95, dir: 275 }
                ];

                // Add intermediate levels when zoomed
                const windLevels = [...baseWindLevels];
                if (zoom >= 2) {
                    windLevels.push(
                        { alt: 6000, speed: 25, dir: 275 },
                        { alt: 12000, speed: 45, dir: 285 },
                        { alt: 24000, speed: 85, dir: 288 },
                        { alt: 36000, speed: 110, dir: 280 }
                    );
                }
                if (zoom >= 4) {
                    windLevels.push(
                        { alt: 1500, speed: 10, dir: 265 },
                        { alt: 4500, speed: 20, dir: 272 },
                        { alt: 15000, speed: 55, dir: 287 },
                        { alt: 21000, speed: 75, dir: 289 },
                        { alt: 27000, speed: 95, dir: 286 },
                        { alt: 33000, speed: 115, dir: 283 }
                    );
                }
                windLevels.sort((a, b) => a.alt - b.alt);

                ctx.strokeStyle = 'rgba(34, 197, 94, 0.7)';
                ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
                const windFontSize = Math.max(6, 9 / zoom);
                ctx.font = `${windFontSize}px sans-serif`;
                ctx.textAlign = 'left';

                windLevels.forEach(wind => {
                    const y = height - padding - (wind.alt / 40000) * (height - 2 * padding);
                    const x = width - padding - 60;

                    // Draw wind arrow
                    const arrowLen = 25 / zoom;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + arrowLen, y);
                    ctx.lineWidth = 2 / zoom;
                    ctx.stroke();

                    // Arrow head
                    const headSize = 4 / zoom;
                    ctx.beginPath();
                    ctx.moveTo(x + arrowLen, y);
                    ctx.lineTo(x + arrowLen - 5 / zoom, y - headSize);
                    ctx.lineTo(x + arrowLen - 5 / zoom, y + headSize);
                    ctx.closePath();
                    ctx.fill();

                    // Wind speed text
                    ctx.fillText(`${wind.speed}kt`, x + arrowLen + 5 / zoom, y + 3 / zoom);
                });
            }

            // Draw optimized flight path with dynamic altitude changes
            if (optimizedPath && optimizedPath.length > 0) {
                ctx.setLineDash([]);

                // Get first and last waypoint positions
                const firstWp = optimizedPath[0];
                const lastWp = optimizedPath[optimizedPath.length - 1];
                const firstX = padding + firstWp.t * (width - 2 * padding);
                const firstY = height - padding - (firstWp.altitude / 40000) * (height - 2 * padding);
                const lastX = padding + lastWp.t * (width - 2 * padding);
                const lastY = height - padding - (lastWp.altitude / 40000) * (height - 2 * padding);

                // Draw flight path shadow for depth
                ctx.beginPath();
                ctx.moveTo(firstX, firstY + 2 / zoom);
                for (let i = 1; i < optimizedPath.length; i++) {
                    const wp = optimizedPath[i];
                    const x = padding + wp.t * (width - 2 * padding);
                    const y = height - padding - (wp.altitude / 40000) * (height - 2 * padding);
                    ctx.lineTo(x, y + 2 / zoom);
                }
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 4 / zoom;
                ctx.stroke();

                // Draw main flight path with phase-based coloring
                let currentPhase = null;
                ctx.beginPath();
                ctx.moveTo(firstX, firstY);

                for (let i = 0; i < optimizedPath.length; i++) {
                    const wp = optimizedPath[i];
                    const x = padding + wp.t * (width - 2 * padding);
                    const y = height - padding - (wp.altitude / 40000) * (height - 2 * padding);

                    // Change color based on flight phase
                    if (wp.phase !== currentPhase && currentPhase !== null) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    }

                    ctx.lineTo(x, y);
                    currentPhase = wp.phase;

                    // Set color based on phase
                    if (wp.phase === 'climb') {
                        ctx.strokeStyle = '#22c55e'; // Green for climb
                    } else if (wp.phase === 'descent') {
                        ctx.strokeStyle = '#f59e0b'; // Amber for descent
                    } else {
                        ctx.strokeStyle = '#6366f1'; // Indigo for cruise
                    }
                }
                ctx.lineWidth = 2.5 / zoom;
                ctx.stroke();

                // Draw waypoint markers at significant altitude changes
                ctx.fillStyle = '#ffffff';
                let prevAlt = 0;
                for (const wp of optimizedPath) {
                    const altChange = Math.abs(wp.altitude - prevAlt);
                    if (altChange >= 3000 && wp.phase === 'cruise') {
                        const x = padding + wp.t * (width - 2 * padding);
                        const y = height - padding - (wp.altitude / 40000) * (height - 2 * padding);
                        ctx.beginPath();
                        ctx.arc(x, y, 3 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    prevAlt = wp.altitude;
                }

                // Draw altitude labels at key points (TOC, cruise changes, TOD)
                ctx.font = `${9 / zoom}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';

                // Find Top of Climb (TOC)
                const tocIdx = optimizedPath.findIndex(wp => wp.phase === 'cruise');
                if (tocIdx > 0) {
                    const toc = optimizedPath[tocIdx];
                    const x = padding + toc.t * (width - 2 * padding);
                    const y = height - padding - (toc.altitude / 40000) * (height - 2 * padding);
                    ctx.fillText(`TOC FL${Math.round(toc.altitude / 100)}`, x, y - 8 / zoom);
                }

                // Find Top of Descent (TOD)
                const todIdx = optimizedPath.findIndex(wp => wp.phase === 'descent');
                if (todIdx > 0) {
                    const tod = optimizedPath[todIdx - 1];
                    const x = padding + tod.t * (width - 2 * padding);
                    const y = height - padding - (tod.altitude / 40000) * (height - 2 * padding);
                    ctx.fillText(`TOD FL${Math.round(tod.altitude / 100)}`, x, y - 8 / zoom);
                }

                // Draw cruise altitude in middle
                const midCruise = optimizedPath[Math.floor(optimizedPath.length / 2)];
                if (midCruise && midCruise.phase === 'cruise') {
                    const x = padding + midCruise.t * (width - 2 * padding);
                    const y = height - padding - (midCruise.altitude / 40000) * (height - 2 * padding);
                    ctx.fillStyle = 'rgba(99, 102, 241, 0.9)';
                    ctx.font = `bold ${10 / zoom}px sans-serif`;
                    ctx.fillText(`FL${Math.round(midCruise.altitude / 100)}`, x, y - 10 / zoom);
                }
            }

            // Restore zoom/pan transform before drawing fixed axis labels
            ctx.restore();

            // Draw fixed axis frame (not affected by zoom)
            ctx.fillStyle = '#12121a';
            // Cover left axis area
            ctx.fillRect(0, 0, padding, height);
            // Cover bottom axis area
            ctx.fillRect(0, height - paddingBottom, width, paddingBottom);
            // Cover top area
            ctx.fillRect(0, 0, width, padding);
            // Cover right area
            ctx.fillRect(width - padding, 0, padding, height);

            // Draw axis border
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding, padding, width - 2 * padding, height - padding - paddingBottom);

            // Calculate visible range based on zoom and pan
            const centerX = width / 2;
            const centerY = height / 2;

            // Reverse transform to find visible canvas coordinates
            // Screen to canvas: canvasCoord = (screenCoord - center - pan) / zoom + center
            const visibleCanvasLeft = (padding - centerX - profileView.panX) / zoom + centerX;
            const visibleCanvasRight = (width - padding - centerX - profileView.panX) / zoom + centerX;
            const visibleCanvasTop = (padding - centerY - profileView.panY) / zoom + centerY;
            const visibleCanvasBottom = (height - paddingBottom - centerY - profileView.panY) / zoom + centerY;

            // Convert canvas Y to altitude (Y increases downward, altitude increases upward)
            const canvasToAlt = (canvasY) => {
                const normalized = (height - paddingBottom - canvasY) / (height - padding - paddingBottom);
                return normalized * 40000;
            };

            // Convert canvas X to distance
            const canvasToDist = (canvasX) => {
                const normalized = (canvasX - padding) / (width - 2 * padding);
                return normalized * distance;
            };

            // Visible altitude and distance ranges
            const visibleAltMin = Math.max(0, canvasToAlt(visibleCanvasBottom));
            const visibleAltMax = Math.min(40000, canvasToAlt(visibleCanvasTop));
            const visibleDistMin = Math.max(0, canvasToDist(visibleCanvasLeft));
            const visibleDistMax = Math.min(distance, canvasToDist(visibleCanvasRight));

            // Y-axis labels (altitude) - only visible range with collision detection
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';

            // Start from first label at or below visible min
            const firstAlt = Math.floor(visibleAltMin / altStep) * altStep;
            let lastAltLabelY = Infinity; // Track last drawn label position
            for (let alt = firstAlt; alt <= visibleAltMax + altStep; alt += altStep) {
                if (alt < 0 || alt > 40000) continue;

                // Calculate screen position for this altitude
                const canvasY = height - paddingBottom - (alt / 40000) * (height - padding - paddingBottom);
                const screenY = (canvasY - centerY) * zoom + centerY + profileView.panY;

                // Only draw if on screen (in the axis area) AND not overlapping previous label
                if (screenY >= padding - 5 && screenY <= height - paddingBottom + 5) {
                    // Check for overlap with previous label (need at least 18px spacing)
                    if (lastAltLabelY - screenY >= 18) {
                        const label = alt >= 1000 ? `${alt/1000}k` : `${alt}`;
                        ctx.fillText(label, padding - 5, screenY + 3);
                        lastAltLabelY = screenY;
                    }
                    // Always draw tick mark
                    ctx.beginPath();
                    ctx.moveTo(padding - 3, screenY);
                    ctx.lineTo(padding, screenY);
                    ctx.stroke();
                }
            }

            // X-axis labels (distance) - only visible range with collision detection
            ctx.textAlign = 'center';

            // Start from first label at or below visible min
            const firstDist = Math.floor(visibleDistMin / distStep) * distStep;
            let lastDistLabelX = -Infinity; // Track last drawn label position
            for (let distNM = firstDist; distNM <= visibleDistMax + distStep; distNM += distStep) {
                if (distNM < 0 || distNM > distance) continue;

                // Calculate screen position for this distance
                const canvasX = padding + (distNM / distance) * (width - 2 * padding);
                const screenX = (canvasX - centerX) * zoom + centerX + profileView.panX;

                // Only draw if on screen (in the axis area) AND not overlapping previous label
                if (screenX >= padding - 5 && screenX <= width - padding + 5) {
                    // Check for overlap with previous label (need at least 35px spacing)
                    if (screenX - lastDistLabelX >= 35) {
                        ctx.fillText(`${Math.round(distNM)}`, screenX, height - paddingBottom + 15);
                        lastDistLabelX = screenX;
                    }
                    // Always draw tick mark
                    ctx.beginPath();
                    ctx.moveTo(screenX, height - paddingBottom);
                    ctx.lineTo(screenX, height - paddingBottom + 3);
                    ctx.stroke();
                }
            }

            // Station labels
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(depStation.id, padding + 20, height - 8);
            ctx.fillText(destStation.id, width - padding - 20, height - 8);

            // Distance label
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = '11px sans-serif';
            ctx.fillText(`${Math.round(distance)} NM`, width / 2, height - 8);

            // Y-axis title
            ctx.save();
            ctx.translate(12, (height - paddingBottom + padding) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Altitude (ft)', 0, 0);
            ctx.restore();

            // X-axis title
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Distance (NM)', width / 2, height - paddingBottom + 35);

            // Zoom indicator in corner
            if (zoom > 1) {
                ctx.fillStyle = 'rgba(99, 102, 241, 0.8)';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(`${zoom.toFixed(1)}x`, width - padding - 5, padding + 12);
            }

            // Store profile data for hover (use original coordinates, not transformed)
            profileHoverData = {
                width, height, padding, paddingBottom, distance,
                depStation, destStation,
                depMetar, destMetar,
                terrainSeed: (depStation.lat * 1000 + destStation.lon * 100) % 1000,
                zoom: profileView.zoom,
                panX: profileView.panX,
                panY: profileView.panY,
                optimizedPath: optimizedPath, // Store flight path for hover
                terrainProfile: terrainProfile
            };
        }

        // Profile hover data storage
        let profileHoverData = null;

        // Profile hover functionality
        function setupProfileHover() {
            const canvas = document.getElementById('profileCanvas');
            const container = document.getElementById('profileContainer');
            const tooltip = document.getElementById('profileTooltip');
            const crosshair = document.getElementById('profileCrosshair');
            const journeyMarker = document.getElementById('journeyMarker');

            canvas.addEventListener('mousemove', (e) => {
                if (!profileHoverData || !currentRoute.dep || profileView.isDragging) return;

                const rect = canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;

                const { width, height, padding, paddingBottom, distance, depStation, destStation, depMetar, destMetar, optimizedPath, terrainProfile } = profileHoverData;

                // Transform screen coordinates back to canvas coordinates (accounting for zoom/pan)
                const zoom = profileView.zoom;
                const centerX = width / 2;
                const centerY = height / 2;

                // Reverse the transform: screen = (canvas - center) * zoom + center + pan
                // So: canvas = (screen - center - pan) / zoom + center
                const x = (screenX - centerX - profileView.panX) / zoom + centerX;
                const y = (screenY - centerY - profileView.panY) / zoom + centerY;

                // Check if within profile area (in canvas coordinates)
                if (x < padding || x > width - padding || y < padding || y > height - paddingBottom) {
                    tooltip.classList.remove('visible');
                    crosshair.classList.remove('visible');
                    journeyMarker.classList.remove('visible');
                    return;
                }

                // Calculate progress along route (0 to 1)
                const progress = Math.max(0, Math.min(1, (x - padding) / (width - 2 * padding)));
                const distanceAlong = Math.round(progress * distance);

                // Calculate current position
                const lat = depStation.lat + progress * (destStation.lat - depStation.lat);
                const lon = depStation.lon + progress * (destStation.lon - depStation.lon);

                // Calculate altitude at cursor position
                const altitudeRatio = Math.max(0, Math.min(1, 1 - (y - padding) / (height - padding - paddingBottom)));
                const cursorAltitude = Math.round(altitudeRatio * 40000);

                // Find closest point on the journey line
                let isNearJourney = false;
                let journeyWaypoint = null;
                let journeyScreenX = screenX;
                let journeyScreenY = screenY;
                let journeyProgress = progress;

                if (optimizedPath && optimizedPath.length > 0) {
                    // Find the waypoint closest to cursor's X position (progress)
                    let closestIdx = 0;
                    let closestDist = Infinity;

                    for (let i = 0; i < optimizedPath.length; i++) {
                        const wp = optimizedPath[i];
                        const wpProgress = wp.t;
                        const dist = Math.abs(wpProgress - progress);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestIdx = i;
                        }
                    }

                    journeyWaypoint = optimizedPath[closestIdx];
                    journeyProgress = journeyWaypoint.t;

                    // Calculate journey line Y position at this progress
                    const journeyCanvasY = height - padding - (journeyWaypoint.altitude / 40000) * (height - 2 * padding);

                    // Convert journey canvas position to screen position
                    journeyScreenX = (padding + journeyProgress * (width - 2 * padding) - centerX) * zoom + centerX + profileView.panX;
                    journeyScreenY = (journeyCanvasY - centerY) * zoom + centerY + profileView.panY;

                    // Check if cursor is near the journey line (within 30 pixels vertically)
                    const verticalDistance = Math.abs(screenY - journeyScreenY);
                    isNearJourney = verticalDistance < 30;
                }

                // Update crosshair
                crosshair.style.left = `${screenX}px`;
                crosshair.style.top = `${Math.max(0, screenY - 50)}px`;
                crosshair.style.height = `${Math.min(height, 100)}px`;
                crosshair.classList.add('visible');

                // Show/hide journey marker based on proximity
                if (isNearJourney && journeyWaypoint) {
                    journeyMarker.style.left = `${journeyScreenX}px`;
                    journeyMarker.style.top = `${journeyScreenY}px`;
                    journeyMarker.classList.add('visible');

                    // Set phase-based color
                    journeyMarker.classList.remove('climb', 'cruise', 'descent');
                    if (journeyWaypoint.phase) {
                        journeyMarker.classList.add(journeyWaypoint.phase);
                    }
                } else {
                    journeyMarker.classList.remove('visible');
                }

                // Determine which altitude to display
                const displayAltitude = isNearJourney && journeyWaypoint ? journeyWaypoint.altitude : cursorAltitude;
                const displayDistance = isNearJourney && journeyWaypoint ? Math.round(journeyWaypoint.distNM) : distanceAlong;

                // Build tooltip content
                let content = '';

                // Journey-specific info when hovering on the flight path
                if (isNearJourney && journeyWaypoint) {
                    const phaseLabel = journeyWaypoint.phase === 'climb' ? ' Climbing' :
                                      journeyWaypoint.phase === 'descent' ? ' Descending' : ' Cruise';
                    const phaseColor = journeyWaypoint.phase === 'climb' ? '#22c55e' :
                                      journeyWaypoint.phase === 'descent' ? '#f59e0b' : '#6366f1';

                    content += `<div class="profile-tooltip-row" style="border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 6px; margin-bottom: 6px;">
                        <span class="label" style="color:${phaseColor}; font-weight: 600;">${phaseLabel}</span>
                        <span class="value" style="color:${phaseColor}">FL${Math.round(journeyWaypoint.altitude / 100)}</span>
                    </div>`;

                    // Show terrain clearance only when terrain overlay is active
                    if (overlayState.terrain && terrainProfile && terrainProfile.length > 0) {
                        const terrainIdx = Math.floor(journeyWaypoint.t * (terrainProfile.length - 1));
                        const terrainAlt = terrainProfile[terrainIdx] || 0;
                        const clearance = journeyWaypoint.altitude - terrainAlt;
                        content += `<div class="profile-tooltip-row terrain"><span class="label">Terrain Clearance</span><span class="value">${Math.round(clearance).toLocaleString()} ft AGL</span></div>`;
                        content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7"><span class="label">Ground Elev</span><span class="value">${Math.round(terrainAlt).toLocaleString()} ft MSL</span></div>`;
                    }

                    // Show temperature info when temperature overlay is active
                    if (overlayState.temperature) {
                        const depTemp = (depMetar && depMetar.temperature != null) ? depMetar.temperature : 15;
                        const destTemp = (destMetar && destMetar.temperature != null) ? destMetar.temperature : 15;
                        const surfaceTemp = depTemp + progress * (destTemp - depTemp);
                        // Temperature lapse rate: ~2C per 1000ft
                        const tempAtAlt = surfaceTemp - (journeyWaypoint.altitude / 1000) * 2;
                        content += `<div class="profile-tooltip-row temperature"><span class="label">OAT</span><span class="value">${tempAtAlt.toFixed(1)}C</span></div>`;
                        content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7"><span class="label">Surface</span><span class="value">${surfaceTemp.toFixed(1)}C</span></div>`;
                    }

                    // Show route position
                    const routeLat = journeyWaypoint.lat.toFixed(3);
                    const routeLon = journeyWaypoint.lon.toFixed(3);
                    content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7"><span class="label">Position</span><span class="value">${routeLat}, ${routeLon}</span></div>`;
                } else {
                    // Generic cursor position info
                    content += `<div class="profile-tooltip-row" style="opacity:0.6; font-size:10px; margin-bottom:4px">
                        <span class="label">Cursor Position</span>
                        <span class="value">(hover near path for details)</span>
                    </div>`;
                }

                // Terrain info
                if (overlayState.terrain) {
                    let seed = profileHoverData.terrainSeed;
                    for (let i = 0; i < Math.floor(progress * 50); i++) {
                        seed = (seed * 9301 + 49297) % 233280;
                    }
                    const terrainHeight = Math.round(Math.sin(progress * 50 / 5) * 2000 + (seed / 233280) * 1000 + 500);
                    content += `<div class="profile-tooltip-row terrain"><span class="label">Terrain</span><span class="value">${terrainHeight.toLocaleString()} ft</span></div>`;
                }

                // Ceiling info (interpolated)
                if (overlayState.ceiling) {
                    const depCeiling = depMetar?.ceiling || 25000;
                    const destCeiling = destMetar?.ceiling || 25000;
                    const currentCeiling = Math.round(depCeiling + progress * (destCeiling - depCeiling));
                    const depFR = depMetar?.flight_rules || 'VFR';
                    const destFR = destMetar?.flight_rules || 'VFR';
                    const fr = progress < 0.5 ? depFR : destFR;
                    content += `<div class="profile-tooltip-row ceiling"><span class="label">Ceiling</span><span class="value">${currentCeiling >= 25000 ? 'CLR' : currentCeiling.toLocaleString() + ' ft'} (${fr})</span></div>`;
                }

                // Visibility info (interpolated)
                if (overlayState.visibility) {
                    const depVis = depMetar?.visibility || 10;
                    const destVis = destMetar?.visibility || 10;
                    const currentVis = (depVis + progress * (destVis - depVis)).toFixed(1);
                    content += `<div class="profile-tooltip-row visibility"><span class="label">Visibility</span><span class="value">${currentVis} SM</span></div>`;
                }

                // Use the appropriate altitude for airspace checks
                const altitude = displayAltitude;

                // Airspace info - comprehensive detection
                if (overlayState.airspace) {
                  try {
                    // Simplified airspace detection based on altitude
                    const routeLat = depStation?.lat + progress * ((destStation?.lat || 0) - (depStation?.lat || 0));
                    const routeLon = depStation?.lon + progress * ((destStation?.lon || 0) - (depStation?.lon || 0));

                    // Simple point-in-polygon test
                    const pointInPolygon = (lat, lon, polygon) => {
                        if (!polygon || !Array.isArray(polygon)) return false;
                        let inside = false;
                        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                            const xi = polygon[i][0], yi = polygon[i][1];
                            const xj = polygon[j][0], yj = polygon[j][1];
                            if (((yi > lon) !== (yj > lon)) && (lat < (xj - xi) * (lon - yi) / (yj - yi) + xi)) {
                                inside = !inside;
                            }
                        }
                        return inside;
                    };

                    // Point-in-circle test for TFRs
                    const pointInCircle = (lat, lon, center, radius) => {
                        if (!center) return false;
                        const dlat = lat - center[0];
                        const dlon = lon - center[1];
                        const dist = Math.sqrt(dlat * dlat + dlon * dlon);
                        return dist <= radius;
                    };

                    let foundAirspaces = [];

                    // Check Class B airspaces
                    airspaceData.classB.forEach(airspace => {
                        airspace.tiers.forEach((tier, idx) => {
                            if (pointInPolygon(routeLat, routeLon, tier.polygon)) {
                                if (altitude >= tier.floor && altitude <= tier.ceiling) {
                                    foundAirspaces.push({
                                        type: 'Class B',
                                        name: airspace.name,
                                        floor: tier.floor,
                                        ceiling: tier.ceiling,
                                        color: '#3b82f6',
                                        priority: 1,
                                        requirements: 'ATC clearance required'
                                    });
                                }
                            }
                        });
                    });

                    // Check Class C airspaces
                    airspaceData.classC.forEach(airspace => {
                        airspace.tiers.forEach((tier, idx) => {
                            if (pointInPolygon(routeLat, routeLon, tier.polygon)) {
                                if (altitude >= tier.floor && altitude <= tier.ceiling) {
                                    foundAirspaces.push({
                                        type: 'Class C',
                                        name: airspace.name,
                                        floor: tier.floor,
                                        ceiling: tier.ceiling,
                                        color: '#ec4899',
                                        priority: 2,
                                        requirements: 'Radio contact required'
                                    });
                                }
                            }
                        });
                    });

                    // Check Class D airspaces (use polygon, not circle)
                    airspaceData.classD.forEach(zone => {
                        if (zone.polygon && pointInPolygon(routeLat, routeLon, zone.polygon)) {
                            if (altitude <= zone.ceiling) {
                                foundAirspaces.push({
                                    type: 'Class D',
                                    name: zone.name,
                                    floor: 0,
                                    ceiling: zone.ceiling,
                                    color: '#60a5fa',
                                    priority: 3,
                                    requirements: 'Two-way radio'
                                });
                            }
                        }
                    });

                    // Check MOAs
                    airspaceData.moa.forEach(zone => {
                        if (pointInPolygon(routeLat, routeLon, zone.polygon)) {
                            if (altitude >= zone.floor && altitude <= zone.ceiling) {
                                foundAirspaces.push({
                                    type: 'MOA',
                                    name: zone.name,
                                    floor: zone.floor,
                                    ceiling: zone.ceiling,
                                    color: '#d97706',
                                    priority: 4,
                                    requirements: 'Exercise caution'
                                });
                            }
                        }
                    });

                    // Check Restricted areas
                    airspaceData.restricted.forEach(zone => {
                        if (pointInPolygon(routeLat, routeLon, zone.polygon)) {
                            if (altitude <= zone.ceiling) {
                                foundAirspaces.push({
                                    type: 'Restricted',
                                    name: zone.name,
                                    floor: 0,
                                    ceiling: zone.ceiling,
                                    color: '#ef4444',
                                    priority: 0,
                                    requirements: 'Authorization required'
                                });
                            }
                        }
                    });

                    // Check Prohibited areas
                    airspaceData.prohibited.forEach(zone => {
                        if (pointInPolygon(routeLat, routeLon, zone.polygon)) {
                            if (altitude <= zone.ceiling) {
                                foundAirspaces.push({
                                    type: 'Prohibited',
                                    name: zone.name,
                                    floor: 0,
                                    ceiling: zone.ceiling,
                                    color: '#dc2626',
                                    priority: -1,
                                    requirements: 'NO ENTRY'
                                });
                            }
                        }
                    });

                    // Check TFRs
                    airspaceData.tfr.forEach(zone => {
                        if (zone.active && pointInCircle(routeLat, routeLon, zone.center, zone.radius)) {
                            if (altitude <= zone.ceiling) {
                                foundAirspaces.push({
                                    type: 'TFR',
                                    name: zone.name,
                                    floor: 0,
                                    ceiling: zone.ceiling,
                                    color: '#ff0000',
                                    priority: -2,
                                    requirements: 'ACTIVE - Check NOTAMs'
                                });
                            }
                        }
                    });

                    // Sort by priority and build display
                    foundAirspaces.sort((a, b) => a.priority - b.priority);

                    if (foundAirspaces.length > 0) {
                        const primary = foundAirspaces[0];
                        const floorStr = primary.floor === 0 ? 'SFC' : primary.floor.toLocaleString() + ' ft';
                        const ceilStr = primary.ceiling >= 99999 ? 'UNL' : primary.ceiling.toLocaleString() + ' ft';
                        content += `<div class="profile-tooltip-row airspace">
                            <span class="label">Airspace</span>
                            <span class="value" style="color:${primary.color}">${primary.type}</span>
                        </div>`;
                        content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.9">
                            <span class="label">${primary.name.replace(' Class B', '').replace(' Class C', '')}</span>
                            <span class="value">${floorStr} - ${ceilStr}</span>
                        </div>`;
                        content += `<div class="profile-tooltip-row" style="font-size:9px;opacity:0.7">
                            <span class="label">Entry</span>
                            <span class="value">${primary.requirements}</span>
                        </div>`;
                    } else {
                        // Default to Class E or G based on altitude
                        const classType = altitude >= 1200 ? 'Class E' : 'Class G';
                        content += `<div class="profile-tooltip-row airspace">
                            <span class="label">Airspace</span>
                            <span class="value">${classType}</span>
                        </div>`;
                        content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7">
                            <span class="label">Uncontrolled</span>
                            <span class="value">No ATC required</span>
                        </div>`;
                    }
                  } catch (err) {
                    console.error('Airspace detection error:', err);
                    // Airspace detection failed, show default
                    content += `<div class="profile-tooltip-row airspace">
                        <span class="label">Airspace</span>
                        <span class="value">--</span>
                    </div>`;
                  }
                }

                // Icing info
                if (overlayState.icing) {
                    let icingLevel = 'None';
                    if (altitude >= 10000 && altitude <= 25000) {
                        icingLevel = altitude >= 15000 && altitude <= 22000 ? 'Moderate' : 'Light';
                    }
                    content += `<div class="profile-tooltip-row icing"><span class="label">Icing</span><span class="value">${icingLevel}</span></div>`;
                }

                // Turbulence info
                if (overlayState.turbulence) {
                    let turbLevel = 'Smooth';
                    if (Math.abs(altitude - 18000) < 3000) turbLevel = 'Moderate';
                    else if (Math.abs(altitude - 5000) < 2000 || Math.abs(altitude - 35000) < 3000) turbLevel = 'Light';
                    content += `<div class="profile-tooltip-row turbulence"><span class="label">Turbulence</span><span class="value">${turbLevel}</span></div>`;
                }

                // Winds info
                if (overlayState.winds) {
                    const windLevels = [
                        { alt: 3000, speed: 15, dir: 270 },
                        { alt: 9000, speed: 35, dir: 280 },
                        { alt: 18000, speed: 65, dir: 290 },
                        { alt: 30000, speed: 120, dir: 285 },
                        { alt: 39000, speed: 95, dir: 275 }
                    ];
                    // Find closest wind level
                    let closestWind = windLevels[0];
                    windLevels.forEach(w => {
                        if (Math.abs(w.alt - altitude) < Math.abs(closestWind.alt - altitude)) {
                            closestWind = w;
                        }
                    });
                    content += `<div class="profile-tooltip-row winds"><span class="label">Wind</span><span class="value">${closestWind.dir} @ ${closestWind.speed}kt</span></div>`;
                }

                // Clouds info
                if (overlayState.clouds) {
                    let cloudInfo = 'Clear';
                    if (altitude >= 8000 && altitude <= 12000) cloudInfo = 'SCT 080-120';
                    else if (altitude >= 18000 && altitude <= 22000) cloudInfo = 'BKN 180-220';
                    else if (altitude >= 28000 && altitude <= 32000) cloudInfo = 'FEW 280-320';
                    content += `<div class="profile-tooltip-row clouds"><span class="label">Clouds</span><span class="value">${cloudInfo}</span></div>`;
                }

                // Precipitation/Dewpoint info
                if (overlayState.dewpoint) {
                    const depTemp = (depMetar && depMetar.temperature != null) ? depMetar.temperature : 15;
                    const destTemp = (destMetar && destMetar.temperature != null) ? destMetar.temperature : 15;
                    const depDew = (depMetar && depMetar.dewpoint != null) ? depMetar.dewpoint : 10;
                    const destDew = (destMetar && destMetar.dewpoint != null) ? destMetar.dewpoint : 10;
                    const currentTemp = depTemp + progress * (destTemp - depTemp);
                    const currentDew = depDew + progress * (destDew - depDew);
                    const spread = currentTemp - currentDew;

                    let precipRisk = 'None';
                    let precipColor = '#94a3b8';
                    if (spread <= 1) { precipRisk = 'Fog Likely'; precipColor = '#94a3b8'; }
                    else if (spread <= 3) { precipRisk = 'Fog Risk'; precipColor = '#94a3b8'; }
                    else if (spread <= 5 && currentTemp < 5) { precipRisk = 'Precip Possible'; precipColor = '#0ea5e9'; }

                    content += `<div class="profile-tooltip-row precip"><span class="label">Precip Risk</span><span class="value" style="color:${precipColor}">${precipRisk}</span></div>`;
                    content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7"><span class="label">T/Td Spread</span><span class="value">${spread.toFixed(1)}C</span></div>`;
                }

                // Update tooltip
                document.getElementById('tooltipPosition').textContent = `${displayAltitude.toLocaleString()} ft`;
                document.getElementById('tooltipDistance').textContent = `${displayDistance} NM`;
                document.getElementById('tooltipContent').innerHTML = content;

                // Position tooltip (use screen coordinates)
                let tooltipX = screenX + 15;
                let tooltipY = screenY - 10;

                // Keep tooltip in bounds
                const containerRect = canvas.parentElement.getBoundingClientRect();
                if (tooltipX + 200 > containerRect.width) tooltipX = screenX - 200;
                if (tooltipY < 0) tooltipY = 10;

                tooltip.style.left = `${tooltipX}px`;
                tooltip.style.top = `${tooltipY}px`;
                tooltip.classList.add('visible');
            });

            canvas.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
                crosshair.classList.remove('visible');
                journeyMarker.classList.remove('visible');
            });
        }

        // Initialize profile hover and zoom/pan
        setupProfileHover();
        setupProfileZoomPan();

        // Setup resize divider functionality
        function setupResizeDivider() {
            const divider = document.getElementById('resizeDivider');
            const mapContainer = document.querySelector('.map-container');
            const profileSection = document.getElementById('profileSection');

            let isResizing = false;
            let startY = 0;
            let startMapHeight = 0;
            let startProfileHeight = 0;

            divider.addEventListener('mousedown', (e) => {
                isResizing = true;
                startY = e.clientY;
                startMapHeight = mapContainer.offsetHeight;
                startProfileHeight = profileSection.offsetHeight;
                divider.classList.add('dragging');
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaY = e.clientY - startY;
                // Calculate available height (viewport minus header/toolbar)
                const headerHeight = document.querySelector('.app-header')?.offsetHeight || 60;
                const toolbarHeight = document.querySelector('.overlay-toolbar')?.offsetHeight || 50;
                const availableHeight = window.innerHeight - headerHeight - toolbarHeight - 20;
                const maxProfileHeight = availableHeight - 150; // Keep minimum 150px for map

                const newMapHeight = Math.max(150, startMapHeight + deltaY);
                const newProfileHeight = Math.min(maxProfileHeight, Math.max(200, startProfileHeight - deltaY)); // Min 200px to keep canvas legible

                mapContainer.style.height = `${newMapHeight}px`;
                profileSection.style.height = `${newProfileHeight}px`;

                // Invalidate map size after resize
                if (typeof map !== 'undefined') {
                    map.invalidateSize();
                }

                // Redraw profile canvas
                const canvas = document.getElementById('profileCanvas');
                if (canvas && canvas.offsetParent !== null) {
                    canvas.width = canvas.parentElement.clientWidth;
                    canvas.height = canvas.parentElement.clientHeight;
                    if (currentRoute.dep && currentRoute.dest) {
                        drawProfile(currentRoute.dep, currentRoute.dest);
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    divider.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';

                    // Final invalidate
                    if (typeof map !== 'undefined') {
                        map.invalidateSize();
                    }
                }
            });

            // Touch support
            divider.addEventListener('touchstart', (e) => {
                isResizing = true;
                startY = e.touches[0].clientY;
                startMapHeight = mapContainer.offsetHeight;
                startProfileHeight = profileSection.offsetHeight;
                divider.classList.add('dragging');
                e.preventDefault();
            });

            document.addEventListener('touchmove', (e) => {
                if (!isResizing) return;

                const deltaY = e.touches[0].clientY - startY;
                // Calculate available height (viewport minus header/toolbar)
                const headerHeight = document.querySelector('.app-header')?.offsetHeight || 60;
                const toolbarHeight = document.querySelector('.overlay-toolbar')?.offsetHeight || 50;
                const availableHeight = window.innerHeight - headerHeight - toolbarHeight - 20;
                const maxProfileHeight = availableHeight - 150; // Keep minimum 150px for map

                const newMapHeight = Math.max(150, startMapHeight + deltaY);
                const newProfileHeight = Math.min(maxProfileHeight, Math.max(200, startProfileHeight - deltaY)); // Min 200px to keep canvas legible

                mapContainer.style.height = `${newMapHeight}px`;
                profileSection.style.height = `${newProfileHeight}px`;

                if (typeof map !== 'undefined') {
                    map.invalidateSize();
                }
            });

            document.addEventListener('touchend', () => {
                if (isResizing) {
                    isResizing = false;
                    divider.classList.remove('dragging');

                    if (typeof map !== 'undefined') {
                        map.invalidateSize();
                    }

                    // Redraw profile
                    const canvas = document.getElementById('profileCanvas');
                    if (canvas && canvas.offsetParent !== null) {
                        canvas.width = canvas.parentElement.clientWidth;
                        canvas.height = canvas.parentElement.clientHeight;
                        if (currentRoute.dep && currentRoute.dest) {
                            drawProfile(currentRoute.dep, currentRoute.dest);
                        }
                    }
                }
            });
        }

        setupResizeDivider();

        // Initialize
        loadRadarLayer();
        loadCloudsLayer();
        loadMetarStations();

        // Apply initial overlay states
        if (overlayState.terrain) {
            terrainLayer.addTo(map);
        }

        // Refresh radar every 5 minutes
        setInterval(loadRadarLayer, 5 * 60 * 1000);

        // Refresh clouds every 10 minutes
        setInterval(loadCloudsLayer, 10 * 60 * 1000);

        // Refresh METAR every 10 minutes
        setInterval(loadMetarStations, 10 * 60 * 1000);

        // Handle window resize for profile
        window.addEventListener('resize', () => {
            if (document.getElementById('profileContainer').style.display !== 'none') {
                const dep = document.getElementById('departure').value.toUpperCase();
                const dest = document.getElementById('destination').value.toUpperCase();
                if (dep && dest) {
                    loadRoute();
                }
            }
        });
    </script>
</body>
</html>
