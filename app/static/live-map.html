<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Weather Map - SkyEye</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-card: rgba(255, 255, 255, 0.03);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-tertiary: rgba(255, 255, 255, 0.4);
            --border-color: rgba(255, 255, 255, 0.08);
            --accent: #6b7280;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        /* Light Mode - Tesla-style greyscale UI */
        :root.light-mode {
            --bg-primary: #f5f5f5;
            --bg-secondary: #e8e8e8;
            --bg-card: rgba(0, 0, 0, 0.04);
            --text-primary: #1a1a1a;
            --text-secondary: rgba(0, 0, 0, 0.65);
            --text-tertiary: rgba(0, 0, 0, 0.45);
            --border-color: rgba(0, 0, 0, 0.12);
        }

        /* Light mode specific overrides */
        .light-mode .top-navbar {
            background: rgba(245, 245, 245, 0.95);
        }

        .light-mode .sidebar {
            background: rgba(245, 245, 245, 0.98);
        }

        .light-mode .station-info-panel {
            background: rgba(245, 245, 245, 0.98);
        }

        .light-mode .profile-container {
            background: rgba(235, 235, 235, 0.98);
        }

        .light-mode .trip-summary {
            background: rgba(245, 245, 245, 0.95);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .light-mode .trip-summary .trip-summary-mini {
            color: #1a1a1a;
        }

        .light-mode .trip-summary .trip-stat-value,
        .light-mode .trip-summary .trip-airport {
            color: #1a1a1a;
        }

        .light-mode .trip-summary .trip-stat-label {
            color: rgba(0, 0, 0, 0.5);
        }

        .light-mode .overlay-controls {
            background: rgba(245, 245, 245, 0.95);
        }

        .light-mode .search-panel {
            background: rgba(245, 245, 245, 0.98);
        }

        /* Increase contrast on dark map tiles for better visibility */
        .leaflet-tile-pane {
            filter: contrast(1.3) brightness(1.15) saturate(1.1);
        }

        /* Invert Leaflet map tiles for light mode */
        .light-mode .leaflet-tile-pane {
            filter: invert(1) hue-rotate(180deg) saturate(0.4) brightness(0.95) contrast(1.3);
        }

        /* Keep overlay colors vibrant - don't apply greyscale to overlays */
        .light-mode .leaflet-overlay-pane {
            filter: none;
        }

        .light-mode .leaflet-marker-pane {
            filter: none;
        }

        .light-mode .leaflet-control-zoom a {
            background: rgba(245, 245, 245, 0.95) !important;
            color: #1a1a1a !important;
            border-color: rgba(0, 0, 0, 0.15) !important;
        }

        .light-mode .leaflet-control-zoom a:hover {
            background: rgba(230, 230, 230, 0.95) !important;
        }

        /* Theme toggle button */
        .theme-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: transparent;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-primary);
        }

        .theme-toggle:hover {
            background: var(--bg-card);
        }

        .theme-toggle svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
        }

        .theme-toggle .sun-icon {
            display: none;
        }

        .theme-toggle .moon-icon {
            display: block;
        }

        .light-mode .theme-toggle .sun-icon {
            display: block;
        }

        .light-mode .theme-toggle .moon-icon {
            display: none;
        }

        /* Light mode tooltips and popups */
        .light-mode .leaflet-tooltip {
            background: rgba(255, 255, 255, 0.95);
            color: #1a1a1a;
            border-color: rgba(0, 0, 0, 0.15);
        }

        .light-mode .leaflet-popup-content-wrapper {
            background: rgba(255, 255, 255, 0.98);
            color: #1a1a1a;
            border-color: rgba(0, 0, 0, 0.15);
        }

        .light-mode .leaflet-popup-tip {
            background: rgba(255, 255, 255, 0.98);
            border-color: rgba(0, 0, 0, 0.15);
        }

        .light-mode .leaflet-popup.pinned .leaflet-popup-content-wrapper {
            border-color: rgba(59, 130, 246, 0.6);
        }

        .light-mode .leaflet-popup.pinned .leaflet-popup-tip {
            border-color: rgba(59, 130, 246, 0.6);
        }

        .light-mode .leaflet-popup-close-button {
            color: #666 !important;
        }

        .light-mode .leaflet-popup-close-button:hover {
            color: #1a1a1a !important;
        }

        .light-mode .profile-tooltip {
            background: rgba(255, 255, 255, 0.95) !important;
            color: #1a1a1a !important;
            border-color: rgba(0, 0, 0, 0.15) !important;
        }

        .light-mode .profile-tooltip .label {
            color: rgba(0, 0, 0, 0.6) !important;
        }

        .light-mode .overlay-btn {
            background: #ECF0F3;
            color: #4b5563;
            border: none;
            box-shadow:
                6px 6px 12px #D1D9E6,
                -6px -6px 12px #FFFFFF;
        }

        .light-mode .overlay-btn:hover {
            background: #E8ECF0;
            color: #1a1a1a;
            box-shadow:
                8px 8px 16px #D1D9E6,
                -8px -8px 16px #FFFFFF;
        }

        .light-mode .overlay-btn:active {
            background: #ECF0F3;
            box-shadow:
                inset 6px 6px 12px #D1D9E6,
                inset -6px -6px 12px #FFFFFF;
        }

        /* Light mode text fixes for better contrast */
        .light-mode .stat-label,
        .light-mode .profile-stat-label,
        .light-mode .legend-title,
        .light-mode .trip-summary-label,
        .light-mode .trip-section-title,
        .light-mode h1, .light-mode h2, .light-mode h3 {
            color: var(--text-primary);
        }

        .light-mode .stat-value,
        .light-mode .profile-stat-value,
        .light-mode input,
        .light-mode select {
            color: var(--text-primary);
        }

        .light-mode input::placeholder {
            color: var(--text-tertiary);
        }

        .light-mode .overlay-toolbar {
            background: rgba(245, 245, 245, 0.95);
        }

        .light-mode .form-row input,
        .light-mode .form-row select {
            background: rgba(0, 0, 0, 0.04);
            color: #1a1a1a;
            border-color: rgba(0, 0, 0, 0.15);
        }

        .light-mode .form-row input::placeholder {
            color: rgba(0, 0, 0, 0.4);
        }

        .light-mode .btn-secondary {
            background: rgba(0, 0, 0, 0.08);
            color: #1a1a1a;
        }

        .light-mode .btn-secondary:hover {
            background: rgba(0, 0, 0, 0.12);
        }

        /* Light mode profile zoom controls */
        .light-mode .profile-zoom-btn {
            background: #ECF0F3;
            color: #1a1a1a;
            border: none;
            box-shadow:
                4px 4px 8px #D1D9E6,
                -4px -4px 8px #FFFFFF;
        }

        .light-mode .profile-zoom-btn:hover {
            background: #E8ECF0;
            color: #4b5563;
            box-shadow:
                6px 6px 12px #D1D9E6,
                -6px -6px 12px #FFFFFF;
        }

        .light-mode .profile-zoom-btn:active {
            background: #ECF0F3;
            box-shadow:
                inset 4px 4px 8px #D1D9E6,
                inset -4px -4px 8px #FFFFFF;
        }

        .light-mode .profile-zoom-info {
            background: #ECF0F3;
            color: #4b5563;
            border: none;
            box-shadow:
                4px 4px 8px #D1D9E6,
                -4px -4px 8px #FFFFFF;
        }

        .light-mode .zoom-divider {
            background: rgba(0, 0, 0, 0.12);
        }

        .light-mode .profile-controls {
            background: rgba(245, 245, 245, 0.9);
        }

        /* Light mode map journey tooltip */
        .light-mode .map-journey-tooltip {
            background: rgba(255, 255, 255, 0.98);
            border-color: rgba(0, 0, 0, 0.15);
            color: #1a1a1a;
        }

        .light-mode .mjt-header {
            border-bottom-color: rgba(0, 0, 0, 0.1);
            color: #1a1a1a;
        }

        .light-mode .mjt-stat-value {
            color: #1a1a1a;
        }

        .light-mode .mjt-stat-label {
            color: rgba(0, 0, 0, 0.6);
        }

        /* Light mode station info panel */
        .light-mode .station-info {
            background: rgba(255, 255, 255, 0.98);
            border-color: rgba(0, 0, 0, 0.12);
        }

        .light-mode .station-info h2 {
            color: #1a1a1a;
        }

        .light-mode .station-info .close-btn {
            color: rgba(0, 0, 0, 0.5);
        }

        .light-mode .station-info .close-btn:hover {
            color: #1a1a1a;
        }

        .light-mode .station-info .metar-raw {
            background: rgba(0, 0, 0, 0.06);
            color: #1a1a1a;
        }

        .light-mode .station-info .weather-item {
            background: rgba(0, 0, 0, 0.04);
        }

        .light-mode .station-info .weather-item .label {
            color: rgba(0, 0, 0, 0.5);
        }

        .light-mode .station-info .weather-item .value {
            color: #1a1a1a;
        }

        /* Light mode flight rules badges - ensure visibility */
        .light-mode .station-info .flight-rules.vfr {
            background: rgba(34, 197, 94, 0.15);
            color: #16a34a;
        }

        .light-mode .station-info .flight-rules.mvfr {
            background: rgba(59, 130, 246, 0.15);
            color: #2563eb;
        }

        .light-mode .station-info .flight-rules.ifr {
            background: rgba(239, 68, 68, 0.15);
            color: #dc2626;
        }

        .light-mode .station-info .flight-rules.lifr {
            background: rgba(168, 85, 247, 0.15);
            color: #9333ea;
        }

        /* Light mode route profile section */
        .light-mode .profile-header {
            background: rgba(245, 245, 245, 0.98);
            border-color: rgba(0, 0, 0, 0.08);
        }

        .light-mode .profile-header h3 {
            color: #1a1a1a;
        }

        .light-mode .profile-header button {
            background: #ECF0F3;
            color: #4b5563;
            border: none;
            box-shadow:
                6px 6px 12px #D1D9E6,
                -6px -6px 12px #FFFFFF;
        }

        .light-mode .profile-header button:hover {
            background: #E8ECF0;
            color: #1a1a1a;
            box-shadow:
                8px 8px 16px #D1D9E6,
                -8px -8px 16px #FFFFFF;
        }

        .light-mode .profile-header button:active,
        .light-mode .profile-header button.active {
            background: #E0E5EC;
            box-shadow:
                inset 6px 6px 12px #D1D9E6,
                inset -6px -6px 12px #FFFFFF;
        }

        .light-mode .profile-header button:active {
            transform: scale(0.97);
            background: #ECF0F3;
            box-shadow:
                inset 6px 6px 12px #D1D9E6,
                inset -6px -6px 12px #FFFFFF;
        }

        .light-mode .route-input input {
            background: #E0E5EC;
            color: #1a1a1a;
            border: none;
            box-shadow:
                inset 4px 4px 8px #BEC8D4,
                inset -3px -3px 6px #FFFFFF;
        }

        .light-mode .route-input input:focus {
            background: #DBE0E8;
            box-shadow:
                inset 5px 5px 10px #B8C2CE,
                inset -3px -3px 6px #FFFFFF,
                0 0 0 1px rgba(0, 0, 0, 0.15);
        }

        .light-mode .route-input input::selection {
            background: rgba(0, 0, 0, 0.15);
            color: #1a1a1a;
        }

        .light-mode .route-input input::placeholder {
            color: rgba(0, 0, 0, 0.35);
        }

        .light-mode .route-input button {
            background: #ECF0F3;
            color: #1a1a1a;
            border: none;
            box-shadow:
                4px 4px 8px #D1D9E6,
                -4px -4px 8px #FFFFFF;
        }

        .light-mode .route-input button:hover {
            background: #E8ECF0;
            box-shadow:
                5px 5px 10px #D1D9E6,
                -5px -5px 10px #FFFFFF;
        }

        .light-mode .route-input button:active {
            background: #ECF0F3;
            box-shadow:
                inset 4px 4px 8px #D1D9E6,
                inset -4px -4px 8px #FFFFFF;
        }

        .light-mode .waypoint-btn,
        .light-mode .stop-btn,
        .light-mode .snap-btn,
        .light-mode .atc-panel-btn {
            background: #ECF0F3;
            color: #4b5563;
            border: none;
            box-shadow:
                6px 6px 12px #D1D9E6,
                -6px -6px 12px #FFFFFF;
        }

        .light-mode .waypoint-btn:hover,
        .light-mode .stop-btn:hover,
        .light-mode .snap-btn:hover,
        .light-mode .atc-panel-btn:hover {
            background: #E8ECF0;
            color: #1a1a1a;
            box-shadow:
                8px 8px 16px #D1D9E6,
                -8px -8px 16px #FFFFFF;
        }

        .light-mode .waypoint-btn:active,
        .light-mode .stop-btn:active,
        .light-mode .snap-btn:active,
        .light-mode .atc-panel-btn:active {
            background: #ECF0F3;
            box-shadow:
                inset 6px 6px 12px #D1D9E6,
                inset -6px -6px 12px #FFFFFF;
        }

        .light-mode .waypoint-btn.active {
            background: rgba(249, 115, 22, 0.12);
            border: 1px solid rgba(249, 115, 22, 0.4);
            color: #c2410c;
            box-shadow: none;
        }

        .light-mode .stop-btn.active {
            background: rgba(59, 130, 246, 0.12);
            border: 1px solid rgba(59, 130, 246, 0.4);
            color: #2563eb;
            box-shadow: none;
        }

        .light-mode .atc-panel-btn.active {
            background: #E0E5EC;
            border: none;
            color: #0891b2;
            box-shadow:
                inset 6px 6px 12px #D1D9E6,
                inset -6px -6px 12px #FFFFFF;
        }

        /* Light mode ATC Radio Panel */
        .light-mode .atc-radio-panel {
            background: rgba(255, 255, 255, 0.98);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 4px 0 24px rgba(0, 0, 0, 0.1);
        }

        .light-mode .atc-header {
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .light-mode .atc-orca-logo {
            fill: #1a1a1a;
        }

        .light-mode .atc-tailnum {
            color: #1a1a1a;
        }

        .light-mode .atc-frequencies {
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .light-mode .atc-freq-row:hover {
            background: rgba(0, 0, 0, 0.03);
        }

        .light-mode .atc-freq-toggle {
            background: #ECF0F3;
            box-shadow:
                4px 4px 8px #D1D9E6,
                -3px -3px 6px #FFFFFF;
        }

        .light-mode .atc-freq-toggle:hover {
            background: #E8ECF0;
            box-shadow:
                5px 5px 10px #D1D9E6,
                -4px -4px 8px #FFFFFF;
        }

        .light-mode .atc-freq-toggle:active {
            background: #ECF0F3;
            box-shadow:
                inset 3px 3px 6px #D1D9E6,
                inset -3px -3px 6px #FFFFFF;
        }

        .light-mode .atc-freq-row.transmit .atc-freq-toggle {
            background: #E0E5EC;
            box-shadow:
                inset 3px 3px 6px #D1D9E6,
                inset -3px -3px 6px #FFFFFF;
        }

        .light-mode .atc-freq-row.transmit .atc-freq-toggle svg {
            fill: #1a1a1a;
        }

        .light-mode .atc-freq-row .atc-freq-toggle svg {
            fill: #9ca3af;
        }

        .light-mode .atc-freq-row.listening .atc-freq-value {
            color: #16a34a;
        }

        .light-mode .atc-freq-value:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        .light-mode .atc-freq-value.listening {
            background: rgba(34, 197, 94, 0.1);
        }

        .light-mode .listen-indicator svg {
            fill: #16a34a;
        }

        .light-mode .atc-freq-value {
            color: #1a1a1a;
        }

        .light-mode .atc-freq-name {
            color: #4b5563;
        }

        .light-mode .atc-freq-type {
            color: #6b7280;
            background: rgba(0, 0, 0, 0.06);
        }

        .light-mode .atc-transcription {
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .light-mode .atc-transcription-text {
            color: #4b5563;
        }

        .light-mode .atc-waiting {
            color: #9ca3af;
        }

        .light-mode .atc-message {
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .light-mode .atc-station {
            color: #8a7a20;
        }

        .light-mode .atc-msg-text {
            color: #374151;
        }

        .light-mode .atc-buttons {
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .light-mode .atc-btn {
            background: #ECF0F3;
            box-shadow:
                4px 4px 8px #D1D9E6,
                -3px -3px 6px #FFFFFF;
        }

        .light-mode .atc-btn:hover {
            background: #E8ECF0;
            box-shadow:
                5px 5px 10px #D1D9E6,
                -4px -4px 8px #FFFFFF;
        }

        .light-mode .atc-btn:active {
            background: #ECF0F3;
            box-shadow:
                inset 3px 3px 6px #D1D9E6,
                inset -3px -3px 6px #FFFFFF;
        }

        .light-mode .atc-btn svg {
            stroke: #4b5563;
        }

        .light-mode .atc-btn .value {
            color: #1a1a1a;
        }

        .light-mode .atc-fuel-icon svg {
            fill: #6b7280;
        }

        .light-mode .atc-fuel-bar {
            background: rgba(0, 0, 0, 0.08);
        }

        /* Light mode profile placeholder */
        .light-mode .profile-placeholder {
            color: rgba(0, 0, 0, 0.4);
        }

        .light-mode .profile-placeholder svg {
            color: rgba(0, 0, 0, 0.25);
        }

        /* Light mode overlay buttons */
        .light-mode .overlay-btn.active {
            border-width: 1px;
        }

        .light-mode .overlay-btn.terrain.active {
            background: rgba(139, 69, 19, 0.12);
            border-color: rgba(139, 69, 19, 0.4);
            color: #8b4513;
        }

        .light-mode .overlay-btn.clouds.active {
            background: rgba(107, 114, 128, 0.12);
            border-color: rgba(107, 114, 128, 0.4);
            color: #4b5563;
        }

        .light-mode .overlay-btn.ceiling.active {
            background: rgba(234, 179, 8, 0.12);
            border-color: rgba(234, 179, 8, 0.4);
            color: #b45309;
        }

        .light-mode .overlay-btn.visibility.active {
            background: rgba(168, 85, 247, 0.12);
            border-color: rgba(168, 85, 247, 0.4);
            color: #7c3aed;
        }

        .light-mode .overlay-btn.airspace.active {
            background: rgba(236, 72, 153, 0.12);
            border-color: rgba(236, 72, 153, 0.4);
            color: #db2777;
        }

        .light-mode .overlay-btn.icing.active {
            background: rgba(6, 182, 212, 0.12);
            border-color: rgba(6, 182, 212, 0.4);
            color: #0891b2;
        }

        .light-mode .overlay-btn.turbulence.active {
            background: rgba(249, 115, 22, 0.12);
            border-color: rgba(249, 115, 22, 0.4);
            color: #c2410c;
        }

        .light-mode .overlay-btn.winds.active {
            background: rgba(34, 197, 94, 0.12);
            border-color: rgba(34, 197, 94, 0.4);
            color: #16a34a;
        }

        .light-mode .overlay-btn.temp.active {
            background: rgba(239, 68, 68, 0.12);
            border-color: rgba(239, 68, 68, 0.4);
            color: #dc2626;
        }

        .light-mode .overlay-btn.precip.active {
            background: rgba(59, 130, 246, 0.12);
            border-color: rgba(59, 130, 246, 0.4);
            color: #2563eb;
        }

        .light-mode .overlay-btn.radar.active {
            background: rgba(34, 197, 94, 0.12);
            border-color: rgba(34, 197, 94, 0.4);
            color: #16a34a;
        }

        .light-mode .overlay-btn.stations.active {
            background: rgba(107, 114, 128, 0.12);
            border-color: rgba(107, 114, 128, 0.4);
            color: #4b5563;
        }

        .light-mode .overlay-btn.traffic.active {
            background: rgba(0, 150, 200, 0.12);
            border-color: rgba(0, 150, 200, 0.4);
            color: #0096c8;
        }

        .light-mode .overlay-btn.conditions.active {
            background: rgba(234, 179, 8, 0.12);
            border-color: rgba(234, 179, 8, 0.4);
            color: #b45309;
        }

        /* Light mode trip summary */
        .light-mode .trip-summary-mini {
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(0, 0, 0, 0.12);
        }

        .light-mode .trip-mini-stat .stat-value {
            color: #1a1a1a;
        }

        .light-mode .trip-mini-stat .stat-label {
            color: rgba(0, 0, 0, 0.5);
        }

        .light-mode .trip-summary-expanded {
            background: rgba(255, 255, 255, 0.98);
            border-color: rgba(0, 0, 0, 0.12);
        }

        .light-mode .trip-overview-grid .trip-stat {
            background: rgba(0, 0, 0, 0.03);
            border: none;
        }

        .light-mode .trip-overview-grid .trip-stat .trip-stat-value {
            color: #1a1a1a;
        }

        .light-mode .trip-overview-grid .trip-stat .trip-stat-label {
            color: rgba(0, 0, 0, 0.5);
        }

        .light-mode .trip-section {
            background: rgba(0, 0, 0, 0.03);
        }

        .light-mode .trip-section-title {
            color: rgba(0, 0, 0, 0.6);
        }

        .light-mode .trip-phase-info .trip-phase-name {
            color: #1a1a1a;
        }

        .light-mode .trip-phase-info .trip-phase-details {
            color: rgba(0, 0, 0, 0.5);
        }

        .light-mode .trip-phase-distance {
            color: rgba(0, 0, 0, 0.6);
        }

        .light-mode .no-hazards {
            color: rgba(0, 0, 0, 0.4);
        }

        .light-mode .trip-hazard {
            box-shadow:
                4px 4px 10px #D1D9E6,
                -3px -3px 8px #FFFFFF,
                inset 0 1px 1px rgba(255, 255, 255, 0.5);
        }

        .light-mode .trip-hazard.critical {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.12) 0%, rgba(185, 28, 28, 0.08) 100%);
        }
        .light-mode .trip-hazard.warning {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.12) 0%, rgba(180, 83, 9, 0.08) 100%);
        }
        .light-mode .trip-hazard.caution {
            background: linear-gradient(135deg, rgba(234, 179, 8, 0.1) 0%, rgba(161, 98, 7, 0.06) 100%);
        }
        .light-mode .trip-hazard.info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(29, 78, 216, 0.06) 100%);
        }

        .light-mode .trip-hazard-desc {
            color: rgba(0, 0, 0, 0.5);
        }

        /* Light mode custom markers */
        .light-mode .custom-waypoint-marker {
            border-color: rgba(0, 0, 0, 0.2);
        }

        .light-mode .custom-stop-marker {
            border-color: rgba(0, 0, 0, 0.2);
        }

        /* Light mode navigation */
        .light-mode .nav-link {
            color: rgba(0, 0, 0, 0.6);
        }

        .light-mode .nav-link:hover {
            background: rgba(0, 0, 0, 0.05);
            color: #1a1a1a;
        }

        .light-mode .nav-link.active {
            background: rgba(0, 0, 0, 0.08);
            color: #1a1a1a;
        }

        .light-mode .nav-link svg {
            color: rgba(0, 0, 0, 0.5);
        }

        .light-mode .nav-link.active svg {
            color: var(--accent);
        }

        /* Light mode METAR station markers tooltip */
        .light-mode .leaflet-tooltip.metar-tooltip {
            background: rgba(255, 255, 255, 0.98);
            color: #1a1a1a;
            border-color: rgba(0, 0, 0, 0.15);
        }

        /* Light mode hazard tooltips */
        .light-mode .hazard-tooltip {
            background: rgba(255, 255, 255, 0.98) !important;
            color: #1a1a1a !important;
            border-color: rgba(0, 0, 0, 0.15) !important;
        }

        /* Light mode stop/waypoint tooltips */
        .light-mode .stop-tooltip,
        .light-mode .waypoint-tooltip {
            background: rgba(255, 255, 255, 0.98);
            color: #1a1a1a;
            border-color: rgba(0, 0, 0, 0.15);
        }

        /* Light mode resize divider */
        .light-mode .resize-divider {
            background: rgba(0, 0, 0, 0.03);
            border-color: rgba(0, 0, 0, 0.08);
        }

        .light-mode .resize-divider:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        .light-mode .resize-handle {
            background: rgba(0, 0, 0, 0.2);
        }

        .light-mode .resize-divider:hover .resize-handle {
            background: var(--accent);
        }

        /* Light mode profile content */
        .light-mode .profile-content {
            background: rgba(235, 235, 235, 0.98);
        }

        /* Light mode profile canvas container */
        .light-mode .profile-canvas-container {
            background: #e8e8e8;
        }

        /* Light mode legends and info boxes */
        .light-mode .legend,
        .light-mode .info-box {
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(0, 0, 0, 0.12);
            color: #1a1a1a;
        }

        .light-mode .legend-title {
            color: #1a1a1a;
        }

        .light-mode .legend-item {
            color: rgba(0, 0, 0, 0.7);
        }

        /* Light mode map zoom controls already defined, but ensure attribution is readable */
        .light-mode .leaflet-control-attribution {
            background: rgba(255, 255, 255, 0.9) !important;
            color: rgba(0, 0, 0, 0.6) !important;
        }

        .light-mode .leaflet-control-attribution a {
            color: rgba(0, 0, 0, 0.8) !important;
        }

        /* Overlay Loading Bar */
        .overlay-loading-bar {
            position: fixed;
            top: 48px;
            left: 0;
            right: 0;
            height: 3px;
            background: transparent;
            z-index: 9998;
            pointer-events: none;
        }

        .overlay-loading-bar .bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent), #3b82f6, var(--accent));
            background-size: 200% 100%;
            transition: width 0.3s ease-out;
            border-radius: 0 2px 2px 0;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
        }

        .overlay-loading-bar.active .bar-fill {
            animation: loading-shimmer 1.5s linear infinite;
        }

        @keyframes loading-shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .overlay-loading-bar .bar-label {
            position: absolute;
            right: 12px;
            top: 8px;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .overlay-loading-bar.active .bar-label {
            opacity: 1;
        }

        .light-mode .overlay-loading-bar .bar-fill {
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        *:focus {
            outline: 1px solid rgba(255, 255, 255, 0.3);
            outline-offset: 2px;
        }

        *:focus:not(:focus-visible) {
            outline: none;
        }

        *:focus-visible {
            outline: 1px solid rgba(255, 255, 255, 0.4);
            outline-offset: 2px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
        }

        /* Top Navigation Bar */
        .top-navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 24px;
            z-index: 9999;
        }

        .nav-brand {
            position: absolute;
            left: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
        }

        .nav-brand svg.orca-logo {
            width: auto;
            height: 20px;
            color: #ffffff;
        }

        .light-mode .nav-brand svg.orca-logo {
            color: #1a1a1a;
        }

        .nav-links {
            display: flex;
            gap: 4px;
        }

        .theme-toggle {
            position: absolute;
            right: 24px;
        }

        .nav-link {
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            text-decoration: none;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .nav-link.active {
            background: rgba(107, 114, 128, 0.15);
            color: var(--accent);
        }

        .nav-link svg {
            width: 16px;
            height: 16px;
        }

        /* Overlay Toolbar */
        .overlay-toolbar {
            position: fixed;
            top: 48px;
            left: 0;
            right: 0;
            height: 52px;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 0 24px;
            z-index: 9998;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: var(--border-color);
            margin: 0 12px;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            min-height: 100vh;
            width: 100%;
            padding-top: 100px; /* navbar + toolbar */
            margin-left: 0;
            background: var(--bg-secondary);
        }

        /* Map Container */
        .map-container {
            flex: 1 1 auto;
            min-height: 300px;
            position: relative;
        }

        /* Resize Divider */
        .resize-divider {
            height: 8px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .resize-divider:hover {
            background: rgba(107, 114, 128, 0.2);
        }

        .resize-divider.dragging {
            background: rgba(107, 114, 128, 0.3);
        }

        .resize-handle {
            width: 40px;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
        }

        .resize-divider:hover .resize-handle {
            background: var(--accent);
        }

        #map {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-secondary);
        }

        /* Map Controls Overlay */
        .map-controls {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-panel {
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px;
            min-width: 200px;
        }

        .control-panel h3 {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: 10px;
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .layer-toggle:hover {
            opacity: 0.8;
        }

        .layer-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
        }

        .layer-toggle label {
            font-size: 13px;
            color: var(--text-secondary);
            cursor: pointer;
            flex: 1;
        }

        .layer-toggle .layer-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(34, 197, 94, 0.2);
            color: var(--success);
        }

        .layer-toggle .layer-status.loading {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }

        /* Station Info Panel */
        .station-info {
            position: absolute;
            top: 80px; /* Below zoom controls */
            left: 16px;
            z-index: 1000;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            min-width: 280px;
            max-width: 320px;
            display: none;
        }

        .station-info.visible {
            display: block;
        }

        .station-info .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            padding: 4px;
        }

        .station-info h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .station-info .flight-rules {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .station-info .flight-rules.vfr { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .station-info .flight-rules.mvfr { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
        .station-info .flight-rules.ifr { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
        .station-info .flight-rules.lifr { background: rgba(168, 85, 247, 0.2); color: #a855f7; }

        .station-info .metar-raw {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 12px;
            word-break: break-all;
            color: var(--text-secondary);
        }

        .station-info .weather-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .station-info .weather-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 8px;
            border-radius: 6px;
        }

        .station-info .weather-item .label {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
        }

        .station-info .weather-item .value {
            font-size: 14px;
            font-weight: 600;
            margin-top: 2px;
        }

        /* Hide Leaflet attribution and radar timestamp */
        .leaflet-control-attribution,
        .radar-timestamp {
            display: none !important;
        }

        /* ATC Radio Panel - Fixed Left Sidebar */
        .atc-radio-panel {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 10000;
            background: rgba(10, 10, 10, 0.98);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            width: 280px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 4px 0 24px rgba(0, 0, 0, 0.5);
            transform: translateX(0);
            transition: transform 0.3s ease;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        .atc-radio-panel.hidden {
            transform: translateX(-100%);
        }

        /* Push main content when ATC panel is visible */
        body.atc-panel-open .main-container {
            margin-left: 280px;
            width: calc(100% - 280px);
            transition: margin-left 0.3s ease, width 0.3s ease;
        }

        body.atc-panel-open .floating-brand {
            left: 296px;
            transition: left 0.3s ease;
        }

        body.atc-panel-open .overlay-toolbar {
            left: calc(50% + 140px);  /* Shift right by half panel width */
            transition: left 0.3s ease;
        }

        body .main-container,
        body .floating-brand,
        body .overlay-toolbar {
            transition: margin-left 0.3s ease, width 0.3s ease, left 0.3s ease;
        }

        .atc-header {
            padding: 20px 20px 16px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
        }

        .atc-logo-link {
            display: block;
            margin-bottom: 8px;
            transition: opacity 0.15s ease;
        }

        .atc-logo-link:hover {
            opacity: 0.8;
        }

        .atc-orca-logo {
            width: 80px;
            height: auto;
            fill: white;
        }

        .atc-tailnum {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .atc-frequencies {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .atc-freq-row {
            display: flex;
            align-items: center;
            padding: 10px 16px;
            gap: 12px;
            transition: background 0.15s ease;
        }

        .atc-freq-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .atc-freq-toggle {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            border: none;
            background: #2a2a2a;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            box-shadow:
                4px 4px 8px rgba(0, 0, 0, 0.5),
                -2px -2px 4px rgba(255, 255, 255, 0.03);
        }

        .atc-freq-toggle:hover {
            background: #323232;
            box-shadow:
                5px 5px 10px rgba(0, 0, 0, 0.55),
                -3px -3px 6px rgba(255, 255, 255, 0.04);
        }

        .atc-freq-toggle:active {
            background: #252525;
            box-shadow:
                inset 3px 3px 6px rgba(0, 0, 0, 0.5),
                inset -2px -2px 4px rgba(255, 255, 255, 0.03);
        }

        .atc-freq-toggle svg {
            width: 18px;
            height: 18px;
            stroke: var(--text-tertiary);
        }

        .atc-freq-toggle.active {
            background: rgba(34, 197, 94, 0.2);
        }

        .atc-freq-toggle.active svg {
            stroke: #22c55e;
        }

        .atc-freq-toggle.muted svg {
            stroke: var(--text-tertiary);
            opacity: 0.5;
        }

        .atc-freq-info {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .atc-freq-number {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            font-family: 'SF Mono', Monaco, monospace;
        }

        .atc-freq-name {
            text-align: right;
        }

        .atc-freq-name .station {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .atc-freq-name .type {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
        }

        .atc-transcription-wrapper {
            position: relative;
            flex: 1;
            min-height: 120px;
            display: flex;
            flex-direction: column;
        }

        .atc-transcription {
            padding: 16px;
            flex: 1;
            overflow-y: auto;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .atc-scroll-fade {
            position: absolute;
            left: 0;
            right: 0;
            height: 40px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .atc-scroll-fade.top {
            top: 0;
            background: linear-gradient(to bottom, rgba(10, 10, 10, 0.98) 0%, transparent 100%);
        }

        .atc-scroll-fade.bottom {
            bottom: 0;
            background: linear-gradient(to top, rgba(10, 10, 10, 0.98) 0%, transparent 100%);
        }

        .atc-scroll-fade.visible {
            opacity: 1;
        }

        .light-mode .atc-scroll-fade.top {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.98) 0%, transparent 100%);
        }

        .light-mode .atc-scroll-fade.bottom {
            background: linear-gradient(to top, rgba(255, 255, 255, 0.98) 0%, transparent 100%);
        }

        .atc-transcription-text {
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .atc-transcription-text .station-id {
            font-weight: 700;
            color: var(--text-primary);
        }

        .atc-waiting {
            color: var(--text-tertiary);
            font-style: italic;
        }

        .atc-message {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .atc-message:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .atc-station {
            font-weight: 700;
            color: #d4c96a;
            font-size: 12px;
            display: block;
            margin-bottom: 4px;
        }

        .atc-msg-text {
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.4;
        }

        /* Frequency row states */
        .atc-freq-row.transmit .atc-freq-toggle {
            background: #252525;
            box-shadow:
                inset 3px 3px 6px rgba(0, 0, 0, 0.5),
                inset -2px -2px 4px rgba(255, 255, 255, 0.03);
        }

        .atc-freq-row.transmit .atc-freq-toggle svg {
            fill: #ffffff;
        }

        .atc-freq-row .atc-freq-toggle svg {
            fill: rgba(255, 255, 255, 0.4);
        }

        /* Dim non-listening rows */
        .atc-freq-row:not(.listening) .atc-freq-value,
        .atc-freq-row:not(.listening) .atc-freq-name,
        .atc-freq-row:not(.listening) .atc-freq-type {
            opacity: 0.4;
        }

        /* Listening state - highlighted frequency */
        .atc-freq-row.listening .atc-freq-value {
            color: var(--text-primary);
        }

        .atc-freq-value {
            font-size: 18px;
            font-weight: 500;
            color: var(--text-primary);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            min-width: 70px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .atc-freq-value:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .atc-freq-value.listening {
            background: rgba(34, 197, 94, 0.1);
        }

        .listen-indicator {
            display: flex;
            align-items: center;
        }

        .listen-indicator svg {
            width: 14px;
            height: 14px;
            fill: #22c55e;
        }

        .atc-freq-name {
            flex: 1;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .atc-freq-type {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.08);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .atc-buttons {
            display: flex;
            gap: 10px;
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
        }

        .atc-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            border-radius: 12px;
            border: none;
            background: #2a2a2a;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow:
                4px 4px 8px rgba(0, 0, 0, 0.5),
                -2px -2px 4px rgba(255, 255, 255, 0.03);
        }

        .atc-btn:hover {
            background: #323232;
            box-shadow:
                5px 5px 10px rgba(0, 0, 0, 0.55),
                -3px -3px 6px rgba(255, 255, 255, 0.04);
        }

        .atc-btn:active {
            background: #252525;
            box-shadow:
                inset 3px 3px 6px rgba(0, 0, 0, 0.5),
                inset -2px -2px 4px rgba(255, 255, 255, 0.03);
        }

        .atc-btn svg {
            width: 18px;
            height: 18px;
            stroke: var(--text-secondary);
        }

        .atc-btn .value {
            font-size: 18px;
            font-weight: 500;
            color: var(--text-primary);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        .atc-fuel {
            padding: 12px 16px 16px;
            flex-shrink: 0;
        }

        .atc-fuel-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .atc-fuel-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--text-tertiary);
        }

        .atc-fuel-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .atc-fuel-level {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .atc-fuel-level.high {
            background: linear-gradient(90deg, #22c55e, #4ade80);
        }

        .atc-fuel-level.medium {
            background: linear-gradient(90deg, #eab308, #facc15);
        }

        .atc-fuel-level.low {
            background: linear-gradient(90deg, #ef4444, #f87171);
        }

        /* Trip Summary Panel - Floating above profile canvas */
        .trip-summary {
            position: absolute;
            bottom: 12px;
            right: 12px;
            z-index: 1000;
            background: rgba(10, 10, 10, 0.92);
            backdrop-filter: blur(16px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            width: 320px;
            max-height: calc(100% - 120px);
            display: none;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .trip-summary.expanded {
            width: 340px;
            max-height: calc(100% - 120px);
        }

        .trip-summary.visible {
            display: flex;
        }

        .trip-summary-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            gap: 12px;
            flex-shrink: 0;
            cursor: pointer;
            background: transparent;
        }

        .trip-summary-header .trip-summary-mini,
        .trip-summary-header .trip-summary-title,
        .trip-summary-header svg {
            background: transparent;
        }

        .trip-summary.expanded .trip-summary-header {
            border-bottom: 1px solid var(--border-color);
        }

        .trip-summary-header:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .trip-summary-title {
            display: none;
        }

        .trip-summary.expanded .trip-summary-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 16px;
            color: var(--accent-color);
        }

        .trip-close-btn {
            background: none;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
        }

        .trip-close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .trip-close-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.15);
        }

        .trip-summary-mini {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .trip-summary.expanded .trip-summary-mini {
            display: none;
        }

        .trip-summary-mini span {
            white-space: nowrap;
            padding: 0;
            background: transparent;
        }

        .expand-icon {
            transition: transform 0.2s;
            color: var(--text-tertiary);
        }

        .expand-icon {
            transition: transform 0.2s ease;
            color: var(--text-tertiary);
        }

        .trip-summary.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .trip-summary-content {
            display: none;
            flex-direction: column;
            overflow-y: auto;
            max-height: 350px;
        }

        .trip-summary.expanded .trip-summary-content {
            display: flex;
        }

        /* Scrollbar styling for trip summary */
        .trip-summary-content::-webkit-scrollbar {
            width: 6px;
        }

        .trip-summary-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .trip-summary-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .trip-summary-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .trip-overview {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            background: rgba(107, 114, 128, 0.05);
        }

        .trip-route-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .trip-airport {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-color);
            letter-spacing: 1px;
        }

        .trip-route-display svg {
            color: var(--text-tertiary);
        }

        .trip-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .trip-stat {
            background: rgba(255, 255, 255, 0.03);
            padding: 12px 10px;
            border-radius: 6px;
            text-align: center;
            border: none;
        }

        .trip-stat-label {
            font-size: 12px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .trip-stat-value {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .route-overlays-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            margin-top: 12px;
            padding: 12px 16px;
            background: #2a2a2a;
            border: none;
            border-radius: 12px;
            color: #d4c96a;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow:
                6px 6px 12px rgba(0, 0, 0, 0.5),
                -4px -4px 10px rgba(255, 255, 255, 0.03);
        }

        .route-overlays-btn:hover {
            background: #2f2f2f;
            box-shadow:
                7px 7px 14px rgba(0, 0, 0, 0.55),
                -5px -5px 12px rgba(255, 255, 255, 0.04);
        }

        .route-overlays-btn:active {
            background: #252525;
            box-shadow:
                inset 4px 4px 8px rgba(0, 0, 0, 0.5),
                inset -3px -3px 6px rgba(255, 255, 255, 0.03);
        }

        .route-overlays-btn.active {
            background: #252525;
            border: none;
            color: #22c55e;
            box-shadow:
                inset 4px 4px 8px rgba(0, 0, 0, 0.5),
                inset -3px -3px 6px rgba(255, 255, 255, 0.03),
                inset 0 0 0 1px rgba(34, 197, 94, 0.3);
        }

        .route-overlays-btn.active:hover {
            background: #282828;
        }

        .light-mode .route-overlays-btn {
            background: #E0E5EC;
            color: #8a7a20;
            box-shadow:
                6px 6px 12px #C8D0D8,
                -4px -4px 10px #FFFFFF;
        }

        .light-mode .route-overlays-btn:hover {
            background: #E4E9F0;
            color: #1a1a1a;
            box-shadow:
                7px 7px 14px #C8D0D8,
                -5px -5px 12px #FFFFFF;
        }

        .light-mode .route-overlays-btn:active {
            background: #DBE0E8;
            box-shadow:
                inset 4px 4px 8px #BEC8D4,
                inset -3px -3px 6px #FFFFFF;
        }

        .light-mode .route-overlays-btn.active {
            background: #DBE0E8;
            border: none;
            color: #16a34a;
            box-shadow:
                inset 4px 4px 8px #BEC8D4,
                inset -3px -3px 6px #FFFFFF,
                inset 0 0 0 1px rgba(34, 197, 94, 0.3);
        }

        .trip-section {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .trip-section:last-child {
            border-bottom: none;
        }

        .trip-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .trip-section-header.warnings {
            color: #f59e0b;
        }

        .trip-section-header.airways {
            color: #06b6d4;
        }

        .trip-airways {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .airway-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        .airway-tag.jet {
            background: rgba(245, 158, 11, 0.15);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .airway-tag.victor {
            background: rgba(6, 182, 212, 0.15);
            color: #06b6d4;
            border: 1px solid rgba(6, 182, 212, 0.3);
        }

        .airway-tag.t-route {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .airway-tag.q-route {
            background: rgba(139, 92, 246, 0.15);
            color: #8b5cf6;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .airway-tag .distance {
            font-size: 9px;
            opacity: 0.8;
            font-weight: 400;
        }

        .trip-section-header.runways {
            color: #a855f7;
        }

        .trip-runways {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .runway-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 6px;
        }

        .runway-label {
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .runway-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .runway-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            font-weight: 700;
            color: #a855f7;
        }

        .runway-wind {
            font-size: 10px;
            color: var(--text-tertiary);
        }

        .runway-wind .headwind {
            color: #22c55e;
        }

        .runway-wind .tailwind {
            color: #ef4444;
        }

        .runway-wind .crosswind {
            color: #f59e0b;
        }

        .trip-phases {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .trip-phase {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            font-size: 12px;
        }

        .trip-phase-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .trip-phase-icon.climb { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .trip-phase-icon.cruise { background: rgba(107, 114, 128, 0.2); color: #6b7280; }
        .trip-phase-icon.descent { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }

        .trip-phase-info {
            flex: 1;
        }

        .trip-phase-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .trip-phase-details {
            font-size: 10px;
            color: var(--text-tertiary);
            margin-top: 2px;
        }

        .trip-phase-distance {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .trip-hazards {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .trip-hazard {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            border-left: 3px solid;
            box-shadow:
                4px 4px 8px rgba(0, 0, 0, 0.4),
                -2px -2px 4px rgba(255, 255, 255, 0.02),
                inset 0 1px 1px rgba(255, 255, 255, 0.03);
        }

        .trip-hazard.critical {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(185, 28, 28, 0.15) 100%);
            border-left-color: #ef4444;
        }
        .trip-hazard.warning {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2) 0%, rgba(180, 83, 9, 0.15) 100%);
            border-left-color: #f59e0b;
        }
        .trip-hazard.caution {
            background: linear-gradient(135deg, rgba(234, 179, 8, 0.15) 0%, rgba(161, 98, 7, 0.1) 100%);
            border-left-color: #eab308;
        }
        .trip-hazard.info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(29, 78, 216, 0.1) 100%);
            border-left-color: #3b82f6;
        }

        .trip-hazard-icon {
            font-size: 14px;
            flex-shrink: 0;
        }

        .trip-hazard-content {
            flex: 1;
        }

        .trip-hazard-title {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .trip-hazard.critical .trip-hazard-title { color: #ef4444; }
        .trip-hazard.warning .trip-hazard-title { color: #f59e0b; }
        .trip-hazard.caution .trip-hazard-title { color: #eab308; }
        .trip-hazard.info .trip-hazard-title { color: #3b82f6; }

        .trip-hazard-desc {
            font-size: 11px;
            color: var(--text-tertiary);
        }

        .trip-hazard-action {
            font-size: 10px;
            color: #22c55e;
            margin-top: 4px;
            font-weight: 500;
        }

        .no-hazards {
            text-align: center;
            padding: 16px;
            color: var(--text-tertiary);
            font-size: 12px;
            background: rgba(34, 197, 94, 0.1);
            border-radius: 6px;
            border: 1px dashed rgba(34, 197, 94, 0.3);
        }

        .trip-waypoints {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .trip-waypoint {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            font-size: 11px;
        }

        .trip-waypoint-marker {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-color);
            flex-shrink: 0;
        }

        .trip-waypoint-marker.departure { background: #22c55e; }
        .trip-waypoint-marker.destination { background: #ef4444; }
        .trip-waypoint-marker.divert { background: #ef4444; border: 2px solid #fca5a5; }
        .trip-waypoint-marker.enroute { background: #f97316; }
        .trip-waypoint-marker.enroute-airport { background: #22c55e; border: 2px solid #f97316; }
        .trip-waypoint-marker.fuel {
            background: #f59e0b;
            width: 18px;
            height: 18px;
            font-size: 9px;
            font-weight: bold;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #fcd34d;
        }

        .trip-waypoint.fuel-stop {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 6px;
            padding: 8px;
            margin: 4px 0;
        }

        .fuel-stop-label {
            font-size: 9px;
            font-weight: 700;
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 6px;
        }

        .trip-waypoint-info {
            flex: 1;
        }

        .trip-waypoint-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .trip-waypoint-coords {
            font-size: 10px;
            color: var(--text-tertiary);
        }

        .trip-waypoint-distance {
            text-align: right;
            color: var(--text-secondary);
        }

        .trip-fuel-plan {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .fuel-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 12px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }

        .fuel-item:last-child {
            border-bottom: none;
            font-weight: 600;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }

        .fuel-item-label {
            color: var(--text-secondary);
        }

        .fuel-item-value {
            color: var(--text-primary);
        }

        .fuel-item-value.warning {
            color: #f59e0b;
        }

        .fuel-item-value.ok {
            color: #22c55e;
        }

        .fuel-stops-header {
            margin: 10px 0 8px 0;
            padding: 8px;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 6px;
            text-align: center;
        }

        .fuel-stops-alert {
            color: #ef4444;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .fuel-leg {
            padding: 8px;
            margin: 6px 0;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
        }

        .fuel-leg-route {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            font-weight: 600;
            color: #3b82f6;
            margin-bottom: 4px;
        }

        .fuel-leg-details {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .fuel-stop-marker {
            text-align: center;
            font-size: 10px;
            font-weight: 700;
            color: #f59e0b;
            padding: 4px 8px;
            margin: 4px 0;
            background: rgba(245, 158, 11, 0.15);
            border: 1px dashed rgba(245, 158, 11, 0.4);
            border-radius: 4px;
            letter-spacing: 1px;
        }

        .fuel-item.fuel-totals {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
            border-bottom: none;
        }

        /* Flight Automation Panel */
        .flight-automation {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .automation-status {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 12px;
        }

        .automation-status.idle {
            background: rgba(107, 114, 128, 0.1);
            border-color: rgba(107, 114, 128, 0.3);
        }

        .automation-status.active {
            background: rgba(34, 197, 94, 0.1);
            border-color: rgba(34, 197, 94, 0.3);
        }

        .automation-status.takeoff {
            background: rgba(245, 158, 11, 0.1);
            border-color: rgba(245, 158, 11, 0.3);
        }

        .automation-phase {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #3b82f6;
            margin-bottom: 8px;
        }

        .automation-status.idle .automation-phase {
            color: #6b7280;
        }

        .automation-status.active .automation-phase {
            color: #22c55e;
        }

        .automation-status.takeoff .automation-phase {
            color: #f59e0b;
        }

        .automation-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .automation-stat {
            font-size: 11px;
        }

        .automation-stat-label {
            color: var(--text-tertiary);
            margin-bottom: 2px;
        }

        .automation-stat-value {
            color: var(--text-primary);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        .automation-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .automation-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .automation-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .automation-btn.position {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }

        .automation-btn.position:hover:not(:disabled) {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(-1px);
        }

        .automation-btn.upload {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
        }

        .automation-btn.upload:hover:not(:disabled) {
            background: linear-gradient(135deg, #7c3aed, #6d28d9);
            transform: translateY(-1px);
        }

        .automation-btn.takeoff {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }

        .automation-btn.takeoff:hover:not(:disabled) {
            background: linear-gradient(135deg, #16a34a, #15803d);
            transform: translateY(-1px);
        }

        .automation-btn.emergency {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .automation-btn.emergency:hover:not(:disabled) {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .automation-btn.emergency:active:not(:disabled) {
            transform: scale(0.98);
        }

        .automation-btn.release-pilot {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            font-weight: 600;
        }

        .automation-btn.release-pilot:hover:not(:disabled) {
            background: linear-gradient(135deg, #d97706, #b45309);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        .automation-btn.release-pilot:active:not(:disabled) {
            transform: scale(0.98);
        }

        .automation-btn.autopilot {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
            color: white;
            font-weight: 700;
            font-size: 14px;
            padding: 16px 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .automation-btn.autopilot:hover:not(:disabled) {
            background: linear-gradient(135deg, #0891b2, #0e7490);
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(6, 182, 212, 0.4);
        }

        .automation-btn.autopilot:active:not(:disabled) {
            transform: scale(0.98);
        }

        .automation-btn.autopilot.engaged {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            animation: autopilot-pulse 2s ease-in-out infinite;
        }

        .automation-btn.autopilot.positioning {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
        }

        .automation-btn.autopilot.uploading {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        }

        .automation-btn.autopilot.takeoff-active {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        @keyframes autopilot-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.4); }
            50% { box-shadow: 0 0 20px 4px rgba(34, 197, 94, 0.3); }
        }

        .autopilot-phase {
            font-size: 10px;
            font-weight: 500;
            opacity: 0.9;
            margin-top: 2px;
            letter-spacing: 0.5px;
        }

        .automation-btn svg {
            width: 14px;
            height: 14px;
        }

        .automation-row {
            display: flex;
            gap: 8px;
        }

        .automation-row .automation-btn {
            flex: 1;
        }

        /* Icon-only autopilot buttons */
        .automation-btn-icon {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .automation-btn-icon:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .automation-btn-icon svg {
            width: 24px;
            height: 24px;
        }

        .automation-btn-icon.autopilot {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
            color: white;
        }

        .automation-btn-icon.autopilot:hover:not(:disabled) {
            background: linear-gradient(135deg, #0891b2, #0e7490);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(6, 182, 212, 0.5);
        }

        .automation-btn-icon.autopilot.engaged {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            animation: autopilot-icon-pulse 2s ease-in-out infinite;
        }

        .automation-btn-icon.autopilot.positioning {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
        }

        .automation-btn-icon.autopilot.uploading {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        }

        .automation-btn-icon.autopilot.takeoff-active {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        @keyframes autopilot-icon-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.4); }
            50% { box-shadow: 0 0 20px 6px rgba(34, 197, 94, 0.4); }
        }

        .automation-btn-icon.disengage {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .automation-btn-icon.disengage:hover:not(:disabled) {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
        }

        .automation-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 8px;
        }

        /* Floating Autopilot Controls */
        .autopilot-float {
            position: absolute;
            bottom: 16px;
            right: 348px;  /* To the left of trip panel (320px + gap) */
            z-index: 1001;
            display: none;
            flex-direction: row;
            align-items: center;
            gap: 12px;
            pointer-events: auto;
        }

        .autopilot-float.visible {
            display: flex;
        }

        .autopilot-float .automation-btn-icon {
            width: 56px;
            height: 56px;
        }

        .autopilot-float .automation-btn-icon svg {
            width: 28px;
            height: 28px;
        }

        .autopilot-status-float {
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 8px 14px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .autopilot-status-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .autopilot-status-phase {
            font-size: 14px;
            font-weight: 700;
            color: #22c55e;
        }

        .autopilot-status-phase.idle {
            color: var(--text-secondary);
        }

        .autopilot-status-phase.active {
            color: #22c55e;
        }

        .light-mode .autopilot-status-float {
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        }

        .light-mode .autopilot-status-label {
            color: rgba(0, 0, 0, 0.5);
        }

        .light-mode .autopilot-status-phase.idle {
            color: rgba(0, 0, 0, 0.6);
        }

        /* Profile View */
        .profile-container {
            height: 400px;
            min-height: 200px;
            max-height: 80vh;
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow: hidden;
            transition: height 0.3s ease;
        }

        /* Minimized profile - collapse to just header */
        .profile-container.minimized {
            height: auto;
            min-height: auto;
            max-height: none;
        }

        .profile-header {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 10px;
            position: relative;
        }

        .profile-header h3 svg {
            width: 20px;
            height: 20px;
        }

        .profile-header .route-input {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .profile-header input {
            background: #252525;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
            width: 85px;
            text-transform: uppercase;
            text-align: center;
            letter-spacing: 1px;
            outline: none;
            box-shadow:
                inset 4px 4px 8px rgba(0, 0, 0, 0.6),
                inset -3px -3px 6px rgba(255, 255, 255, 0.04),
                inset 0 1px 2px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease;
        }

        .profile-header input:focus {
            box-shadow:
                inset 5px 5px 10px rgba(0, 0, 0, 0.7),
                inset -3px -3px 6px rgba(255, 255, 255, 0.05),
                inset 0 1px 3px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.15);
            background: #222222;
        }

        .profile-header input::selection {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }

        .profile-header input::placeholder {
            color: rgba(255, 255, 255, 0.25);
            font-weight: 400;
        }

        .profile-header button {
            background: #2a2a2a;
            border: none;
            border-radius: 10px;
            padding: 10px 12px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow:
                5px 5px 10px rgba(0, 0, 0, 0.5),
                -3px -3px 8px rgba(255, 255, 255, 0.03);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .profile-header button:hover {
            background: #2f2f2f;
            color: var(--text-primary);
            box-shadow:
                6px 6px 12px rgba(0, 0, 0, 0.55),
                -4px -4px 10px rgba(255, 255, 255, 0.04);
        }

        .profile-header button:active {
            background: #252525;
            box-shadow:
                inset 4px 4px 8px rgba(0, 0, 0, 0.5),
                inset -3px -3px 6px rgba(255, 255, 255, 0.03);
        }

        .profile-header button svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        .profile-header .waypoint-btn {
            background: #2a2a2a;
            color: var(--text-secondary);
        }

        .profile-header .waypoint-btn:hover {
            background: #2f2f2f;
            color: var(--text-primary);
        }

        .profile-header .waypoint-btn.active {
            background: #252525;
            border: none;
            color: #f97316;
            box-shadow:
                inset 4px 4px 8px rgba(0, 0, 0, 0.5),
                inset -3px -3px 6px rgba(255, 255, 255, 0.03),
                inset 0 0 0 1px rgba(249, 115, 22, 0.3);
        }

        .profile-header .snap-btn {
            background: #2a2a2a;
            color: var(--text-secondary);
        }

        .profile-header .snap-btn:hover {
            background: #2f2f2f;
            color: var(--text-primary);
        }

        .profile-header .snap-btn.active {
            background: #252525;
            border: none;
            color: #22c55e;
            box-shadow:
                inset 4px 4px 8px rgba(0, 0, 0, 0.5),
                inset -3px -3px 6px rgba(255, 255, 255, 0.03),
                inset 0 0 0 1px rgba(34, 197, 94, 0.3);
        }

        .profile-header .stop-btn {
            background: #2a2a2a;
            color: var(--text-secondary);
        }

        .profile-header .stop-btn:hover {
            background: #2f2f2f;
            color: var(--text-primary);
        }

        .profile-header .stop-btn.active {
            background: #252525;
            border: none;
            color: #3b82f6;
            box-shadow:
                inset 4px 4px 8px rgba(0, 0, 0, 0.5),
                inset -3px -3px 6px rgba(255, 255, 255, 0.03),
                inset 0 0 0 1px rgba(59, 130, 246, 0.3);
        }

        .profile-header .atc-panel-btn {
            background: #2a2a2a;
            color: var(--text-secondary);
        }

        .profile-header .atc-panel-btn:hover {
            background: #2f2f2f;
            color: var(--text-primary);
        }

        .profile-header .atc-panel-btn.active {
            background: #252525;
            border: none;
            color: #06b6d4;
            box-shadow:
                inset 4px 4px 8px rgba(0, 0, 0, 0.5),
                inset -3px -3px 6px rgba(255, 255, 255, 0.03),
                inset 0 0 0 1px rgba(6, 182, 212, 0.3);
        }

        /* Custom stop markers */
        .custom-stop-marker {
            width: 28px;
            height: 28px;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: transform 0.15s ease;
        }

        .custom-stop-marker:hover {
            transform: scale(1.15);
        }

        .custom-stop-icon {
            background: transparent !important;
        }

        /* Custom waypoint markers */
        .custom-waypoint-marker {
            width: 24px;
            height: 24px;
            background: #f97316;
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: transform 0.15s ease;
        }

        .custom-waypoint-marker:hover {
            transform: scale(1.15);
        }

        .custom-waypoint-marker.snapped {
            background: #22c55e;
        }

        .waypoint-preview-line {
            stroke-dasharray: 8, 8;
        }

        /* Waypoint mode cursor */
        .leaflet-container.waypoint-mode {
            cursor: crosshair !important;
        }

        /* Stop mode cursor */
        .leaflet-container.stop-mode {
            cursor: crosshair !important;
        }

        .profile-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px 12px 12px;
            position: relative;
            min-height: 0;
        }

        .profile-canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #profileCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .header-zoom-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
        }

        .zoom-divider {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 4px;
        }

        .profile-zoom-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow:
                4px 4px 8px rgba(0, 0, 0, 0.5),
                -2px -2px 4px rgba(255, 255, 255, 0.02),
                inset 0 1px 1px rgba(255, 255, 255, 0.04),
                inset 0 -2px 4px rgba(0, 0, 0, 0.4);
        }

        .profile-zoom-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 2.5;
        }

        .profile-zoom-btn:hover {
            background: linear-gradient(180deg, #323232 0%, #222222 100%);
            color: var(--text-primary);
        }

        .profile-zoom-btn:active {
            transform: scale(0.97);
            background: linear-gradient(180deg, #1a1a1a 0%, #121212 100%);
            box-shadow:
                inset 0 3px 8px rgba(0, 0, 0, 0.7),
                inset 0 -1px 2px rgba(255, 255, 255, 0.02);
        }

        .profile-zoom-info {
            padding: 6px 10px;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            box-shadow:
                4px 4px 8px rgba(0, 0, 0, 0.5),
                -2px -2px 4px rgba(255, 255, 255, 0.02),
                inset 0 1px 1px rgba(255, 255, 255, 0.04),
                inset 0 -2px 4px rgba(0, 0, 0, 0.4);
        }

        /* Profile Expand/Minimize Button (prominent) */
        .profile-expand-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border: none;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
            box-shadow:
                4px 4px 8px rgba(0, 0, 0, 0.5),
                -2px -2px 4px rgba(255, 255, 255, 0.02),
                inset 0 1px 1px rgba(255, 255, 255, 0.04),
                inset 0 -2px 4px rgba(0, 0, 0, 0.4);
        }

        .profile-expand-btn svg {
            width: 14px;
            height: 14px;
            stroke-width: 2.5;
            transition: transform 0.2s ease;
        }

        .profile-expand-btn:hover {
            background: linear-gradient(180deg, #323232 0%, #222222 100%);
            color: var(--text-primary);
        }

        .profile-expand-btn:active {
            transform: scale(0.97);
        }

        .profile-expand-btn.expanded svg {
            transform: rotate(180deg);
        }

        .profile-expand-btn.expanded {
            background: linear-gradient(180deg, #1a3a1a 0%, #0a2a0a 100%);
            color: #4ade80;
        }

        .light-mode .profile-expand-btn {
            background: #ECF0F3;
            color: #4b5563;
            box-shadow:
                6px 6px 12px #D1D9E6,
                -6px -6px 12px #FFFFFF;
        }

        .light-mode .profile-expand-btn:hover {
            background: #e0e4e8;
            color: #1a1a1a;
        }

        .light-mode .profile-expand-btn.expanded {
            background: #d4edda;
            color: #22c55e;
        }

        /* Profile Toggle Button (in zoom controls) */
        .profile-toggle-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow:
                4px 4px 8px rgba(0, 0, 0, 0.5),
                -2px -2px 4px rgba(255, 255, 255, 0.02),
                inset 0 1px 1px rgba(255, 255, 255, 0.04),
                inset 0 -2px 4px rgba(0, 0, 0, 0.4);
        }

        .profile-toggle-btn svg {
            width: 18px;
            height: 18px;
            stroke-width: 2;
            transition: transform 0.2s ease;
        }

        .profile-toggle-btn:hover {
            background: linear-gradient(180deg, #323232 0%, #222222 100%);
            color: var(--text-primary);
        }

        .profile-toggle-btn:active {
            transform: scale(0.97);
        }

        .profile-toggle-btn.minimized svg {
            transform: rotate(180deg);
        }

        /* Floating Trip Progress Bar */
        .trip-progress-float {
            position: absolute;
            bottom: 20px;  /* Near bottom of map */
            left: 16px;
            z-index: 999;
            display: none;
            flex-direction: column;
            align-items: flex-start;
            gap: 12px;
            pointer-events: none;
        }

        .trip-progress-float.visible {
            display: flex;
        }

        .trip-progress-time {
            font-size: 84px;
            font-weight: 600;
            color: var(--text-primary);
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            letter-spacing: -1px;
            text-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            line-height: 1;
        }

        .trip-progress-bar-container {
            width: 280px;
            height: 6px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            overflow: hidden;
        }

        .trip-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #22c55e 0%, #4ade80 100%);
            border-radius: 2px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .light-mode .trip-progress-float .trip-progress-time {
            color: var(--text-primary);
            text-shadow: 0 1px 4px rgba(255, 255, 255, 0.5);
        }

        .light-mode .trip-progress-bar-container {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Profile Hover Tooltip */
        .profile-tooltip {
            position: absolute;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 11px;
            color: var(--text-primary);
            pointer-events: none;
            z-index: 100;
            min-width: 200px;
            max-width: 280px;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .profile-tooltip.visible {
            display: block;
        }

        .profile-tooltip-header {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            gap: 24px;
        }

        .profile-tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            gap: 16px;
            color: var(--text-secondary);
        }

        .profile-tooltip-row .label {
            color: var(--text-tertiary);
            flex-shrink: 0;
        }

        .profile-tooltip-row .value {
            font-weight: 500;
            text-align: right;
            flex-shrink: 0;
        }

        .profile-tooltip-row.terrain .value { color: #d4a574; }
        .profile-tooltip-row.ceiling .value { color: #3b82f6; }
        .profile-tooltip-row.visibility .value { color: #a855f7; }
        .profile-tooltip-row.airspace .value { color: #ec4899; }
        .profile-tooltip-row.icing .value { color: #06b6d4; }
        .profile-tooltip-row.turbulence .value { color: #f97316; }
        .profile-tooltip-row.winds .value { color: #22c55e; }
        .profile-tooltip-row.clouds .value { color: #94a3b8; }

        .profile-crosshair {
            position: absolute;
            width: 1px;
            background: rgba(255, 255, 255, 0.3);
            pointer-events: none;
            display: none;
        }

        .profile-crosshair.visible {
            display: block;
        }

        .journey-marker {
            position: absolute;
            pointer-events: none;
            display: none;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .journey-marker.visible {
            display: block;
        }

        .journey-marker-dot {
            width: 12px;
            height: 12px;
            background: #6b7280;
            border: 2px solid #ffffff;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(107, 114, 128, 0.5);
            position: relative;
            z-index: 2;
        }

        .journey-marker.climb .journey-marker-dot {
            background: #22c55e;
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.5);
        }

        .journey-marker.descent .journey-marker-dot {
            background: #f59e0b;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.5);
        }

        .journey-marker-pulse {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: rgba(107, 114, 128, 0.3);
            border-radius: 50%;
            animation: pulse 1.5s ease-out infinite;
            z-index: 1;
        }

        .journey-marker.climb .journey-marker-pulse {
            background: rgba(34, 197, 94, 0.3);
        }

        .journey-marker.descent .journey-marker-pulse {
            background: rgba(245, 158, 11, 0.3);
        }

        /* Pinned state for tap-to-pin feature */
        .journey-marker.pinned .journey-marker-dot {
            background: #3b82f6;
            border-color: #ffffff;
            box-shadow: 0 2px 12px rgba(59, 130, 246, 0.6);
            width: 14px;
            height: 14px;
        }

        .journey-marker.pinned .journey-marker-pulse {
            background: rgba(59, 130, 246, 0.4);
            width: 28px;
            height: 28px;
        }

        .profile-tooltip.pinned {
            border-color: rgba(59, 130, 246, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .profile-tooltip.pinned::before {
            content: 'PINNED';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: #3b82f6;
            color: white;
            font-size: 8px;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 3px;
            letter-spacing: 0.5px;
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0.8;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }

        /* Polygon pulse animation for hazard overlays */
        @keyframes polygonPulse {
            0% {
                stroke-width: 2;
                stroke-opacity: 0.8;
            }
            50% {
                stroke-width: 4;
                stroke-opacity: 1;
            }
            100% {
                stroke-width: 2;
                stroke-opacity: 0.8;
            }
        }

        @keyframes polygonGlow {
            0%, 100% {
                filter: drop-shadow(0 0 4px currentColor);
            }
            50% {
                filter: drop-shadow(0 0 12px currentColor);
            }
        }

        .leaflet-overlay-pane path.hazard-pulse {
            animation: polygonPulse 2s ease-in-out infinite, polygonGlow 2s ease-in-out infinite;
        }

        .leaflet-overlay-pane path.icing-pulse {
            animation: polygonPulse 2s ease-in-out infinite;
            filter: drop-shadow(0 0 6px #06b6d4);
        }

        .leaflet-overlay-pane path.turbulence-pulse {
            animation: polygonPulse 1.5s ease-in-out infinite;
            filter: drop-shadow(0 0 6px #f97316);
        }

        .leaflet-overlay-pane path.restricted-pulse {
            animation: polygonPulse 2.5s ease-in-out infinite;
            filter: drop-shadow(0 0 6px #ef4444);
        }

        /* Route pulse animation */
        .leaflet-overlay-pane path.route-pulse {
            pointer-events: none;
        }

        /* Map Journey Marker */
        .map-journey-marker {
            background: none !important;
            border: none !important;
        }

        .map-journey-dot {
            position: relative;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .map-journey-dot-inner {
            width: 14px;
            height: 14px;
            background: #ffffff;
            border: 3px solid #6b7280;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            z-index: 2;
        }

        .map-journey-dot-pulse {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: rgba(107, 114, 128, 0.4);
            border-radius: 50%;
            animation: mapPulse 1.5s ease-out infinite;
            z-index: 1;
        }

        @keyframes mapPulse {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0.6;
            }
            100% {
                transform: translate(-50%, -50%) scale(2.5);
                opacity: 0;
            }
        }

        .map-journey-tooltip-container {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
        }

        .map-journey-tooltip-container::before {
            display: none !important;
        }

        .map-journey-tooltip {
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 100px;
        }

        .mjt-header {
            font-size: 11px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mjt-stats {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .mjt-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .mjt-label {
            font-size: 9px;
            color: var(--text-tertiary);
            text-transform: uppercase;
        }

        .mjt-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .profile-placeholder {
            text-align: center;
            color: var(--text-tertiary);
        }

        .profile-placeholder svg {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
            opacity: 0.3;
        }

        .profile-placeholder p {
            font-size: 13px;
        }

        /* Overlay Buttons */
        .overlay-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 18px;
            min-height: 44px;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            border: none;
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow:
                4px 4px 8px rgba(0, 0, 0, 0.5),
                -2px -2px 4px rgba(255, 255, 255, 0.02),
                inset 0 1px 1px rgba(255, 255, 255, 0.04),
                inset 0 -2px 4px rgba(0, 0, 0, 0.4);
        }

        .overlay-btn:hover {
            background: linear-gradient(180deg, #323232 0%, #222222 100%);
            color: var(--text-primary);
        }

        .overlay-btn.active {
            background: linear-gradient(180deg, #1a1a1a 0%, #141414 100%);
            border: none;
            color: var(--accent);
            box-shadow:
                inset 0 2px 6px rgba(0, 0, 0, 0.6),
                inset 0 -1px 2px rgba(255, 255, 255, 0.03);
        }

        .overlay-btn:active {
            transform: scale(0.97);
            background: linear-gradient(180deg, #1a1a1a 0%, #121212 100%);
            box-shadow:
                inset 0 3px 8px rgba(0, 0, 0, 0.7),
                inset 0 -1px 2px rgba(255, 255, 255, 0.02);
        }

        .overlay-btn svg {
            width: 18px;
            height: 18px;
        }

        .overlay-btn.terrain.active {
            background: rgba(139, 92, 42, 0.3);
            border-color: rgba(139, 92, 42, 0.5);
            color: #d4a574;
        }

        .overlay-btn.clouds.active {
            background: rgba(148, 163, 184, 0.2);
            border-color: rgba(148, 163, 184, 0.4);
            color: #94a3b8;
        }

        .overlay-btn.ceiling.active {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.4);
            color: #3b82f6;
        }

        .overlay-btn.icing.active {
            background: rgba(6, 182, 212, 0.2);
            border-color: rgba(6, 182, 212, 0.4);
            color: #06b6d4;
        }

        .overlay-btn.turbulence.active {
            background: rgba(249, 115, 22, 0.2);
            border-color: rgba(249, 115, 22, 0.4);
            color: #f97316;
        }

        .overlay-btn.winds.active {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.4);
            color: #22c55e;
        }

        .overlay-btn.temperature.active {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
            color: #ef4444;
        }

        .overlay-btn.dewpoint.active {
            background: rgba(14, 165, 233, 0.2);
            border-color: rgba(14, 165, 233, 0.4);
            color: #0ea5e9;
        }

        .overlay-btn.radar.active {
            background: rgba(132, 204, 22, 0.2);
            border-color: rgba(132, 204, 22, 0.4);
            color: #84cc16;
        }

        .overlay-btn.stations.active {
            background: rgba(20, 184, 166, 0.2);
            border-color: rgba(20, 184, 166, 0.4);
            color: #14b8a6;
        }

        .overlay-btn.traffic.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: rgba(0, 212, 255, 0.4);
            color: #00d4ff;
        }

        .traffic-marker {
            transition: transform 0.3s ease;
        }

        /* X-Plane Aircraft Marker */
        .xplane-aircraft-marker {
            background: none !important;
            border: none !important;
        }

        .xplane-aircraft-icon {
            filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.8));
            transition: transform 0.1s ease-out;
        }

        .xplane-aircraft-icon svg path {
            fill: #3b82f6;
        }

        .xplane-aircraft-marker::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: rgba(59, 130, 246, 0.2);
            animation: xplane-pulse 2s ease-out infinite;
        }

        @keyframes xplane-pulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        .xplane-status-dot {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .overlay-toggle.xplane-toggle {
            position: relative;
        }

        .overlay-toggle.xplane-toggle.active {
            background: rgba(0, 255, 0, 0.2);
            border-color: rgba(0, 255, 0, 0.4);
            color: #00ff00;
        }

        .traffic-popup {
            font-size: 12px;
        }

        .traffic-popup .callsign {
            font-weight: 600;
            color: #00d4ff;
        }

        .overlay-btn.visibility.active {
            background: rgba(168, 85, 247, 0.2);
            border-color: rgba(168, 85, 247, 0.4);
            color: #a855f7;
        }

        .overlay-btn.airspace.active {
            background: rgba(236, 72, 153, 0.2);
            border-color: rgba(236, 72, 153, 0.4);
            color: #ec4899;
        }

        .overlay-btn.conditions.active {
            background: rgba(234, 179, 8, 0.2);
            border-color: rgba(234, 179, 8, 0.4);
            color: #eab308;
        }

        .overlay-btn.airways.active {
            background: rgba(6, 182, 212, 0.2);
            border-color: rgba(6, 182, 212, 0.4);
            color: #06b6d4;
        }

        .overlay-btn.runways.active {
            background: rgba(168, 85, 247, 0.2);
            border-color: rgba(168, 85, 247, 0.4);
            color: #a855f7;
        }

        /* Simple Loading Bar */
        .loading-bar-container {
            position: fixed;
            top: 99px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 3px;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            background: rgba(59, 130, 246, 0.15);
            border-radius: 2px;
            overflow: hidden;
            transition: opacity 0.3s;
        }

        .loading-bar-container.active {
            opacity: 1;
        }

        .loading-bar {
            height: 100%;
            width: 0%;
            background: #3b82f6;
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.6), 0 0 16px rgba(59, 130, 246, 0.4);
            transition: width 0.3s ease-out;
            animation: loading-glow 1.5s ease-in-out infinite;
        }

        @keyframes loading-glow {
            0%, 100% {
                box-shadow: 0 0 8px rgba(59, 130, 246, 0.5), 0 0 16px rgba(59, 130, 246, 0.3);
            }
            50% {
                box-shadow: 0 0 12px rgba(59, 130, 246, 0.8), 0 0 24px rgba(59, 130, 246, 0.5);
            }
        }

        /* Legend */
        .map-legend {
            position: absolute;
            bottom: 16px;
            left: 16px;
            z-index: 1000;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px 16px;
        }

        .legend-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: 8px;
        }

        .legend-items {
            display: flex;
            gap: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.vfr { background: #22c55e; }
        .legend-dot.mvfr { background: #3b82f6; }
        .legend-dot.ifr { background: #ef4444; }
        .legend-dot.lifr { background: #a855f7; }

        /* Leaflet Customization */
        .leaflet-control-zoom {
            border: none !important;
            box-shadow: none !important;
            position: fixed !important;
            bottom: 380px !important;
            left: 296px !important;
            top: auto !important;
            margin: 0 !important;
        }

        body.atc-panel-open .leaflet-control-zoom {
            left: 296px !important;
        }

        body:not(.atc-panel-open) .leaflet-control-zoom {
            left: 16px !important;
        }

        .leaflet-control-zoom a {
            background: rgba(10, 10, 10, 0.9) !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color) !important;
            backdrop-filter: blur(20px);
        }

        .leaflet-control-zoom a:hover {
            background: rgba(20, 20, 30, 0.95) !important;
        }

        .leaflet-popup-content-wrapper {
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 14px;
            min-width: 160px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .leaflet-popup-content {
            margin: 14px 16px;
            line-height: 1.5;
        }

        .leaflet-popup-tip {
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid var(--border-color);
        }

        /* Pinned popup state */
        .leaflet-popup.pinned .leaflet-popup-content-wrapper {
            border-color: rgba(59, 130, 246, 0.6);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3), 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .leaflet-popup.pinned .leaflet-popup-tip {
            border-color: rgba(59, 130, 246, 0.6);
        }

        .leaflet-popup.pinned::before {
            content: 'PINNED';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: #3b82f6;
            color: white;
            font-size: 9px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 4px;
            z-index: 1000;
            letter-spacing: 0.5px;
        }

        /* Larger close button for touch */
        .leaflet-popup-close-button {
            font-size: 24px !important;
            width: 32px !important;
            height: 32px !important;
            line-height: 28px !important;
            padding: 0 !important;
            color: var(--text-secondary) !important;
        }

        .leaflet-popup-close-button:hover {
            color: var(--text-primary) !important;
        }

        /* Radar timestamp */
        .radar-timestamp {
            position: absolute;
            bottom: 16px;
            right: 16px;
            z-index: 1000;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .map-controls {
                top: 8px;
                right: 8px;
            }

            .control-panel {
                min-width: 160px;
                padding: 10px;
            }

            .station-info {
                left: 8px;
                right: 8px;
                max-width: none;
            }

            .profile-container {
                height: 200px;
                min-height: 200px;
            }

            .overlay-toolbar {
                flex-wrap: wrap;
                height: auto;
                padding: 8px 12px;
            }

            .toolbar-divider {
                display: none;
            }

            .nav-links {
                display: none;
            }
        }

        /* ============================================
           TOUCH-FRIENDLY MAGNIFIED UI
           Larger buttons, inputs, and interactive elements
           for easier finger/touch interaction
           ============================================ */

        /* Hide the original navbar */
        .top-navbar {
            display: none !important;
        }

        /* Floating brand/logo - top left */
        .floating-brand {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 18px;
            color: var(--text-primary);
            text-decoration: none;
            padding: 10px 16px;
            background: transparent;
            border: none;
            transition: all 0.2s ease;
        }

        .floating-brand:hover {
            transform: scale(1.02);
        }

        .floating-brand svg.orca-logo {
            width: auto;
            height: 22px;
            color: #ffffff;
        }

        .light-mode .floating-brand {
            background: transparent;
        }

        .light-mode .floating-brand:hover {
            background: transparent;
        }

        .light-mode .floating-brand svg.orca-logo {
            color: #1a1a1a;
        }

        /* Floating theme toggle - top right */
        .floating-theme-toggle {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-primary);
        }

        .floating-theme-toggle:hover {
            transform: scale(1.05);
        }

        .floating-theme-toggle:active {
            transform: scale(0.95);
        }

        .floating-theme-toggle svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
        }

        .floating-theme-toggle .sun-icon {
            display: none;
        }

        .floating-theme-toggle .moon-icon {
            display: block;
        }

        .light-mode .floating-theme-toggle .sun-icon {
            display: block;
        }

        .light-mode .floating-theme-toggle .moon-icon {
            display: none;
        }

        .light-mode .floating-theme-toggle {
            background: rgba(245, 245, 245, 0.85);
        }

        .light-mode .floating-theme-toggle:hover {
            background: rgba(245, 245, 245, 0.95);
        }

        /* X-Plane toggle button */
        .xplane-toggle {
            position: fixed;
            top: 16px;
            right: 72px;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 10px;
            background: rgba(26, 26, 26, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .xplane-toggle:hover {
            background: rgba(26, 26, 26, 0.95);
            transform: scale(1.05);
        }

        .xplane-toggle svg {
            width: 18px;
            height: 18px;
        }

        .xplane-toggle .xplane-label {
            display: none;
        }

        .xplane-toggle .xplane-status-dot {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #666;
        }

        .xplane-toggle.active {
            background: rgba(59, 130, 246, 0.15);
            border-color: rgba(59, 130, 246, 0.4);
            color: #3b82f6;
        }

        .xplane-toggle.active svg {
            fill: #3b82f6;
        }

        .light-mode .xplane-toggle {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .light-mode .xplane-toggle:hover {
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .light-mode .xplane-toggle.active {
            background: rgba(59, 130, 246, 0.15);
            border-color: rgba(59, 130, 246, 0.4);
            color: #2563eb;
        }

        .light-mode .xplane-toggle.active svg {
            fill: #2563eb;
        }

        /* Overlay toolbar buttons - icon only, larger touch targets */
        .overlay-btn {
            padding: 12px;
            font-size: 0; /* Hide text */
            min-height: 48px;
            min-width: 48px;
            width: 48px;
            height: 48px;
            gap: 0;
            justify-content: center;
            border-radius: 12px;
        }

        .overlay-btn svg {
            width: 24px;
            height: 24px;
        }

        /* Light mode overlay buttons - must come after default dark styles */
        .light-mode .overlay-btn {
            background: #f5f5f5 !important;
            color: #374151 !important;
            border: 1px solid #e5e7eb !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
        }

        .light-mode .overlay-btn:hover {
            background: #e5e7eb !important;
            color: #111827 !important;
        }

        .light-mode .overlay-btn svg {
            stroke: #374151 !important;
        }

        .light-mode .overlay-btn:hover svg {
            stroke: #111827 !important;
        }

        .light-mode .overlay-btn.active svg {
            stroke: currentColor !important;
        }

        .light-mode .overlay-toolbar {
            background: rgba(255, 255, 255, 0.9) !important;
            border-color: rgba(0, 0, 0, 0.1) !important;
        }

        /* Overlay toolbar - floating over map, single row */
        .overlay-toolbar {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            right: auto;
            height: auto;
            width: auto;
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            gap: 6px;
            padding: 8px;
            flex-wrap: nowrap;
            justify-content: center;
            z-index: 1000;
        }

        .toolbar-section {
            flex-wrap: nowrap;
            gap: 6px;
        }

        /* Main container - no navbar, full height */
        .main-container {
            padding-top: 0;
        }

        /* Map container - flex to fill available space */
        .map-container {
            flex: 1 1 auto;
        }

        /* Leaflet zoom controls - moved down to avoid logo */
        .leaflet-control-zoom {
            margin-top: 80px !important;
        }

        /* Profile header inputs and buttons */
        .profile-header {
            padding: 12px 20px;
        }

        .profile-header input {
            padding: 12px 14px;
            font-size: 14px;
            width: 90px;
            min-height: 48px;
            border-radius: 8px;
        }

        .profile-header button {
            padding: 12px 18px;
            font-size: 14px;
            min-height: 48px;
            border-radius: 8px;
        }

        .profile-header .route-input {
            gap: 10px;
        }

        .profile-header .waypoint-btn,
        .profile-header .stop-btn,
        .profile-header .snap-btn {
            min-height: 48px;
            padding: 12px 16px;
            font-size: 13px;
        }

        /* Profile zoom buttons */
        .profile-zoom-btn {
            width: 44px;
            height: 44px;
            font-size: 20px;
            border-radius: 8px;
        }

        .profile-zoom-info {
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 6px;
        }

        .profile-zoom-controls {
            gap: 6px;
        }

        /* Station info panel - close button */
        .station-info .close-btn {
            padding: 8px;
            min-width: 40px;
            min-height: 40px;
        }

        .station-info .close-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Trip summary close button */
        .trip-close-btn {
            width: 36px;
            height: 36px;
        }

        .trip-close-btn svg {
            width: 18px;
            height: 18px;
        }

        /* Layer toggles / checkboxes */
        .layer-toggle {
            padding: 12px 0;
            min-height: 48px;
        }

        .layer-toggle input[type="checkbox"] {
            width: 24px;
            height: 24px;
        }

        .layer-toggle label {
            font-size: 15px;
        }

        /* Leaflet zoom controls */
        .leaflet-control-zoom a {
            width: 44px !important;
            height: 44px !important;
            line-height: 44px !important;
            font-size: 20px !important;
        }

        /* Control panel in map */
        .control-panel {
            padding: 16px;
            border-radius: 14px;
        }

        .control-panel h3 {
            font-size: 13px;
            margin-bottom: 12px;
        }

        /* Flight rules badge */
        .station-info .flight-rules {
            padding: 6px 12px;
            font-size: 13px;
            border-radius: 6px;
        }

        /* Weather grid items */
        .station-info .weather-item {
            padding: 12px;
            border-radius: 8px;
        }

        .station-info .weather-item .label {
            font-size: 12px;
        }

        .station-info .weather-item .value {
            font-size: 16px;
        }

        /* METAR raw text */
        .station-info .metar-raw {
            padding: 14px;
            font-size: 13px;
            border-radius: 8px;
        }

        /* Station info panel sizing */
        .station-info {
            min-width: 320px;
            max-width: 380px;
            padding: 20px;
            border-radius: 16px;
        }

        .station-info h2 {
            font-size: 20px;
        }

        /* Legend */
        .map-legend {
            padding: 14px 20px;
            border-radius: 14px;
        }

        .legend-title {
            font-size: 13px;
        }

        .legend-item {
            font-size: 14px;
        }

        .legend-dot {
            width: 14px;
            height: 14px;
        }

        /* Loading bar adjustment - at very top */
        .overlay-loading-bar {
            top: 0;
        }

        /* Toolbar divider - hide for icon-only layout */
        .toolbar-divider {
            display: none;
        }

        /* Light mode floating toolbar */
        .light-mode .overlay-toolbar {
            background: rgba(245, 245, 245, 0.85);
        }

        /* Responsive adjustments for touch-friendly sizes */
        @media (max-width: 768px) {
            .floating-brand {
                top: 12px;
                left: 12px;
                padding: 8px 12px;
                font-size: 16px;
            }

            .floating-brand svg.orca-logo {
                height: 18px;
            }

            .floating-theme-toggle {
                top: 12px;
                right: 12px;
                width: 44px;
                height: 44px;
            }

            .overlay-toolbar {
                top: 70px;
                padding: 6px;
                gap: 4px;
            }

            .overlay-btn {
                width: 48px;
                height: 48px;
                min-width: 48px;
                min-height: 48px;
                padding: 12px;
            }

            .overlay-btn svg {
                width: 24px;
                height: 24px;
            }

            .toolbar-section {
                gap: 4px;
            }

            .main-container {
                padding-top: 0;
            }

            .map-container {
                flex: 1 1 auto;
            }

            .leaflet-control-zoom {
                bottom: 360px !important;
            }

            body.atc-panel-open .leaflet-control-zoom {
                left: 236px !important;
            }

            body:not(.atc-panel-open) .leaflet-control-zoom {
                left: 12px !important;
            }

            .profile-header {
                flex-wrap: wrap;
                gap: 10px;
                padding: 10px 16px;
            }

            .profile-header input {
                width: 80px;
                min-height: 44px;
            }

            .profile-header button {
                min-height: 44px;
            }

            /* ATC Radio Panel responsive */
            .atc-radio-panel {
                width: 220px;
            }

            body.atc-panel-open .main-container {
                margin-left: 220px;
                width: calc(100% - 220px);
            }

            body.atc-panel-open .floating-brand {
                left: 232px;
            }

            body.atc-panel-open .overlay-toolbar {
                left: calc(50% + 110px);  /* Shift right by half panel width */
            }

            .atc-freq-row {
                padding: 8px 12px;
                gap: 8px;
            }

            .atc-freq-value {
                font-size: 14px;
            }

            .atc-transcription {
                min-height: 80px;
                max-height: 120px;
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Overlay Loading Bar -->
    <div class="overlay-loading-bar" id="overlayLoadingBar">
        <div class="bar-fill"></div>
        <span class="bar-label" id="loadingLabel">Loading...</span>
    </div>

    <!-- Floating Theme Toggle -->
    <button class="floating-theme-toggle" onclick="toggleTheme()" title="Toggle Light/Dark Mode">
        <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
        </svg>
        <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="5"/>
            <line x1="12" y1="1" x2="12" y2="3"/>
            <line x1="12" y1="21" x2="12" y2="23"/>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
            <line x1="1" y1="12" x2="3" y2="12"/>
            <line x1="21" y1="12" x2="23" y2="12"/>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
        </svg>
    </button>

    <!-- X-Plane Mode Toggle -->
    <button id="xplaneToggle" class="xplane-toggle" onclick="toggleXPlaneMode()" title="Toggle X-Plane Live Mode">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor" stroke="none">
            <path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"/>
        </svg>
        <span class="xplane-label">X-PLANE</span>
        <span class="xplane-status-dot"></span>
    </button>

    <!-- Overlay Toolbar -->
    <div class="overlay-toolbar">
        <div class="toolbar-section">
            <button class="overlay-btn terrain" data-overlay="terrain" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 20l5-10 4 6 5-8 4 12H3z"/>
                </svg>
                Terrain
            </button>
            <button class="overlay-btn clouds" data-overlay="clouds" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 10a4 4 0 0 0-4-4 4 4 0 0 0-4 4H7a3 3 0 0 0 0 6h11a3 3 0 0 0 0-6z"/>
                </svg>
                Clouds
            </button>
            <button class="overlay-btn conditions" data-overlay="conditions" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                    <circle cx="12" cy="12" r="3"/>
                </svg>
                Conditions
            </button>
            <button class="overlay-btn airspace" data-overlay="airspace" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                    <path d="M2 17l10 5 10-5"/>
                    <path d="M2 12l10 5 10-5"/>
                </svg>
                Airspace
            </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="toolbar-section">
            <button class="overlay-btn icing" data-overlay="icing" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M12 2v20M2 12h20M4.93 4.93l14.14 14.14M19.07 4.93L4.93 19.07"/>
                    <path d="M12 2l-2 3M12 2l2 3M12 22l-2-3M12 22l2-3M2 12l3 2M2 12l3-2M22 12l-3 2M22 12l-3-2"/>
                    <path d="M4.93 4.93l2.12 1.41M4.93 4.93l1.41 2.12M19.07 4.93l-2.12 1.41M19.07 4.93l-1.41 2.12M4.93 19.07l2.12-1.41M4.93 19.07l1.41-2.12M19.07 19.07l-2.12-1.41M19.07 19.07l-1.41-2.12"/>
                </svg>
                Icing
            </button>
            <button class="overlay-btn turbulence" data-overlay="turbulence" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M2 12c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/>
                    <path d="M2 8c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/>
                    <path d="M2 16c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/>
                </svg>
                Turbulence
            </button>
            <button class="overlay-btn winds" data-overlay="winds" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"/>
                </svg>
                Winds
            </button>
            <button class="overlay-btn temperature" data-overlay="temperature" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"/>
                </svg>
                Temp
            </button>
            <button class="overlay-btn dewpoint" data-overlay="dewpoint" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/>
                </svg>
                Precip
            </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="toolbar-section">
            <button class="overlay-btn radar" data-overlay="radar" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 2v10l7 7"/>
                </svg>
                Radar
            </button>
            <button class="overlay-btn stations" data-overlay="stations" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="10" r="3"/>
                    <path d="M12 21.7C17.3 17 20 13 20 10a8 8 0 1 0-16 0c0 3 2.7 6.9 8 11.7z"/>
                </svg>
                Stations
            </button>
            <button class="overlay-btn traffic" data-overlay="traffic" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 16v-2l-8-5V3.5a1.5 1.5 0 0 0-3 0V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"/>
                </svg>
                Traffic
            </button>
            <button class="overlay-btn airways" data-overlay="airways" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12h4l3-9 4 18 3-9h4"/>
                </svg>
                Airways
            </button>
            <button class="overlay-btn runways" data-overlay="runways" onclick="toggleOverlay(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="8" y="2" width="8" height="20" rx="1"/>
                    <line x1="12" y1="5" x2="12" y2="7"/>
                    <line x1="12" y1="10" x2="12" y2="12"/>
                    <line x1="12" y1="15" x2="12" y2="17"/>
                </svg>
                Runways
            </button>
        </div>
    </div>

    <!-- Simple Loading Bar -->
    <div class="loading-bar-container" id="loadingBarContainer">
        <div class="loading-bar" id="loadingBar"></div>
    </div>

    <div class="main-container">
        <!-- Map Section -->
        <div class="map-container">
            <div id="map"></div>

            <!-- ATC Radio Panel -->
            <div id="atcRadioPanel" class="atc-radio-panel">
                <div class="atc-header">
                    <a href="/" class="atc-logo-link" title="Back to Weather Dashboard">
                        <svg class="atc-orca-logo" viewBox="0 0 798 257" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M67.8809 234.41C186.564 258.373 307.51 270.119 360.879 234.41C414.248 198.702 779.734 36.4014 796.092 14.7603C812.45 -6.88083 723.078 -6.93654 548.57 29.5108C375.251 65.7097 321.828 80.6187 159.348 125.963L155.986 126.901C-9.12734 172.979 -50.8019 210.448 67.8809 234.41Z"/>
                        </svg>
                    </a>
                    <div class="atc-tailnum">N90210</div>
                </div>
                <div class="atc-frequencies" id="atcFrequencies">
                    <!-- Populated dynamically -->
                </div>
                <div class="atc-transcription-wrapper">
                    <div class="atc-scroll-fade top" id="atcScrollFadeTop"></div>
                    <div class="atc-transcription" id="atcTranscription">
                        <div class="atc-transcription-text" id="atcTranscriptionText">
                            Waiting for route...
                        </div>
                    </div>
                    <div class="atc-scroll-fade bottom" id="atcScrollFadeBottom"></div>
                </div>
                <div class="atc-buttons">
                    <button class="atc-btn" id="atcSquawkBtn" title="Squawk Code">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2a10 10 0 0 1 10 10c0 5.52-4.48 10-10 10S2 17.52 2 12"/>
                            <circle cx="12" cy="12" r="3"/>
                            <path d="M12 2v4M22 12h-4"/>
                        </svg>
                        <span class="value" id="atcSquawkValue">1200</span>
                    </button>
                    <button class="atc-btn" id="atcAltimeterBtn" title="Altimeter Setting">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 19V5M5 12l7-7 7 7"/>
                        </svg>
                        <span class="value" id="atcAltimeterValue">29.92</span>
                    </button>
                </div>
                <div class="atc-fuel">
                    <div class="atc-fuel-container">
                        <div class="atc-fuel-icon">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19.77 7.23l.01-.01-3.72-3.72L15 4.56l2.11 2.11c-.94.36-1.61 1.26-1.61 2.33a2.5 2.5 0 0 0 2.5 2.5c.36 0 .69-.08 1-.21v7.21c0 .55-.45 1-1 1s-1-.45-1-1V14a2 2 0 0 0-2-2h-1V5a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v16h10v-7.5h1.5v5a2.5 2.5 0 0 0 5 0V9c0-.69-.28-1.32-.73-1.77zM12 10H6V5h6v5z"/>
                            </svg>
                        </div>
                        <div class="atc-fuel-bar">
                            <div class="atc-fuel-level high" id="atcFuelLevel" style="width: 75%"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Station Info Panel -->
            <div class="station-info" id="stationInfo">
                <button class="close-btn" onclick="closeStationInfo()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                </button>
                <h2 id="stationName">KJFK</h2>
                <span class="flight-rules vfr" id="stationFlightRules">VFR</span>
                <div class="metar-raw" id="stationMetar">Loading...</div>
                <div class="weather-grid">
                    <div class="weather-item">
                        <div class="label">Wind</div>
                        <div class="value" id="stationWind">--</div>
                    </div>
                    <div class="weather-item">
                        <div class="label">Visibility</div>
                        <div class="value" id="stationVis">--</div>
                    </div>
                    <div class="weather-item">
                        <div class="label">Ceiling</div>
                        <div class="value" id="stationCeiling">--</div>
                    </div>
                    <div class="weather-item">
                        <div class="label">Altimeter</div>
                        <div class="value" id="stationAltimeter">--</div>
                    </div>
                </div>
            </div>

            <!-- Floating Trip Progress (visible when panel minimized) -->
            <div class="trip-progress-float" id="tripProgressFloat">
                <div class="trip-progress-time" id="tripFloatTime">-- hrs</div>
                <div class="trip-progress-bar-container">
                    <div class="trip-progress-bar" id="tripProgressBar"></div>
                </div>
            </div>

            <!-- Floating Autopilot Controls (visible when panel minimized) -->
            <div class="autopilot-float" id="autopilotFloat">
                <div class="autopilot-status-float">
                    <span class="autopilot-status-label">Autopilot</span>
                    <span class="autopilot-status-phase idle" id="autopilotFloatPhase">IDLE</span>
                </div>
                <button class="automation-btn-icon autopilot" id="btnAutopilotFloat" onclick="engageAutopilot()" disabled title="Engage Autopilot">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"/>
                    </svg>
                </button>
                <button class="automation-btn-icon disengage" id="btnDisengageFloat" onclick="disengageAutopilot()" title="Disengage Autopilot">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="15" y1="9" x2="9" y2="15"/>
                        <line x1="9" y1="9" x2="15" y2="15"/>
                    </svg>
                </button>
            </div>

            <!-- Trip Summary Panel -->
            <div class="trip-summary" id="tripSummary">
                <div class="trip-summary-header" onclick="toggleTripSummary()">
                    <div class="trip-summary-title">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="6" cy="19" r="3"/><path d="M9 19h8.5a3.5 3.5 0 0 0 0-7h-11a3.5 3.5 0 0 1 0-7H15"/><circle cx="18" cy="5" r="3"/>
                        </svg>
                        <span>Trip</span>
                    </div>
                    <div class="trip-summary-mini" id="tripSummaryMini">
                        <span id="tripMiniDistance">-- NM</span>
                        <span id="tripMiniTime">-- hrs</span>
                        <span id="tripMiniConditions" style="font-weight: 700;">--%</span>
                    </div>
                    <svg class="expand-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 15 12 9 18 15"/>
                    </svg>
                    <button class="trip-close-btn" onclick="event.stopPropagation(); hideTripSummary()" title="Close">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 6L6 18M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
                <div class="trip-summary-content" id="tripSummaryContent">
                    <div class="trip-overview">
                        <div class="trip-route-display">
                            <span class="trip-airport" id="tripDepAirport">----</span>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                            <span class="trip-airport" id="tripDestAirport">----</span>
                        </div>
                        <div class="trip-stats-grid">
                            <div class="trip-stat">
                                <div class="trip-stat-label">Distance</div>
                                <div class="trip-stat-value" id="tripDistance">-- NM</div>
                            </div>
                            <div class="trip-stat">
                                <div class="trip-stat-label">Est. Time</div>
                                <div class="trip-stat-value" id="tripTime">--:--</div>
                            </div>
                            <div class="trip-stat">
                                <div class="trip-stat-label">Fuel Req.</div>
                                <div class="trip-stat-value" id="tripFuel">-- gal</div>
                            </div>
                            <div class="trip-stat">
                                <div class="trip-stat-label">Conditions</div>
                                <div class="trip-stat-value" id="tripConditions" style="font-weight: 700;">--%</div>
                            </div>
                        </div>
                        <button class="route-overlays-btn" id="routeOverlaysBtn" onclick="toggleRouteOverlays()">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                                <circle cx="12" cy="12" r="3"/>
                            </svg>
                            Show Route Advisories
                        </button>
                    </div>

                    <div class="trip-section">
                        <div class="trip-section-header">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
                            </svg>
                            Flight Phases
                        </div>
                        <div class="trip-phases" id="tripPhases">
                            <!-- Populated dynamically -->
                        </div>
                    </div>

                    <div class="trip-section">
                        <div class="trip-section-header warnings">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                                <line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>
                            </svg>
                            Hazards & Avoidance
                        </div>
                        <div class="trip-hazards" id="tripHazards">
                            <div class="no-hazards">No significant hazards detected</div>
                        </div>
                    </div>

                    <div class="trip-section">
                        <div class="trip-section-header">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/>
                            </svg>
                            Waypoints
                        </div>
                        <div class="trip-waypoints" id="tripWaypoints">
                            <!-- Populated dynamically -->
                        </div>
                    </div>

                    <div class="trip-section" id="tripAirwaysSection" style="display: none;">
                        <div class="trip-section-header airways">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M22 2L2 22M2 2l20 20" stroke-opacity="0.3"/>
                                <circle cx="6" cy="6" r="2"/><circle cx="18" cy="18" r="2"/>
                                <path d="M6 6l12 12"/>
                            </svg>
                            Airways
                        </div>
                        <div class="trip-airways" id="tripAirways">
                            <!-- Populated dynamically -->
                        </div>
                    </div>

                    <div class="trip-section" id="tripRunwaysSection" style="display: none;">
                        <div class="trip-section-header runways">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="8" y="2" width="8" height="20" rx="1"/>
                                <line x1="12" y1="5" x2="12" y2="7"/>
                                <line x1="12" y1="10" x2="12" y2="12"/>
                                <line x1="12" y1="15" x2="12" y2="17"/>
                            </svg>
                            Runways
                        </div>
                        <div class="trip-runways" id="tripRunways">
                            <!-- Populated dynamically -->
                        </div>
                    </div>

                    <div class="trip-section">
                        <div class="trip-section-header">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                            </svg>
                            Fuel Planning
                        </div>
                        <div class="trip-fuel-plan" id="tripFuelPlan">
                            <!-- Populated dynamically -->
                        </div>
                    </div>

                    <div class="trip-section" id="flightAutomationSection">
                        <div class="trip-section-header">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                                <path d="M2 17l10 5 10-5"/>
                                <path d="M2 12l10 5 10-5"/>
                            </svg>
                            Flight Automation
                        </div>
                        <div class="flight-automation">
                            <div class="automation-status idle" id="automationStatus">
                                <div class="automation-phase" id="automationPhase">IDLE</div>
                                <div class="automation-stats">
                                    <div class="automation-stat">
                                        <div class="automation-stat-label">Next Waypoint</div>
                                        <div class="automation-stat-value" id="automationNextWpt">--</div>
                                    </div>
                                    <div class="automation-stat">
                                        <div class="automation-stat-label">Distance</div>
                                        <div class="automation-stat-value" id="automationDistance">-- NM</div>
                                    </div>
                                    <div class="automation-stat">
                                        <div class="automation-stat-label">Target HDG</div>
                                        <div class="automation-stat-value" id="automationTargetHdg">---</div>
                                    </div>
                                    <div class="automation-stat">
                                        <div class="automation-stat-label">Target ALT</div>
                                        <div class="automation-stat-value" id="automationTargetAlt">-----</div>
                                    </div>
                                </div>
                            </div>
                            <div class="automation-buttons">
                                <button class="automation-btn-icon autopilot" id="btnAutopilot" onclick="engageAutopilot()" disabled title="Engage Autopilot">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"/>
                                    </svg>
                                </button>
                                <button class="automation-btn-icon disengage" id="btnDisengage" onclick="disengageAutopilot()" title="Disengage Autopilot">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="10"/>
                                        <line x1="15" y1="9" x2="9" y2="15"/>
                                        <line x1="9" y1="9" x2="15" y2="15"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Radar Timestamp -->
            <div class="radar-timestamp" id="radarTimestamp">
                Radar: Loading...
            </div>
        </div>

        <!-- Resize Divider -->
        <div class="resize-divider" id="resizeDivider">
            <div class="resize-handle"></div>
        </div>

        <!-- Profile View -->
        <div class="profile-container minimized" id="profileSection">
            <div class="profile-header">
                <div class="route-input">
                    <input type="text" id="departure" placeholder="FROM" maxlength="4">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color: var(--text-tertiary)">
                        <path d="M5 12h14M12 5l7 7-7 7"/>
                    </svg>
                    <input type="text" id="destination" placeholder="TO" maxlength="4">
                    <button onclick="loadRoute()" title="Load Route">
                        <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M2.5 19h19v2h-19v-2zm19.57-9.36c-.21-.8-1.04-1.28-1.84-1.06L14.92 10l-6.9-6.43-1.93.51 4.14 7.17-4.97 1.33-1.97-1.54-1.45.39 2.59 4.49s7.71-2.06 16.08-4.3c.79-.21 1.27-1.04 1.05-1.84l-.49-1.94z"/></svg>
                    </button>
                    <button id="waypointModeBtn" class="waypoint-btn" onclick="toggleWaypointMode()" title="Add Waypoints">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>
                    </button>
                    <button id="stopModeBtn" class="stop-btn" onclick="toggleStopMode()" title="Add Stop">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><rect x="9" y="9" width="6" height="6" rx="1"/></svg>
                    </button>
                    <button id="atcPanelBtn" class="atc-panel-btn" onclick="toggleATCPanel()" title="Toggle ATC Radio Panel">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="2" width="6" height="12" rx="3"/><path d="M5 11v1a7 7 0 0 0 14 0v-1"/><line x1="12" y1="19" x2="12" y2="22"/><line x1="8" y1="22" x2="16" y2="22"/></svg>
                    </button>
                    <button id="snapModeBtn" class="snap-btn" onclick="toggleSnapMode()" title="Snap to Airports">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 2v4M12 18v4M2 12h4M18 12h4"/></svg>
                    </button>
                    <!-- Profile Expand/Minimize Button -->
                    <button id="profileExpandBtn" class="profile-expand-btn" onclick="toggleProfileCanvas()" title="Expand Profile" style="display: none;">
                        <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="18 15 12 9 6 15"/>
                        </svg>
                        <span class="expand-label">Profile</span>
                    </button>
                    <div class="header-zoom-controls" id="headerZoomControls" style="display: none;">
                        <div class="zoom-divider"></div>
                        <button class="profile-zoom-btn" onclick="profileZoom(1.5)" title="Zoom In">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                        </button>
                        <button class="profile-zoom-btn" onclick="profileZoom(0.67)" title="Zoom Out">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/></svg>
                        </button>
                        <button class="profile-zoom-btn" onclick="profileResetZoom()" title="Reset Zoom">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        </button>
                        <div class="profile-zoom-info"><span id="profileZoomLevel">1.0x</span></div>
                        <button id="profileToggleBtn" class="profile-toggle-btn" onclick="toggleProfileCanvas()" title="Minimize Profile">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="6 9 12 15 18 9"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
            <div class="profile-content" id="profileContent" style="display: none;">
                <div class="profile-canvas-container" id="profileContainer">
                    <canvas id="profileCanvas"></canvas>
                    <div class="profile-crosshair" id="profileCrosshair"></div>
                    <div class="journey-marker" id="journeyMarker">
                        <div class="journey-marker-dot"></div>
                        <div class="journey-marker-pulse"></div>
                    </div>
                    <div class="profile-tooltip" id="profileTooltip">
                        <div class="profile-tooltip-header">
                            <span id="tooltipPosition">--</span>
                            <span id="tooltipDistance">-- NM</span>
                        </div>
                        <div id="tooltipContent"></div>
                    </div>
                </div>
                <div class="profile-placeholder" id="profilePlaceholder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
                    </svg>
                    <p>Enter departure and destination airports to view weather profile</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Theme toggle functionality
        let isLightMode = localStorage.getItem('theme') === 'light';

        function toggleTheme() {
            isLightMode = !isLightMode;
            document.documentElement.classList.toggle('light-mode', isLightMode);
            localStorage.setItem('theme', isLightMode ? 'light' : 'dark');

            // Redraw profile canvas with new colors if visible
            if (typeof currentRoute !== 'undefined' && currentRoute.dep && currentRoute.dest && !profileView.minimized) {
                drawProfile(currentRoute.dep, currentRoute.dest);
            }
        }

        // Apply saved theme on load
        if (isLightMode) {
            document.documentElement.classList.add('light-mode');
        }

        // ============================================
        // DEPARTURE & ARRIVAL PROCEDURES DATABASE
        // Realistic SID/STAR patterns for major airports
        // ============================================
        const airportProcedures = {
            // Los Angeles International - Ocean departures, multiple arrival corridors
            'KLAX': {
                departures: {
                    // Default westbound ocean departure (ORCKA-style)
                    'default': {
                        name: 'OCEAN DEP',
                        waypoints: [
                            { name: 'LAXDP', lat: 33.9350, lon: -118.5200, alt: 1500, desc: 'Initial climb over ocean' },
                            { name: 'TOREL', lat: 33.9100, lon: -118.6500, alt: 3500, desc: 'Ocean turn point' },
                            { name: 'GAATE', lat: 33.9400, lon: -118.7200, alt: 5000, desc: 'Departure gate' }
                        ]
                    },
                    // Northbound departure (for BUR, SFO, SEA)
                    'north': {
                        name: 'ORCKA DEP',
                        waypoints: [
                            { name: 'LAXDP', lat: 33.9350, lon: -118.5200, alt: 1500, desc: 'Initial climb over ocean' },
                            { name: 'ORCKA', lat: 33.9500, lon: -118.6400, alt: 4000, desc: 'ORCKA intersection' },
                            { name: 'DOTSS', lat: 34.0200, lon: -118.6000, alt: 6000, desc: 'Turn to course' }
                        ]
                    },
                    // Eastbound departure (for PHX, DEN, DFW)
                    'east': {
                        name: 'LAXX DEP',
                        waypoints: [
                            { name: 'LAXDP', lat: 33.9350, lon: -118.5200, alt: 1500, desc: 'Initial climb' },
                            { name: 'SEAL', lat: 33.8800, lon: -118.4000, alt: 3000, desc: 'Seal Beach turn' },
                            { name: 'SLI', lat: 33.7900, lon: -118.0500, alt: 6000, desc: 'SLI VOR' }
                        ]
                    }
                },
                arrivals: {
                    // Default arrival from east
                    'default': {
                        name: 'RIIVR ARR',
                        waypoints: [
                            { name: 'HECTOR', lat: 34.7900, lon: -117.3200, alt: 12000, desc: 'HECTOR arrival gate' },
                            { name: 'RIIVR', lat: 34.1500, lon: -117.6800, alt: 8000, desc: 'RIIVR transition' },
                            { name: 'SEAVU', lat: 33.9800, lon: -118.1500, alt: 4000, desc: 'Final approach' }
                        ]
                    },
                    // Arrival from north
                    'north': {
                        name: 'SADDE ARR',
                        waypoints: [
                            { name: 'SADDE', lat: 34.6500, lon: -118.8500, alt: 10000, desc: 'SADDE fix' },
                            { name: 'SILEX', lat: 34.3200, lon: -118.6800, alt: 7000, desc: 'SILEX descent' },
                            { name: 'KIMMO', lat: 34.0500, lon: -118.5000, alt: 4000, desc: 'Final descent' }
                        ]
                    }
                },
                elevation: 128
            },
            // Burbank Bob Hope Airport
            'KBUR': {
                departures: {
                    'default': {
                        name: 'ELMOO DEP',
                        waypoints: [
                            { name: 'BURDP', lat: 34.2200, lon: -118.3800, alt: 2000, desc: 'Initial climb' },
                            { name: 'ELMOO', lat: 34.3000, lon: -118.4500, alt: 4000, desc: 'ELMOO fix' }
                        ]
                    },
                    'south': {
                        name: 'VNY DEP',
                        waypoints: [
                            { name: 'VNY', lat: 34.2098, lon: -118.4896, alt: 3000, desc: 'Van Nuys VOR' },
                            { name: 'DARTS', lat: 34.0500, lon: -118.4000, alt: 5000, desc: 'DARTS fix' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'CANOGA ARR',
                        waypoints: [
                            { name: 'CANOG', lat: 34.2000, lon: -118.6000, alt: 5000, desc: 'CANOGA fix' },
                            { name: 'BOGET', lat: 34.2100, lon: -118.4500, alt: 3000, desc: 'Base turn' }
                        ]
                    }
                },
                elevation: 778
            },
            // San Francisco International
            'KSFO': {
                departures: {
                    'default': {
                        name: 'SFO DEP',
                        waypoints: [
                            { name: 'SFODP', lat: 37.5800, lon: -122.4500, alt: 2000, desc: 'Initial climb' },
                            { name: 'SSTIK', lat: 37.5000, lon: -122.5500, alt: 4000, desc: 'Over bay' },
                            { name: 'MODIS', lat: 37.4200, lon: -122.6800, alt: 7000, desc: 'Coastal turn' }
                        ]
                    },
                    'east': {
                        name: 'TRUKN DEP',
                        waypoints: [
                            { name: 'SFODP', lat: 37.5800, lon: -122.4500, alt: 2000, desc: 'Initial' },
                            { name: 'TRUKN', lat: 37.6800, lon: -122.1200, alt: 6000, desc: 'TRUKN fix' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'SERFR ARR',
                        waypoints: [
                            { name: 'FAITH', lat: 37.3500, lon: -122.0500, alt: 8000, desc: 'FAITH arrival' },
                            { name: 'MENLO', lat: 37.4500, lon: -122.2000, alt: 5000, desc: 'MENLO transition' },
                            { name: 'ARCHI', lat: 37.5500, lon: -122.3200, alt: 3000, desc: 'Final' }
                        ]
                    }
                },
                elevation: 13
            },
            // San Diego Intl
            'KSAN': {
                departures: {
                    'default': {
                        name: 'PEBLE DEP',
                        waypoints: [
                            { name: 'SANDP', lat: 32.7500, lon: -117.2500, alt: 2000, desc: 'Over bay' },
                            { name: 'PEBLE', lat: 32.7800, lon: -117.3500, alt: 4000, desc: 'PEBLE intersection' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'COMIX ARR',
                        waypoints: [
                            { name: 'COMIX', lat: 32.9500, lon: -117.0500, alt: 6000, desc: 'COMIX fix' },
                            { name: 'VYDDA', lat: 32.8200, lon: -117.1200, alt: 3500, desc: 'VYDDA transition' }
                        ]
                    }
                },
                elevation: 17
            },
            // John F. Kennedy Intl
            'KJFK': {
                departures: {
                    'default': {
                        name: 'JFK DEP',
                        waypoints: [
                            { name: 'JFKDP', lat: 40.6200, lon: -73.8200, alt: 1500, desc: 'Initial climb' },
                            { name: 'SHIPP', lat: 40.5000, lon: -73.9500, alt: 4000, desc: 'SHIPP fix' },
                            { name: 'WAVEY', lat: 40.3500, lon: -73.8500, alt: 7000, desc: 'Oceanic gate' }
                        ]
                    },
                    'west': {
                        name: 'DEEZZ DEP',
                        waypoints: [
                            { name: 'JFKDP', lat: 40.6200, lon: -73.9000, alt: 2000, desc: 'Initial' },
                            { name: 'DEEZZ', lat: 40.8000, lon: -74.2500, alt: 6000, desc: 'DEEZZ' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'CAMRN ARR',
                        waypoints: [
                            { name: 'CAMRN', lat: 40.9500, lon: -73.4500, alt: 8000, desc: 'CAMRN fix' },
                            { name: 'ROBER', lat: 40.7500, lon: -73.6000, alt: 4000, desc: 'ROBER transition' }
                        ]
                    }
                },
                elevation: 13
            },
            // Denver Intl
            'KDEN': {
                departures: {
                    'default': {
                        name: 'PLAINS DEP',
                        waypoints: [
                            { name: 'DENDP', lat: 39.8200, lon: -104.6500, alt: 7500, desc: 'Initial climb' },
                            { name: 'TOMSN', lat: 39.9500, lon: -104.4000, alt: 11000, desc: 'TOMSN fix' }
                        ]
                    },
                    'west': {
                        name: 'ROCKIES DEP',
                        waypoints: [
                            { name: 'DENDP', lat: 39.8200, lon: -104.6500, alt: 7500, desc: 'Initial' },
                            { name: 'FLATI', lat: 39.8000, lon: -105.1000, alt: 12000, desc: 'Foothills climb' },
                            { name: 'BAYLR', lat: 39.7500, lon: -105.4500, alt: 14000, desc: 'Mountain crossing' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'DANDD ARR',
                        waypoints: [
                            { name: 'DANDD', lat: 39.5000, lon: -104.2000, alt: 12000, desc: 'DANDD arrival' },
                            { name: 'SAYGE', lat: 39.6500, lon: -104.4500, alt: 9000, desc: 'SAYGE transition' }
                        ]
                    }
                },
                elevation: 5434
            },
            // Salt Lake City Intl
            'KSLC': {
                departures: {
                    'default': {
                        name: 'SLC DEP',
                        waypoints: [
                            { name: 'SLCDP', lat: 40.7800, lon: -112.0000, alt: 6500, desc: 'Initial climb' },
                            { name: 'MISAN', lat: 40.9000, lon: -112.3000, alt: 9000, desc: 'MISAN fix' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'KRAM ARR',
                        waypoints: [
                            { name: 'KRAM', lat: 40.5000, lon: -111.5000, alt: 11000, desc: 'KRAM arrival' },
                            { name: 'PERKY', lat: 40.6500, lon: -111.8000, alt: 8000, desc: 'PERKY transition' }
                        ]
                    }
                },
                elevation: 4227
            },
            // Phoenix Sky Harbor
            'KPHX': {
                departures: {
                    'default': {
                        name: 'PHX DEP',
                        waypoints: [
                            { name: 'PHXDP', lat: 33.4500, lon: -112.0500, alt: 2500, desc: 'Initial climb' },
                            { name: 'BUZAD', lat: 33.5500, lon: -112.2500, alt: 5000, desc: 'BUZAD fix' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'EAGUL ARR',
                        waypoints: [
                            { name: 'EAGUL', lat: 33.2500, lon: -111.7000, alt: 8000, desc: 'EAGUL arrival' },
                            { name: 'GEELA', lat: 33.3500, lon: -111.9000, alt: 5000, desc: 'GEELA transition' }
                        ]
                    }
                },
                elevation: 1135
            },
            // Seattle-Tacoma Intl
            'KSEA': {
                departures: {
                    'default': {
                        name: 'SEA DEP',
                        waypoints: [
                            { name: 'SEADP', lat: 47.4200, lon: -122.4000, alt: 2000, desc: 'Initial climb' },
                            { name: 'BANGR', lat: 47.5500, lon: -122.5500, alt: 5000, desc: 'BANGR fix' }
                        ]
                    },
                    'east': {
                        name: 'SUMMA DEP',
                        waypoints: [
                            { name: 'SEADP', lat: 47.4200, lon: -122.3000, alt: 2000, desc: 'Initial' },
                            { name: 'SUMMA', lat: 47.4500, lon: -121.8000, alt: 8000, desc: 'Mountain crossing' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'HAWKZ ARR',
                        waypoints: [
                            { name: 'HAWKZ', lat: 47.2000, lon: -122.1500, alt: 8000, desc: 'HAWKZ arrival' },
                            { name: 'ZADON', lat: 47.3500, lon: -122.2500, alt: 4000, desc: 'ZADON transition' }
                        ]
                    }
                },
                elevation: 433
            },
            // Chicago O'Hare
            'KORD': {
                departures: {
                    'default': {
                        name: 'ORD DEP',
                        waypoints: [
                            { name: 'ORDDP', lat: 41.9800, lon: -87.9500, alt: 2000, desc: 'Initial climb' },
                            { name: 'PAITN', lat: 42.0500, lon: -88.2000, alt: 5000, desc: 'PAITN fix' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'TWOLF ARR',
                        waypoints: [
                            { name: 'TWOLF', lat: 41.7500, lon: -87.5000, alt: 8000, desc: 'TWOLF arrival' },
                            { name: 'KRENA', lat: 41.8500, lon: -87.7500, alt: 4000, desc: 'KRENA transition' }
                        ]
                    }
                },
                elevation: 672
            },
            // Palm Springs Intl
            'KPSP': {
                departures: {
                    'default': {
                        name: 'PSP DEP',
                        waypoints: [
                            { name: 'PSPDP', lat: 33.8500, lon: -116.5500, alt: 2000, desc: 'Initial climb' },
                            { name: 'JOTNU', lat: 33.9500, lon: -116.3000, alt: 5000, desc: 'Valley climb' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'ORCKA ARR',
                        waypoints: [
                            { name: 'TIPTK', lat: 33.9000, lon: -117.0000, alt: 7000, desc: 'TIPTK arrival' },
                            { name: 'CIVET', lat: 33.8700, lon: -116.7000, alt: 4000, desc: 'Valley descent' }
                        ]
                    }
                },
                elevation: 477
            },
            // Las Vegas McCarran
            'KLAS': {
                departures: {
                    'default': {
                        name: 'LAS DEP',
                        waypoints: [
                            { name: 'LASDP', lat: 36.0500, lon: -115.2500, alt: 3000, desc: 'Initial climb' },
                            { name: 'CEASR', lat: 36.1500, lon: -115.4000, alt: 6000, desc: 'CEASR fix' }
                        ]
                    }
                },
                arrivals: {
                    'default': {
                        name: 'GRNPA ARR',
                        waypoints: [
                            { name: 'GRNPA', lat: 35.8500, lon: -114.8000, alt: 10000, desc: 'GRNPA arrival' },
                            { name: 'PRFUM', lat: 35.9500, lon: -115.0500, alt: 6000, desc: 'PRFUM transition' }
                        ]
                    }
                },
                elevation: 2181
            }
        };

        // Get departure waypoints for an airport based on destination direction
        function getDepartureWaypoints(depICAO, destLat, destLon, depLat, depLon) {
            const procedures = airportProcedures[depICAO];
            if (!procedures || !procedures.departures) {
                return null;
            }

            // Calculate bearing from departure to destination
            const bearing = calculateInitialBearing(depLat, depLon, destLat, destLon);

            // Select appropriate departure procedure based on bearing
            let selectedProc = null;
            if (bearing >= 315 || bearing < 45) {
                // Northbound
                selectedProc = procedures.departures['north'] || procedures.departures['default'];
            } else if (bearing >= 45 && bearing < 135) {
                // Eastbound
                selectedProc = procedures.departures['east'] || procedures.departures['default'];
            } else if (bearing >= 135 && bearing < 225) {
                // Southbound
                selectedProc = procedures.departures['south'] || procedures.departures['default'];
            } else {
                // Westbound
                selectedProc = procedures.departures['west'] || procedures.departures['default'];
            }

            if (!selectedProc) {
                selectedProc = procedures.departures['default'];
            }

            return selectedProc ? { name: selectedProc.name, waypoints: selectedProc.waypoints } : null;
        }

        // Get arrival waypoints for an airport based on arrival direction
        function getArrivalWaypoints(destICAO, depLat, depLon, destLat, destLon) {
            const procedures = airportProcedures[destICAO];
            if (!procedures || !procedures.arrivals) {
                return null;
            }

            // Calculate bearing from departure to destination (arrival direction is opposite)
            const bearing = calculateInitialBearing(depLat, depLon, destLat, destLon);
            const arrivalFrom = (bearing + 180) % 360; // Direction arrival is coming FROM

            // Select appropriate arrival procedure based on arrival direction
            let selectedProc = null;
            if (arrivalFrom >= 315 || arrivalFrom < 45) {
                selectedProc = procedures.arrivals['north'] || procedures.arrivals['default'];
            } else if (arrivalFrom >= 45 && arrivalFrom < 135) {
                selectedProc = procedures.arrivals['east'] || procedures.arrivals['default'];
            } else if (arrivalFrom >= 135 && arrivalFrom < 225) {
                selectedProc = procedures.arrivals['south'] || procedures.arrivals['default'];
            } else {
                selectedProc = procedures.arrivals['west'] || procedures.arrivals['default'];
            }

            if (!selectedProc) {
                selectedProc = procedures.arrivals['default'];
            }

            return selectedProc ? { name: selectedProc.name, waypoints: selectedProc.waypoints } : null;
        }

        // Calculate initial bearing between two points
        function calculateInitialBearing(lat1, lon1, lat2, lon2) {
            const 1 = lat1 * Math.PI / 180;
            const 2 = lat2 * Math.PI / 180;
            const  = (lon2 - lon1) * Math.PI / 180;

            const y = Math.sin() * Math.cos(2);
            const x = Math.cos(1) * Math.sin(2) - Math.sin(1) * Math.cos(2) * Math.cos();
            const  = Math.atan2(y, x);

            return ( * 180 / Math.PI + 360) % 360;
        }

        // Initialize map centered on CONUS
        const map = L.map('map', {
            zoomControl: true
        }).setView([39.8283, -98.5795], 5);

        // Base layers
        const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; OpenStreetMap, &copy; CARTO',
            maxZoom: 19
        });

        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri',
            maxZoom: 19
        });

        const vfrLayer = L.tileLayer('https://wms.chartbundle.com/tms/1.0.0/sec/{z}/{x}/{y}.png?type=google', {
            attribution: '&copy; ChartBundle',
            maxZoom: 13,
            tms: true
        });

        // Add default base layer
        darkLayer.addTo(map);

        // Invalidate map size multiple times to ensure proper rendering
        // This is necessary because flexbox layout may not be fully calculated immediately
        setTimeout(() => map.invalidateSize(), 100);
        setTimeout(() => map.invalidateSize(), 300);
        setTimeout(() => map.invalidateSize(), 500);
        setTimeout(() => map.invalidateSize(), 1000);
        window.addEventListener('load', () => {
            map.invalidateSize();
            setTimeout(() => map.invalidateSize(), 100);
        });

        // Also invalidate on resize
        window.addEventListener('resize', () => map.invalidateSize());

        // Initialize ATC Radio Panel state from localStorage
        initATCPanel();

        // ============================================
        // Route corridor filtering (must be before overlay functions)
        // ============================================
        let routeOverlaysActive = false;
        const ROUTE_CORRIDOR_NM = 100;
        let currentRoute = { dep: null, dest: null };
        let currentRouteData = null; // Stores full route data including cruise altitude
        let customWaypoints = [];
        let customStops = [];

        function pointInPolygon(lat, lon, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];
                if (((yi > lon) !== (yj > lon)) && (lat < (xj - xi) * (lon - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function getRouteWaypoints() {
            if (!currentRoute || !currentRoute.dep || !currentRoute.dest) return [];
            const waypoints = [];
            waypoints.push({ lat: currentRoute.dep.lat, lon: currentRoute.dep.lon });
            if (customWaypoints && customWaypoints.length > 0) {
                customWaypoints.forEach(wp => waypoints.push({ lat: wp.lat, lon: wp.lon }));
            }
            if (customStops && customStops.length > 0) {
                customStops.forEach(stop => waypoints.push({ lat: stop.lat, lon: stop.lon }));
            }
            waypoints.push({ lat: currentRoute.dest.lat, lon: currentRoute.dest.lon });
            return waypoints;
        }

        function haversineNM(lat1, lon1, lat2, lon2) {
            const R = 3440.065;
            const toRad = d => d * Math.PI / 180;
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function isNearRoute(lat, lon, corridorNM = ROUTE_CORRIDOR_NM) {
            if (!routeOverlaysActive) return true;
            const waypoints = getRouteWaypoints();
            if (waypoints.length < 2) return true;
            for (const wp of waypoints) {
                if (haversineNM(lat, lon, wp.lat, wp.lon) <= corridorNM) return true;
            }
            for (let i = 0; i < waypoints.length - 1; i++) {
                const midLat = (waypoints[i].lat + waypoints[i+1].lat) / 2;
                const midLon = (waypoints[i].lon + waypoints[i+1].lon) / 2;
                if (haversineNM(lat, lon, midLat, midLon) <= corridorNM) return true;
            }
            return false;
        }

        function zoneIntersectsRoute(polygon, corridorNM = ROUTE_CORRIDOR_NM) {
            if (!routeOverlaysActive) return true;
            const waypoints = getRouteWaypoints();
            if (waypoints.length < 2) return true;
            for (const coord of polygon) {
                if (isNearRoute(coord[0], coord[1], corridorNM)) return true;
            }
            for (const wp of waypoints) {
                if (pointInPolygon(wp.lat, wp.lon, polygon)) return true;
            }
            let centLat = 0, centLon = 0;
            for (const coord of polygon) {
                centLat += coord[0];
                centLon += coord[1];
            }
            centLat /= polygon.length;
            centLon /= polygon.length;
            return isNearRoute(centLat, centLon, corridorNM);
        }
        // ============================================

        // Terrain overlay layer - route-aware hazard visualization
        const terrainLayer = L.layerGroup();

        // Generate terrain hazard overlay along the flight route
        function createTerrainOverlay() {
            terrainLayer.clearLayers();

            // Only show terrain if we have a route defined
            if (!currentRoute.dep || !currentRoute.dest) {
                // No route - show message marker at map center
                const center = map.getCenter();
                const noRouteIcon = L.divIcon({
                    className: 'terrain-no-route',
                    html: `<div style="
                        background: rgba(0,0,0,0.8);
                        border: 1px solid #f59e0b;
                        border-radius: 6px;
                        padding: 6px 12px;
                        color: #f59e0b;
                        font-size: 11px;
                        white-space: nowrap;
                    ">Select a route to view terrain hazards</div>`,
                    iconSize: [200, 30],
                    iconAnchor: [100, 15]
                });
                terrainLayer.addLayer(L.marker(center, { icon: noRouteIcon }));
                return;
            }

            // currentRoute.dep/dest are station objects (have .lat, .lon properties)
            const depStation = currentRoute.dep;
            const destStation = currentRoute.dest;
            if (!depStation || !destStation) return;

            // Generate terrain samples along the route corridor
            const numSamples = 30;
            const corridorWidthNM = 15; // Width of corridor to check (NM on each side)

            // Seeded random for consistent terrain
            let terrainSeed = (depStation.lat * 1000 + destStation.lon * 100) % 1000;
            function seededRandom() {
                terrainSeed = (terrainSeed * 9301 + 49297) % 233280;
                return terrainSeed / 233280;
            }

            // Get the optimized flight path altitude at each point
            const getFlightAltAtProgress = (t) => {
                // Simplified climb/cruise/descent profile (max 12500 ft)
                if (t < 0.15) return 2000 + (t / 0.15) * 10500; // Climb to 12500
                if (t > 0.85) return 12500 - ((t - 0.85) / 0.15) * 10500; // Descent
                return 12500; // Cruise
            };

            // Sample terrain along route
            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples;
                const lat = depStation.lat + t * (destStation.lat - depStation.lat);
                const lon = depStation.lon + t * (destStation.lon - depStation.lon);

                // Generate terrain elevation (simulated based on position)
                const baseTerrain = Math.sin(lat * 50) * 2000 + Math.sin(lon * 40) * 1500;
                const localVariation = seededRandom() * 1500 + Math.sin(t * 25) * 1000;
                const terrainElevation = Math.max(0, baseTerrain + localVariation + 1000);

                // Get planned flight altitude at this point
                const flightAlt = getFlightAltAtProgress(t);
                const clearance = flightAlt - terrainElevation;
                const minSafeClearance = 2000; // 2000ft minimum safe clearance

                // Only show terrain that's a concern (within 5000ft of flight path or above it)
                if (clearance < 5000) {
                    // Determine hazard level
                    let color, fillOpacity, hazardLevel;
                    if (clearance < 0) {
                        // TERRAIN! Flight path goes through terrain
                        color = '#dc2626';
                        fillOpacity = 0.7;
                        hazardLevel = 'CRITICAL';
                    } else if (clearance < minSafeClearance) {
                        // Below minimum safe clearance
                        color = '#f59e0b';
                        fillOpacity = 0.5;
                        hazardLevel = 'WARNING';
                    } else if (clearance < 4000) {
                        // Caution zone
                        color = '#eab308';
                        fillOpacity = 0.35;
                        hazardLevel = 'CAUTION';
                    } else {
                        // Advisory
                        color = '#22c55e';
                        fillOpacity = 0.2;
                        hazardLevel = 'ADVISORY';
                    }

                    // Create terrain marker polygon
                    const radiusKm = 8 + (5000 - clearance) / 500; // Larger for more dangerous terrain
                    const terrainCoords = createCircularPolygonCoords(lat, lon, radiusKm, map.getZoom());

                    const polygon = L.polygon(terrainCoords, {
                        color: color,
                        fillColor: color,
                        fillOpacity: fillOpacity,
                        weight: clearance < minSafeClearance ? 2 : 1,
                        dashArray: clearance >= minSafeClearance ? '3, 3' : null
                    });

                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:${color}">Terrain ${hazardLevel}</div>
                        <div><b>Elevation:</b> ${Math.round(terrainElevation).toLocaleString()} ft MSL</div>
                        <div><b>Flight Alt:</b> ${Math.round(flightAlt).toLocaleString()} ft</div>
                        <div><b>Clearance:</b> ${Math.round(clearance).toLocaleString()} ft</div>
                        <div style="font-size:10px;opacity:0.7;margin-top:4px">Min safe: ${minSafeClearance.toLocaleString()} ft AGL</div>
                    `, { sticky: true });

                    terrainLayer.addLayer(polygon);

                    // Add elevation label for critical/warning terrain
                    if (clearance < 4000) {
                        const elevIcon = L.divIcon({
                            className: 'terrain-elev-label',
                            html: `<div style="
                                background: rgba(0,0,0,0.8);
                                border: 1px solid ${color};
                                border-radius: 3px;
                                padding: 1px 4px;
                                font-size: 9px;
                                font-weight: 600;
                                color: ${color};
                                white-space: nowrap;
                            ">${Math.round(terrainElevation / 100)}00'</div>`,
                            iconSize: [40, 16],
                            iconAnchor: [20, 8]
                        });
                        terrainLayer.addLayer(L.marker([lat, lon], { icon: elevIcon }));
                    }
                }
            }

        }

        // Clouds/Satellite IR layer (RainViewer satellite)
        let cloudsLayer = null;

        async function loadCloudsLayer() {
            try {
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                const data = await response.json();

                if (data.satellite && data.satellite.infrared && data.satellite.infrared.length > 0) {
                    const latestFrame = data.satellite.infrared[data.satellite.infrared.length - 1];

                    if (cloudsLayer) {
                        map.removeLayer(cloudsLayer);
                    }

                    cloudsLayer = L.tileLayer(`https://tilecache.rainviewer.com${latestFrame.path}/256/{z}/{x}/{y}/0/0_0.png`, {
                        opacity: 0.5,
                        zIndex: 90
                    });

                    if (overlayState.clouds) {
                        cloudsLayer.addTo(map);
                    }
                }
            } catch (error) {
                console.error('Failed to load clouds layer:', error);
            }
        }

        // Icing zones layer (canvas overlay for visualization)
        const icingLayer = L.layerGroup();

        function createIcingOverlay() {
            icingLayer.clearLayers();
            const zoomLevel = map.getZoom();
            // Add icing zone polygons with realistic irregular shapes
            const icingZones = [
                { name: 'Northern Plains', polygon: [[46.5, -98.0], [47.2, -95.5], [46.8, -92.0], [44.5, -90.5], [42.5, -91.0], [41.8, -94.0], [42.2, -97.5], [44.0, -99.0], [46.5, -98.0]], intensity: 'Moderate', base: 8000, top: 22000, type: 'Mixed' },
                { name: 'Northeast', polygon: [[44.5, -76.0], [45.0, -73.5], [43.8, -71.0], [41.5, -72.0], [40.0, -74.5], [40.5, -77.0], [42.0, -78.5], [44.5, -76.0]], intensity: 'Light', base: 10000, top: 18000, type: 'Rime' },
                { name: 'Pacific Northwest', polygon: [[49.0, -122.5], [48.5, -119.0], [46.5, -117.5], [44.5, -118.5], [44.0, -121.0], [45.5, -123.5], [47.5, -124.0], [49.0, -122.5]], intensity: 'Light-Moderate', base: 6000, top: 20000, type: 'Mixed' },
                { name: 'Great Lakes', polygon: [[45.5, -86.0], [46.0, -83.5], [45.0, -81.0], [43.0, -80.5], [41.5, -82.5], [40.5, -86.0], [41.0, -89.0], [42.5, -90.0], [44.5, -88.0], [45.5, -86.0]], intensity: 'Moderate', base: 4000, top: 16000, type: 'Rime' },
                { name: 'Rocky Mountains', polygon: [[43.0, -108.5], [43.5, -105.0], [42.0, -102.5], [39.0, -102.5], [36.0, -104.5], [35.5, -108.0], [37.0, -110.0], [40.0, -110.0], [43.0, -108.5]], intensity: 'Light', base: 12000, top: 24000, type: 'Clear' },
            ];

            icingZones.forEach(zone => {
                // Filter by route corridor when advisories active
                if (routeOverlaysActive && !zoneIntersectsRoute(zone.polygon)) return;

                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                // Only pulse if zone strictly intersects route (not just corridor)
                const strictlyIntersects = routeOverlaysActive && zoneIntersectsRoute(zone.polygon, 10);
                const polygon = L.polygon(refinedCoords, {
                    color: '#06b6d4',
                    fillColor: '#06b6d4',
                    fillOpacity: 0.15,
                    weight: 2,
                    dashArray: '5, 5',
                    className: strictlyIntersects ? 'icing-pulse' : ''
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#06b6d4">Icing Advisory</div>
                    <div><b>Area:</b> ${zone.name}</div>
                    <div><b>Intensity:</b> ${zone.intensity}</div>
                    <div><b>Type:</b> ${zone.type}</div>
                    <div><b>Base:</b> ${zone.base.toLocaleString()} ft</div>
                    <div><b>Top:</b> ${zone.top.toLocaleString()} ft</div>
                `, { sticky: true });
                icingLayer.addLayer(polygon);
            });
        }

        // Turbulence zones layer
        const turbulenceLayer = L.layerGroup();

        function createTurbulenceOverlay() {
            turbulenceLayer.clearLayers();
            const zoomLevel = map.getZoom();
            // Add turbulence zone polygons with realistic SIGMET-style shapes
            const turbZones = [
                { name: 'Rocky Mountain Wave', polygon: [[41.0, -107.5], [41.5, -104.5], [40.0, -102.5], [37.5, -103.0], [36.0, -105.0], [36.5, -108.0], [38.5, -108.5], [41.0, -107.5]], intensity: 'Moderate-Severe', type: 'Mountain Wave', base: 15000, top: 45000 },
                { name: 'Sierra Nevada', polygon: [[38.5, -120.5], [39.0, -118.0], [37.5, -116.0], [35.0, -116.5], [34.0, -118.0], [35.0, -120.0], [37.0, -121.0], [38.5, -120.5]], intensity: 'Moderate', type: 'Mountain Wave', base: 18000, top: 40000 },
                { name: 'Appalachian Ridges', polygon: [[38.0, -82.0], [37.5, -79.5], [35.5, -80.0], [33.5, -82.5], [32.5, -85.0], [34.0, -86.5], [36.5, -85.5], [38.0, -82.0]], intensity: 'Light-Moderate', type: 'Mechanical', base: 8000, top: 25000 },
                { name: 'Great Plains Jet', polygon: [[41.0, -101.0], [41.5, -96.0], [39.5, -93.5], [36.5, -94.5], [35.0, -97.5], [36.0, -101.5], [38.5, -102.5], [41.0, -101.0]], intensity: 'Light-Moderate', type: 'Clear Air (CAT)', base: 30000, top: 42000 },
                { name: 'Gulf Coast Convective', polygon: [[32.0, -93.0], [32.5, -89.0], [31.0, -86.5], [29.0, -87.0], [28.0, -90.0], [29.0, -93.5], [31.0, -94.0], [32.0, -93.0]], intensity: 'Moderate', type: 'Convective', base: 10000, top: 35000 },
            ];

            turbZones.forEach(zone => {
                // Filter by route corridor when advisories active
                if (routeOverlaysActive && !zoneIntersectsRoute(zone.polygon)) return;

                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                // Only pulse if zone strictly intersects route (not just corridor)
                const strictlyIntersects = routeOverlaysActive && zoneIntersectsRoute(zone.polygon, 10);
                const polygon = L.polygon(refinedCoords, {
                    color: '#f97316',
                    fillColor: '#f97316',
                    fillOpacity: 0.15,
                    weight: 2,
                    dashArray: '3, 6',
                    className: strictlyIntersects ? 'turbulence-pulse' : ''
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#f97316">Turbulence SIGMET</div>
                    <div><b>Area:</b> ${zone.name}</div>
                    <div><b>Intensity:</b> ${zone.intensity}</div>
                    <div><b>Type:</b> ${zone.type}</div>
                    <div><b>Base:</b> FL${Math.round(zone.base/100)}</div>
                    <div><b>Top:</b> FL${Math.round(zone.top/100)}</div>
                `, { sticky: true });
                turbulenceLayer.addLayer(polygon);
            });
        }

        // Winds layer (wind barbs at stations)
        const windsLayer = L.layerGroup();

        function createWindsOverlay() {
            windsLayer.clearLayers();
            // Add wind indicators at each METAR station
            metarStations.forEach(station => {
                const data = metarData[station.id];
                if (data && data.wind_speed !== undefined) {
                    const windDir = data.wind_direction || 0;
                    const windSpd = data.wind_speed || 0;
                    const windGust = data.wind_gust || null;

                    // Create wind arrow marker
                    const arrowIcon = L.divIcon({
                        className: 'wind-arrow',
                        html: `<div style="transform: rotate(${windDir}deg); color: #22c55e; font-size: 20px; text-shadow: 0 0 3px rgba(0,0,0,0.5);"></div>
                               <div style="font-size: 10px; color: #22c55e; text-align: center; margin-top: -2px; font-weight: 600;">${windSpd}</div>`,
                        iconSize: [30, 35],
                        iconAnchor: [15, 17]
                    });

                    const marker = L.marker([station.lat, station.lon], { icon: arrowIcon });
                    marker.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:#22c55e">Surface Wind</div>
                        <div><b>Station:</b> ${station.id}</div>
                        <div><b>Direction:</b> ${windDir === 0 ? 'Variable' : windDir + ''}</div>
                        <div><b>Speed:</b> ${windSpd} kt</div>
                        ${windGust ? `<div><b>Gusts:</b> ${windGust} kt</div>` : ''}
                        <div><b>Category:</b> ${windSpd < 10 ? 'Light' : windSpd < 20 ? 'Moderate' : 'Strong'}</div>
                    `, { sticky: true });
                    windsLayer.addLayer(marker);
                }
            });
        }

        // Temperature layer (showing OAT at stations)
        const temperatureLayer = L.layerGroup();

        function createTemperatureOverlay() {
            temperatureLayer.clearLayers();

            // Get temperature color based on value
            const getTempColor = (temp) => {
                if (temp <= -20) return { color: '#581c87', fill: 'rgba(88, 28, 135, 0.35)' };  // Deep purple - extreme cold
                if (temp <= -10) return { color: '#7c3aed', fill: 'rgba(124, 58, 237, 0.3)' };  // Purple - very cold
                if (temp <= 0) return { color: '#3b82f6', fill: 'rgba(59, 130, 246, 0.25)' };   // Blue - cold/freezing
                if (temp <= 10) return { color: '#06b6d4', fill: 'rgba(6, 182, 212, 0.2)' };    // Cyan - cool
                if (temp <= 20) return { color: '#22c55e', fill: 'rgba(34, 197, 94, 0.2)' };    // Green - mild
                if (temp <= 30) return { color: '#f59e0b', fill: 'rgba(245, 158, 11, 0.25)' };  // Amber - warm
                if (temp <= 40) return { color: '#ef4444', fill: 'rgba(239, 68, 68, 0.3)' };    // Red - hot
                return { color: '#991b1b', fill: 'rgba(153, 27, 27, 0.35)' };                    // Dark red - extreme heat
            };

            // Get temperature category
            const getTempCategory = (temp) => {
                if (temp <= -20) return { name: 'Extreme Cold', desc: 'Severe icing risk, cold soaking concerns' };
                if (temp <= -10) return { name: 'Very Cold', desc: 'Significant icing potential' };
                if (temp <= 0) return { name: 'Freezing', desc: 'Icing conditions possible' };
                if (temp <= 10) return { name: 'Cool', desc: 'Comfortable conditions' };
                if (temp <= 20) return { name: 'Mild', desc: 'Optimal flying conditions' };
                if (temp <= 30) return { name: 'Warm', desc: 'Reduced air density' };
                if (temp <= 40) return { name: 'Hot', desc: 'High density altitude concerns' };
                return { name: 'Extreme Heat', desc: 'Significant performance reduction' };
            };

            metarStations.forEach(station => {
                const data = metarData[station.id];
                if (data && data.temperature !== null && data.temperature !== undefined) {
                    const temp = data.temperature;
                    const tempF = Math.round(temp * 9/5 + 32);
                    const colors = getTempColor(temp);
                    const category = getTempCategory(temp);

                    // Create heat map polygon - radius based on how extreme the temperature is
                    const extremity = Math.abs(temp - 15); // 15C is "normal"
                    const radiusKm = 30 + extremity * 1.5; // Larger radius for more extreme temps
                    const hexCoords = createCircularPolygonCoords(station.lat, station.lon, radiusKm, map.getZoom());
                    const refinedCoords = refinePolygon(hexCoords, map.getZoom());

                    const polygon = L.polygon(refinedCoords, {
                        color: colors.color,
                        fillColor: colors.color,
                        fillOpacity: parseFloat(colors.fill.match(/[\d.]+(?=\))/)[0]),
                        weight: 2,
                        opacity: 0.8
                    });

                    const dewpointF = data.dewpoint !== null ? Math.round(data.dewpoint * 9/5 + 32) : null;
                    const spreadF = data.dewpoint !== null ? Math.round((temp - data.dewpoint) * 9/5) : null;
                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:${colors.color}">${station.id} Temperature</div>
                        <div style="font-size:10px;opacity:0.8;margin-bottom:6px">${category.desc}</div>
                        <div><b>OAT:</b> ${tempF}F</div>
                        <div><b>Category:</b> ${category.name}</div>
                        ${dewpointF !== null ? `<div><b>Dewpoint:</b> ${dewpointF}F</div>` : ''}
                        ${spreadF !== null ? `<div><b>Spread:</b> ${spreadF}F</div>` : ''}
                        ${data.altimeter ? `<div><b>Altimeter:</b> ${data.altimeter.toFixed(2)}"</div>` : ''}
                    `, { sticky: true });
                    temperatureLayer.addLayer(polygon);

                    // Add temperature label marker at center
                    const tempIcon = L.divIcon({
                        className: 'temp-label',
                        html: `<div style="
                            background: rgba(0,0,0,0.7);
                            border: 1px solid ${colors.color};
                            border-radius: 4px;
                            padding: 1px 4px;
                            font-size: 10px;
                            font-weight: 600;
                            color: ${colors.color};
                            white-space: nowrap;
                        ">${tempF}F</div>`,
                        iconSize: [30, 18],
                        iconAnchor: [15, 9]
                    });
                    const marker = L.marker([station.lat, station.lon], { icon: tempIcon });
                    temperatureLayer.addLayer(marker);
                }
            });
        }

        // Dew point / Precipitation layer
        const dewpointLayer = L.layerGroup();

        function createDewpointOverlay() {
            dewpointLayer.clearLayers();
            const zoomLevel = map.getZoom();

            metarStations.forEach(station => {
                const data = metarData[station.id];
                if (data) {
                    const dewpoint = data.dewpoint;
                    const temp = data.temperature;
                    const spread = (temp !== null && dewpoint !== null) ? temp - dewpoint : null;

                    // Determine precipitation type and intensity
                    let precipType = null;
                    let precipColor = null;
                    let riskLevel = 0; // 0 = none, 1 = low, 2 = moderate, 3 = high

                    if (data.weather_string) {
                        if (data.weather_string.includes('TS')) {
                            precipType = 'Thunderstorm';
                            precipColor = '#ef4444';
                            riskLevel = 3;
                        } else if (data.weather_string.includes('+RA') || data.weather_string.includes('+SH')) {
                            precipType = 'Heavy Rain';
                            precipColor = '#3b82f6';
                            riskLevel = 3;
                        } else if (data.weather_string.includes('RA') || data.weather_string.includes('SH')) {
                            precipType = 'Rain';
                            precipColor = '#0ea5e9';
                            riskLevel = 2;
                        } else if (data.weather_string.includes('SN') || data.weather_string.includes('SG')) {
                            precipType = 'Snow';
                            precipColor = '#a855f7';
                            riskLevel = 2;
                        } else if (data.weather_string.includes('DZ')) {
                            precipType = 'Drizzle';
                            precipColor = '#06b6d4';
                            riskLevel = 1;
                        } else if (data.weather_string.includes('FG') || data.weather_string.includes('BR')) {
                            precipType = 'Fog/Mist';
                            precipColor = '#94a3b8';
                            riskLevel = 2;
                        }
                    }

                    // Show fog risk based on temp/dewpoint spread (only if no other precip)
                    if (spread !== null && spread <= 3 && !precipType) {
                        precipType = spread <= 1 ? 'Fog Likely' : 'Fog Risk';
                        precipColor = '#94a3b8';
                        riskLevel = spread <= 1 ? 2 : 1;
                    }

                    // Only show stations with actual risks
                    if (!precipType || riskLevel === 0) return;

                    // Create high-resolution polygon outline
                    const radiusKm = 40 + riskLevel * 15; // Larger radius for higher risk
                    const sides = Math.min(48, Math.max(24, Math.floor(24 * Math.pow(1.2, zoomLevel - 4))));
                    const coords = [];
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * 2 * Math.PI;
                        const latOffset = (radiusKm / 111) * Math.cos(angle);
                        const lonOffset = (radiusKm / (111 * Math.cos(station.lat * Math.PI / 180))) * Math.sin(angle);
                        coords.push([station.lat + latOffset, station.lon + lonOffset]);
                    }

                    const polygon = L.polygon(coords, {
                        color: precipColor,
                        fillColor: precipColor,
                        fillOpacity: 0.08 + riskLevel * 0.04,
                        weight: riskLevel >= 2 ? 2.5 : 1.5,
                        opacity: 0.8
                    });

                    const dewpointF = dewpoint !== null ? Math.round(dewpoint * 9/5 + 32) : null;
                    const spreadF = spread !== null ? Math.round(spread * 9/5) : null;
                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:${precipColor}">${precipType}</div>
                        <div><b>Station:</b> ${station.id}</div>
                        ${dewpointF !== null ? `<div><b>Dewpoint:</b> ${dewpointF}F</div>` : ''}
                        ${spreadF !== null ? `<div><b>Temp/DP Spread:</b> ${spreadF}F</div>` : ''}
                        ${data.weather_string ? `<div><b>Weather:</b> ${data.weather_string}</div>` : ''}
                        ${spread !== null && spread <= 3 ? `<div style="color:#f59e0b;font-size:10px;margin-top:4px"> Low spread - fog/moisture risk</div>` : ''}
                    `, { sticky: true });
                    dewpointLayer.addLayer(polygon);
                }
            });
        }

        // Helper function to create circular polygon with zoom-responsive vertex count
        function createCircularPolygonCoords(lat, lon, radiusKm, zoomLevel = 5) {
            // Sides scale with zoom: 6 at zoom 4, up to 72 at zoom 14+
            const baseSides = 6;
            const sides = Math.min(72, Math.max(baseSides, Math.floor(baseSides * Math.pow(1.3, zoomLevel - 4))));
            const coords = [];
            const earthRadius = 6371; // km
            const angleStep = 360 / sides;
            for (let i = 0; i < sides; i++) {
                const angle = (i * angleStep) * Math.PI / 180;
                const dLat = (radiusKm / earthRadius) * Math.cos(angle) * (180 / Math.PI);
                const dLon = (radiusKm / earthRadius) * Math.sin(angle) * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
                coords.push([lat + dLat, lon + dLon]);
            }
            coords.push(coords[0]); // Close the polygon
            return coords;
        }

        // Refine existing polygon with interpolated points based on zoom level
        function refinePolygon(coords, zoomLevel = 5) {
            // At low zoom, return original. At high zoom, add intermediate points for smooth curves
            const refinementFactor = Math.max(1, Math.floor(Math.pow(1.4, zoomLevel - 6)));
            if (refinementFactor <= 1) return coords;

            const refined = [];
            for (let i = 0; i < coords.length - 1; i++) {
                const p1 = coords[i];
                const p2 = coords[i + 1];
                refined.push(p1);

                // Add intermediate points using spherical interpolation approximation
                for (let j = 1; j < refinementFactor; j++) {
                    const t = j / refinementFactor;
                    // Catmull-Rom-like smoothing using neighboring points
                    const prevIdx = Math.max(0, i - 1);
                    const nextIdx = Math.min(coords.length - 2, i + 1);
                    const p0 = coords[prevIdx];
                    const p3 = coords[nextIdx === i ? Math.min(coords.length - 2, i + 2) : nextIdx + 1] || p2;

                    // Cubic interpolation for smoother curves
                    const t2 = t * t;
                    const t3 = t2 * t;
                    const lat = 0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t +
                               (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t2 +
                               (-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t3);
                    const lon = 0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t +
                               (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t2 +
                               (-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t3);
                    refined.push([lat, lon]);
                }
            }
            refined.push(coords[coords.length - 1]); // Close polygon
            return refined;
        }

        // Legacy wrapper for backwards compatibility
        function createHexagonCoords(lat, lon, radiusKm, rotation = 0) {
            return createCircularPolygonCoords(lat, lon, radiusKm, map.getZoom());
        }

        // Flight Conditions overlay - combines ceiling + visibility into flight rules (VFR/MVFR/IFR/LIFR)
        const conditionsLayer = L.layerGroup();

        function createConditionsOverlay() {
            conditionsLayer.clearLayers();
            metarStations.forEach(station => {
                // Filter by route corridor when advisories active
                if (routeOverlaysActive && !isNearRoute(station.lat, station.lon)) return;

                const data = metarData[station.id];
                if (data) {
                    const flightRules = data.flight_rules || 'VFR';

                    // Only show safety-critical conditions (MVFR, IFR, LIFR)
                    // Skip VFR - good visibility doesn't need to be highlighted
                    if (flightRules === 'VFR') return;

                    const color = flightRulesColors[flightRules] || '#22c55e';
                    const ceiling = data.ceiling;
                    const vis = data.visibility;

                    // Flight rules descriptions
                    const flightRulesDesc = {
                        'MVFR': 'Marginal VFR - Caution',
                        'IFR': 'Instrument Flight Rules - Warning',
                        'LIFR': 'Low IFR - Critical'
                    };
                    const flightRulesCriteria = {
                        'MVFR': 'Ceiling 1000-3000 ft OR Visibility 3-5 SM',
                        'IFR': 'Ceiling 500-1000 ft OR Visibility 1-3 SM',
                        'LIFR': 'Ceiling <500 ft OR Visibility <1 SM'
                    };

                    // Opacity based on conditions severity - more visible for worse conditions
                    let fillOpacity = 0.2;
                    if (flightRules === 'IFR') fillOpacity = 0.3;
                    if (flightRules === 'LIFR') fillOpacity = 0.4;

                    // Create hexagon for flight conditions (50km radius)
                    const hexCoords = createHexagonCoords(station.lat, station.lon, 50);
                    const polygon = L.polygon(hexCoords, {
                        color: color,
                        fillColor: color,
                        fillOpacity: fillOpacity,
                        weight: 2
                    });

                    // Format data for tooltip
                    const ceilingText = ceiling ? `${ceiling.toLocaleString()} ft AGL` : 'Clear / Unlimited';
                    const visText = vis !== null ? `${vis} SM` : 'N/A';
                    const tempF = data.temperature !== null ? Math.round(data.temperature * 9/5 + 32) : null;
                    const dewF = data.dewpoint !== null ? Math.round(data.dewpoint * 9/5 + 32) : null;

                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:${color}">${station.id} - ${flightRules}</div>
                        <div style="font-size:10px;opacity:0.8;margin-bottom:6px">${flightRulesDesc[flightRules]}: ${flightRulesCriteria[flightRules]}</div>
                        <div><b>Ceiling:</b> ${ceilingText}</div>
                        <div><b>Visibility:</b> ${visText}</div>
                        ${data.wind_speed ? `<div><b>Wind:</b> ${data.wind_direction} @ ${data.wind_speed} kt</div>` : ''}
                        ${tempF !== null ? `<div><b>Temp/Dewpoint:</b> ${tempF}F / ${dewF}F</div>` : ''}
                        ${data.weather_string ? `<div><b>Weather:</b> ${data.weather_string}</div>` : ''}
                    `, { sticky: true, className: 'conditions-tooltip' });

                    conditionsLayer.addLayer(polygon);
                }
            });
        }

        // Airspace layer
        const airspaceLayer = L.layerGroup();

        // Detailed airspace data with polygon boundaries and multiple tiers
        const airspaceData = {
            // Class B airspaces with realistic multi-tier polygon shapes
            classB: [
                {
                    name: 'New York Class B',
                    center: [40.6413, -73.7781],
                    tiers: [
                        { floor: 0, ceiling: 7000, polygon: [[40.85, -73.45], [40.90, -73.65], [40.88, -73.95], [40.75, -74.10], [40.55, -74.15], [40.40, -74.05], [40.35, -73.85], [40.40, -73.55], [40.55, -73.40], [40.70, -73.35], [40.85, -73.45]] },
                        { floor: 1500, ceiling: 7000, polygon: [[40.95, -73.30], [41.00, -73.60], [40.98, -74.05], [40.85, -74.25], [40.60, -74.35], [40.35, -74.25], [40.20, -74.00], [40.18, -73.60], [40.30, -73.25], [40.55, -73.10], [40.80, -73.15], [40.95, -73.30]] },
                        { floor: 3000, ceiling: 7000, polygon: [[41.05, -73.15], [41.15, -73.55], [41.10, -74.15], [40.90, -74.45], [40.55, -74.55], [40.20, -74.40], [40.00, -74.05], [39.98, -73.50], [40.15, -73.05], [40.50, -72.85], [40.85, -72.95], [41.05, -73.15]] }
                    ]
                },
                {
                    name: 'Los Angeles Class B',
                    center: [33.9425, -118.4081],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[34.10, -118.20], [34.15, -118.45], [34.10, -118.70], [33.90, -118.80], [33.70, -118.75], [33.60, -118.50], [33.65, -118.20], [33.80, -118.05], [34.00, -118.05], [34.10, -118.20]] },
                        { floor: 2500, ceiling: 10000, polygon: [[34.25, -118.00], [34.35, -118.45], [34.25, -118.90], [33.95, -119.05], [33.60, -118.95], [33.45, -118.55], [33.50, -118.10], [33.75, -117.85], [34.10, -117.85], [34.25, -118.00]] },
                        { floor: 5000, ceiling: 10000, polygon: [[34.40, -117.80], [34.55, -118.40], [34.40, -119.05], [34.00, -119.25], [33.50, -119.10], [33.30, -118.55], [33.40, -117.95], [33.75, -117.60], [34.20, -117.60], [34.40, -117.80]] }
                    ]
                },
                {
                    name: 'Chicago Class B',
                    center: [41.9742, -87.9073],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[42.15, -87.70], [42.20, -87.95], [42.15, -88.20], [41.95, -88.30], [41.75, -88.25], [41.65, -88.00], [41.70, -87.70], [41.85, -87.55], [42.05, -87.55], [42.15, -87.70]] },
                        { floor: 1900, ceiling: 10000, polygon: [[42.30, -87.50], [42.40, -87.90], [42.30, -88.35], [42.00, -88.55], [41.65, -88.45], [41.45, -88.05], [41.55, -87.55], [41.85, -87.30], [42.15, -87.30], [42.30, -87.50]] },
                        { floor: 3000, ceiling: 10000, polygon: [[42.45, -87.30], [42.55, -87.85], [42.45, -88.50], [42.05, -88.75], [41.55, -88.65], [41.30, -88.10], [41.40, -87.40], [41.80, -87.10], [42.25, -87.10], [42.45, -87.30]] }
                    ]
                },
                {
                    name: 'Atlanta Class B',
                    center: [33.6407, -84.4277],
                    tiers: [
                        { floor: 0, ceiling: 12500, polygon: [[33.85, -84.25], [33.90, -84.45], [33.85, -84.65], [33.65, -84.75], [33.45, -84.70], [33.35, -84.50], [33.40, -84.25], [33.55, -84.10], [33.75, -84.10], [33.85, -84.25]] },
                        { floor: 3000, ceiling: 12500, polygon: [[34.00, -84.05], [34.10, -84.45], [34.00, -84.85], [33.70, -85.00], [33.35, -84.90], [33.20, -84.50], [33.30, -84.05], [33.55, -83.85], [33.85, -83.85], [34.00, -84.05]] },
                        { floor: 5000, ceiling: 12500, polygon: [[34.15, -83.85], [34.30, -84.40], [34.15, -85.00], [33.75, -85.20], [33.25, -85.05], [33.05, -84.45], [33.20, -83.85], [33.55, -83.55], [33.95, -83.55], [34.15, -83.85]] }
                    ]
                },
                {
                    name: 'Dallas Class B',
                    center: [32.8998, -97.0403],
                    tiers: [
                        { floor: 0, ceiling: 11000, polygon: [[33.10, -96.85], [33.15, -97.05], [33.10, -97.25], [32.90, -97.35], [32.70, -97.30], [32.60, -97.10], [32.65, -96.85], [32.80, -96.70], [33.00, -96.70], [33.10, -96.85]] },
                        { floor: 2500, ceiling: 11000, polygon: [[33.25, -96.65], [33.35, -97.05], [33.25, -97.45], [32.95, -97.60], [32.60, -97.50], [32.45, -97.10], [32.55, -96.65], [32.80, -96.45], [33.10, -96.45], [33.25, -96.65]] },
                        { floor: 4000, ceiling: 11000, polygon: [[33.40, -96.45], [33.55, -97.00], [33.40, -97.60], [33.00, -97.85], [32.50, -97.70], [32.30, -97.10], [32.45, -96.45], [32.80, -96.15], [33.20, -96.15], [33.40, -96.45]] }
                    ]
                },
                {
                    name: 'Denver Class B',
                    center: [39.8561, -104.6737],
                    tiers: [
                        { floor: 0, ceiling: 12000, polygon: [[40.05, -104.45], [40.10, -104.70], [40.05, -104.95], [39.85, -105.05], [39.65, -105.00], [39.55, -104.75], [39.60, -104.45], [39.75, -104.30], [39.95, -104.30], [40.05, -104.45]] },
                        { floor: 3000, ceiling: 12000, polygon: [[40.20, -104.25], [40.30, -104.70], [40.20, -105.15], [39.90, -105.30], [39.55, -105.20], [39.40, -104.75], [39.50, -104.25], [39.75, -104.00], [40.05, -104.00], [40.20, -104.25]] },
                        { floor: 7000, ceiling: 12000, polygon: [[40.35, -104.00], [40.50, -104.65], [40.35, -105.35], [39.95, -105.55], [39.45, -105.40], [39.25, -104.70], [39.40, -104.00], [39.75, -103.70], [40.15, -103.70], [40.35, -104.00]] }
                    ]
                },
                {
                    name: 'San Francisco Class B',
                    center: [37.6213, -122.3790],
                    tiers: [
                        { floor: 0, ceiling: 8000, polygon: [[37.80, -122.20], [37.85, -122.40], [37.80, -122.60], [37.60, -122.70], [37.40, -122.65], [37.30, -122.45], [37.35, -122.20], [37.50, -122.05], [37.70, -122.05], [37.80, -122.20]] },
                        { floor: 1500, ceiling: 8000, polygon: [[37.95, -122.00], [38.05, -122.35], [37.95, -122.75], [37.65, -122.90], [37.30, -122.80], [37.15, -122.45], [37.25, -122.00], [37.50, -121.80], [37.80, -121.80], [37.95, -122.00]] },
                        { floor: 3000, ceiling: 8000, polygon: [[38.10, -121.80], [38.25, -122.30], [38.10, -122.90], [37.70, -123.10], [37.20, -122.95], [37.00, -122.40], [37.15, -121.80], [37.50, -121.55], [37.90, -121.55], [38.10, -121.80]] }
                    ]
                },
                {
                    name: 'Seattle Class B',
                    center: [47.4502, -122.3088],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[47.65, -122.10], [47.70, -122.35], [47.65, -122.55], [47.45, -122.65], [47.25, -122.60], [47.15, -122.40], [47.20, -122.15], [47.35, -122.00], [47.55, -122.00], [47.65, -122.10]] },
                        { floor: 2000, ceiling: 10000, polygon: [[47.80, -121.90], [47.90, -122.30], [47.80, -122.70], [47.50, -122.85], [47.15, -122.75], [47.00, -122.40], [47.10, -121.95], [47.35, -121.75], [47.65, -121.75], [47.80, -121.90]] },
                        { floor: 4000, ceiling: 10000, polygon: [[47.95, -121.70], [48.10, -122.25], [47.95, -122.85], [47.55, -123.05], [47.05, -122.90], [46.85, -122.35], [47.00, -121.75], [47.35, -121.50], [47.75, -121.50], [47.95, -121.70]] }
                    ]
                },
                {
                    name: 'Miami Class B',
                    center: [25.7959, -80.2870],
                    tiers: [
                        { floor: 0, ceiling: 7000, polygon: [[26.00, -80.10], [26.05, -80.30], [26.00, -80.50], [25.80, -80.55], [25.60, -80.50], [25.50, -80.30], [25.55, -80.10], [25.70, -79.95], [25.90, -79.95], [26.00, -80.10]] },
                        { floor: 1500, ceiling: 7000, polygon: [[26.15, -79.90], [26.25, -80.25], [26.15, -80.60], [25.85, -80.75], [25.50, -80.65], [25.35, -80.30], [25.45, -79.90], [25.70, -79.70], [26.00, -79.70], [26.15, -79.90]] },
                        { floor: 3000, ceiling: 7000, polygon: [[26.30, -79.70], [26.45, -80.20], [26.30, -80.75], [25.90, -80.95], [25.40, -80.80], [25.20, -80.25], [25.35, -79.70], [25.70, -79.45], [26.10, -79.45], [26.30, -79.70]] }
                    ]
                },
                {
                    name: 'Boston Class B',
                    center: [42.3656, -71.0096],
                    tiers: [
                        { floor: 0, ceiling: 7000, polygon: [[42.55, -70.85], [42.60, -71.05], [42.55, -71.25], [42.35, -71.35], [42.15, -71.30], [42.05, -71.10], [42.10, -70.85], [42.25, -70.70], [42.45, -70.70], [42.55, -70.85]] },
                        { floor: 1500, ceiling: 7000, polygon: [[42.70, -70.65], [42.80, -71.00], [42.70, -71.40], [42.40, -71.55], [42.05, -71.45], [41.90, -71.05], [42.00, -70.65], [42.25, -70.45], [42.55, -70.45], [42.70, -70.65]] },
                        { floor: 2500, ceiling: 7000, polygon: [[42.85, -70.45], [43.00, -70.95], [42.85, -71.55], [42.45, -71.75], [41.95, -71.60], [41.75, -71.00], [41.90, -70.45], [42.25, -70.20], [42.65, -70.20], [42.85, -70.45]] }
                    ]
                },
                {
                    name: 'Philadelphia Class B',
                    center: [39.8729, -75.2411],
                    tiers: [
                        { floor: 0, ceiling: 7000, polygon: [[40.05, -75.05], [40.10, -75.25], [40.05, -75.45], [39.85, -75.55], [39.65, -75.50], [39.55, -75.30], [39.60, -75.05], [39.75, -74.90], [39.95, -74.90], [40.05, -75.05]] },
                        { floor: 1500, ceiling: 7000, polygon: [[40.20, -74.85], [40.30, -75.20], [40.20, -75.60], [39.90, -75.75], [39.55, -75.65], [39.40, -75.25], [39.50, -74.85], [39.75, -74.65], [40.05, -74.65], [40.20, -74.85]] },
                        { floor: 3000, ceiling: 7000, polygon: [[40.35, -74.65], [40.50, -75.15], [40.35, -75.75], [39.95, -75.95], [39.45, -75.80], [39.25, -75.20], [39.40, -74.65], [39.75, -74.40], [40.15, -74.40], [40.35, -74.65]] }
                    ]
                },
                {
                    name: 'Washington Dulles Class B',
                    center: [38.9531, -77.4565],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[39.10, -77.30], [39.15, -77.50], [39.10, -77.70], [38.90, -77.80], [38.70, -77.75], [38.60, -77.55], [38.65, -77.30], [38.80, -77.15], [39.00, -77.15], [39.10, -77.30]] },
                        { floor: 1500, ceiling: 10000, polygon: [[39.25, -77.10], [39.35, -77.45], [39.25, -77.85], [38.95, -78.00], [38.60, -77.90], [38.45, -77.50], [38.55, -77.10], [38.80, -76.90], [39.10, -76.90], [39.25, -77.10]] },
                        { floor: 3500, ceiling: 10000, polygon: [[39.40, -76.90], [39.55, -77.40], [39.40, -78.00], [39.00, -78.20], [38.50, -78.05], [38.30, -77.45], [38.45, -76.90], [38.80, -76.65], [39.20, -76.65], [39.40, -76.90]] }
                    ]
                },
                {
                    name: 'Phoenix Class B',
                    center: [33.4373, -112.0078],
                    tiers: [
                        { floor: 0, ceiling: 9000, polygon: [[33.60, -111.85], [33.65, -112.05], [33.60, -112.25], [33.40, -112.35], [33.20, -112.30], [33.10, -112.10], [33.15, -111.85], [33.30, -111.70], [33.50, -111.70], [33.60, -111.85]] },
                        { floor: 3000, ceiling: 9000, polygon: [[33.75, -111.65], [33.85, -112.00], [33.75, -112.40], [33.45, -112.55], [33.10, -112.45], [32.95, -112.05], [33.05, -111.65], [33.30, -111.45], [33.60, -111.45], [33.75, -111.65]] },
                        { floor: 5000, ceiling: 9000, polygon: [[33.90, -111.45], [34.05, -111.95], [33.90, -112.55], [33.50, -112.75], [33.00, -112.60], [32.80, -112.00], [32.95, -111.45], [33.30, -111.20], [33.70, -111.20], [33.90, -111.45]] }
                    ]
                },
                {
                    name: 'Detroit Class B',
                    center: [42.2162, -83.3554],
                    tiers: [
                        { floor: 0, ceiling: 8000, polygon: [[42.40, -83.15], [42.45, -83.40], [42.40, -83.60], [42.20, -83.70], [42.00, -83.65], [41.90, -83.40], [41.95, -83.15], [42.10, -83.00], [42.30, -83.00], [42.40, -83.15]] },
                        { floor: 2000, ceiling: 8000, polygon: [[42.55, -82.95], [42.65, -83.35], [42.55, -83.75], [42.25, -83.90], [41.90, -83.80], [41.75, -83.40], [41.85, -82.95], [42.10, -82.75], [42.40, -82.75], [42.55, -82.95]] },
                        { floor: 4000, ceiling: 8000, polygon: [[42.70, -82.75], [42.85, -83.30], [42.70, -83.90], [42.30, -84.10], [41.80, -83.95], [41.60, -83.35], [41.75, -82.75], [42.10, -82.50], [42.50, -82.50], [42.70, -82.75]] }
                    ]
                },
                {
                    name: 'Charlotte Class B',
                    center: [35.2140, -80.9431],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[35.40, -80.75], [35.45, -80.95], [35.40, -81.15], [35.20, -81.25], [35.00, -81.20], [34.90, -81.00], [34.95, -80.75], [35.10, -80.60], [35.30, -80.60], [35.40, -80.75]] },
                        { floor: 2500, ceiling: 10000, polygon: [[35.55, -80.55], [35.65, -80.90], [35.55, -81.30], [35.25, -81.45], [34.90, -81.35], [34.75, -80.95], [34.85, -80.55], [35.10, -80.35], [35.40, -80.35], [35.55, -80.55]] },
                        { floor: 4000, ceiling: 10000, polygon: [[35.70, -80.35], [35.85, -80.85], [35.70, -81.45], [35.30, -81.65], [34.80, -81.50], [34.60, -80.90], [34.75, -80.35], [35.10, -80.10], [35.50, -80.10], [35.70, -80.35]] }
                    ]
                },
                {
                    name: 'Orlando Class B',
                    center: [28.4312, -81.3081],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[28.60, -81.15], [28.65, -81.35], [28.60, -81.50], [28.40, -81.60], [28.20, -81.55], [28.10, -81.35], [28.15, -81.15], [28.30, -81.00], [28.50, -81.00], [28.60, -81.15]] },
                        { floor: 2000, ceiling: 10000, polygon: [[28.75, -80.95], [28.85, -81.30], [28.75, -81.65], [28.45, -81.80], [28.10, -81.70], [27.95, -81.35], [28.05, -80.95], [28.30, -80.75], [28.60, -80.75], [28.75, -80.95]] },
                        { floor: 4000, ceiling: 10000, polygon: [[28.90, -80.75], [29.05, -81.25], [28.90, -81.80], [28.50, -82.00], [28.00, -81.85], [27.80, -81.30], [27.95, -80.75], [28.30, -80.50], [28.70, -80.50], [28.90, -80.75]] }
                    ]
                },
                {
                    name: 'Tampa Class B',
                    center: [27.9755, -82.5332],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[28.15, -82.35], [28.20, -82.55], [28.15, -82.75], [27.95, -82.85], [27.75, -82.80], [27.65, -82.60], [27.70, -82.35], [27.85, -82.20], [28.05, -82.20], [28.15, -82.35]] },
                        { floor: 2000, ceiling: 10000, polygon: [[28.30, -82.15], [28.40, -82.50], [28.30, -82.90], [28.00, -83.05], [27.65, -82.95], [27.50, -82.55], [27.60, -82.15], [27.85, -81.95], [28.15, -81.95], [28.30, -82.15]] },
                        { floor: 4000, ceiling: 10000, polygon: [[28.45, -81.95], [28.60, -82.45], [28.45, -83.05], [28.05, -83.25], [27.55, -83.10], [27.35, -82.50], [27.50, -81.95], [27.85, -81.70], [28.25, -81.70], [28.45, -81.95]] }
                    ]
                },
                {
                    name: 'Minneapolis Class B',
                    center: [44.8848, -93.2223],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[45.05, -93.05], [45.10, -93.25], [45.05, -93.45], [44.85, -93.55], [44.65, -93.50], [44.55, -93.30], [44.60, -93.05], [44.75, -92.90], [44.95, -92.90], [45.05, -93.05]] },
                        { floor: 2000, ceiling: 10000, polygon: [[45.20, -92.85], [45.30, -93.20], [45.20, -93.60], [44.90, -93.75], [44.55, -93.65], [44.40, -93.25], [44.50, -92.85], [44.75, -92.65], [45.05, -92.65], [45.20, -92.85]] },
                        { floor: 4000, ceiling: 10000, polygon: [[45.35, -92.65], [45.50, -93.15], [45.35, -93.75], [44.95, -93.95], [44.45, -93.80], [44.25, -93.20], [44.40, -92.65], [44.75, -92.40], [45.15, -92.40], [45.35, -92.65]] }
                    ]
                },
                {
                    name: 'Salt Lake City Class B',
                    center: [40.7899, -111.9791],
                    tiers: [
                        { floor: 0, ceiling: 12000, polygon: [[40.95, -111.80], [41.00, -112.00], [40.95, -112.20], [40.75, -112.30], [40.55, -112.25], [40.45, -112.05], [40.50, -111.80], [40.65, -111.65], [40.85, -111.65], [40.95, -111.80]] },
                        { floor: 4000, ceiling: 12000, polygon: [[41.10, -111.60], [41.20, -111.95], [41.10, -112.35], [40.80, -112.50], [40.45, -112.40], [40.30, -112.00], [40.40, -111.60], [40.65, -111.40], [40.95, -111.40], [41.10, -111.60]] },
                        { floor: 7000, ceiling: 12000, polygon: [[41.25, -111.40], [41.40, -111.90], [41.25, -112.50], [40.85, -112.70], [40.35, -112.55], [40.15, -111.95], [40.30, -111.40], [40.65, -111.15], [41.05, -111.15], [41.25, -111.40]] }
                    ]
                },
                {
                    name: 'Houston Bush Class B',
                    center: [29.9844, -95.3414],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[30.15, -95.15], [30.20, -95.35], [30.15, -95.55], [29.95, -95.65], [29.75, -95.60], [29.65, -95.40], [29.70, -95.15], [29.85, -95.00], [30.05, -95.00], [30.15, -95.15]] },
                        { floor: 2000, ceiling: 10000, polygon: [[30.30, -94.95], [30.40, -95.30], [30.30, -95.70], [30.00, -95.85], [29.65, -95.75], [29.50, -95.35], [29.60, -94.95], [29.85, -94.75], [30.15, -94.75], [30.30, -94.95]] },
                        { floor: 4000, ceiling: 10000, polygon: [[30.45, -94.75], [30.60, -95.25], [30.45, -95.85], [30.05, -96.05], [29.55, -95.90], [29.35, -95.30], [29.50, -94.75], [29.85, -94.50], [30.25, -94.50], [30.45, -94.75]] }
                    ]
                },
                {
                    name: 'San Diego Class B',
                    center: [32.7336, -117.1897],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[32.90, -117.05], [32.95, -117.20], [32.90, -117.40], [32.70, -117.50], [32.50, -117.45], [32.40, -117.25], [32.45, -117.05], [32.60, -116.90], [32.80, -116.90], [32.90, -117.05]] },
                        { floor: 2000, ceiling: 10000, polygon: [[33.05, -116.85], [33.15, -117.15], [33.05, -117.55], [32.75, -117.70], [32.40, -117.60], [32.25, -117.20], [32.35, -116.85], [32.60, -116.65], [32.90, -116.65], [33.05, -116.85]] },
                        { floor: 4000, ceiling: 10000, polygon: [[33.20, -116.65], [33.35, -117.10], [33.20, -117.70], [32.80, -117.90], [32.30, -117.75], [32.10, -117.15], [32.25, -116.65], [32.60, -116.40], [33.00, -116.40], [33.20, -116.65]] }
                    ]
                },
                {
                    name: 'Honolulu Class B',
                    center: [21.3187, -157.9225],
                    tiers: [
                        { floor: 0, ceiling: 8000, polygon: [[21.45, -157.80], [21.50, -157.95], [21.45, -158.10], [21.30, -158.20], [21.15, -158.15], [21.05, -157.95], [21.10, -157.75], [21.25, -157.65], [21.40, -157.65], [21.45, -157.80]] },
                        { floor: 1500, ceiling: 8000, polygon: [[21.55, -157.65], [21.65, -157.90], [21.55, -158.20], [21.35, -158.35], [21.10, -158.25], [20.95, -157.95], [21.05, -157.60], [21.25, -157.45], [21.50, -157.45], [21.55, -157.65]] },
                        { floor: 3000, ceiling: 8000, polygon: [[21.65, -157.50], [21.80, -157.85], [21.65, -158.35], [21.40, -158.50], [21.00, -158.35], [20.85, -157.90], [21.00, -157.45], [21.25, -157.25], [21.55, -157.25], [21.65, -157.50]] }
                    ]
                },
                {
                    name: 'St. Louis Class B',
                    center: [38.7487, -90.3700],
                    tiers: [
                        { floor: 0, ceiling: 8000, polygon: [[38.90, -90.20], [38.95, -90.40], [38.90, -90.55], [38.70, -90.65], [38.50, -90.60], [38.40, -90.40], [38.45, -90.20], [38.60, -90.05], [38.80, -90.05], [38.90, -90.20]] },
                        { floor: 2000, ceiling: 8000, polygon: [[39.05, -90.00], [39.15, -90.35], [39.05, -90.70], [38.75, -90.85], [38.40, -90.75], [38.25, -90.40], [38.35, -90.00], [38.60, -89.80], [38.90, -89.80], [39.05, -90.00]] },
                        { floor: 4000, ceiling: 8000, polygon: [[39.20, -89.80], [39.35, -90.30], [39.20, -90.85], [38.80, -91.05], [38.30, -90.90], [38.10, -90.35], [38.25, -89.80], [38.60, -89.55], [39.00, -89.55], [39.20, -89.80]] }
                    ]
                },
                {
                    name: 'Cleveland Class B',
                    center: [41.4117, -81.8498],
                    tiers: [
                        { floor: 0, ceiling: 8000, polygon: [[41.55, -81.70], [41.60, -81.90], [41.55, -82.05], [41.35, -82.15], [41.20, -82.10], [41.10, -81.90], [41.15, -81.70], [41.30, -81.55], [41.50, -81.55], [41.55, -81.70]] },
                        { floor: 2000, ceiling: 8000, polygon: [[41.70, -81.50], [41.80, -81.85], [41.70, -82.20], [41.40, -82.35], [41.10, -82.25], [40.95, -81.90], [41.05, -81.50], [41.30, -81.30], [41.60, -81.30], [41.70, -81.50]] },
                        { floor: 4000, ceiling: 8000, polygon: [[41.85, -81.30], [42.00, -81.80], [41.85, -82.35], [41.45, -82.55], [41.00, -82.40], [40.80, -81.85], [40.95, -81.30], [41.30, -81.05], [41.70, -81.05], [41.85, -81.30]] }
                    ]
                },
                {
                    name: 'Pittsburgh Class B',
                    center: [40.4915, -80.2329],
                    tiers: [
                        { floor: 0, ceiling: 8000, polygon: [[40.65, -80.05], [40.70, -80.25], [40.65, -80.45], [40.45, -80.55], [40.25, -80.50], [40.15, -80.30], [40.20, -80.05], [40.35, -79.90], [40.55, -79.90], [40.65, -80.05]] },
                        { floor: 2500, ceiling: 8000, polygon: [[40.80, -79.85], [40.90, -80.20], [40.80, -80.60], [40.50, -80.75], [40.15, -80.65], [40.00, -80.25], [40.10, -79.85], [40.35, -79.65], [40.65, -79.65], [40.80, -79.85]] },
                        { floor: 4500, ceiling: 8000, polygon: [[40.95, -79.65], [41.10, -80.15], [40.95, -80.75], [40.55, -80.95], [40.05, -80.80], [39.85, -80.20], [40.00, -79.65], [40.35, -79.40], [40.75, -79.40], [40.95, -79.65]] }
                    ]
                },
                {
                    name: 'Kansas City Class B',
                    center: [39.2976, -94.7139],
                    tiers: [
                        { floor: 0, ceiling: 8000, polygon: [[39.45, -94.55], [39.50, -94.75], [39.45, -94.95], [39.25, -95.05], [39.05, -95.00], [38.95, -94.80], [39.00, -94.55], [39.15, -94.40], [39.35, -94.40], [39.45, -94.55]] },
                        { floor: 2000, ceiling: 8000, polygon: [[39.60, -94.35], [39.70, -94.70], [39.60, -95.10], [39.30, -95.25], [38.95, -95.15], [38.80, -94.75], [38.90, -94.35], [39.15, -94.15], [39.45, -94.15], [39.60, -94.35]] },
                        { floor: 4000, ceiling: 8000, polygon: [[39.75, -94.15], [39.90, -94.65], [39.75, -95.25], [39.35, -95.45], [38.85, -95.30], [38.65, -94.70], [38.80, -94.15], [39.15, -93.90], [39.55, -93.90], [39.75, -94.15]] }
                    ]
                }
            ],
            // Class C with detailed polygons
            classC: [
                {
                    name: 'Houston Hobby Class C',
                    center: [29.6454, -95.2789],
                    tiers: [
                        { floor: 0, ceiling: 4000, polygon: [[29.75, -95.18], [29.78, -95.30], [29.72, -95.42], [29.60, -95.45], [29.50, -95.38], [29.48, -95.25], [29.55, -95.15], [29.68, -95.12], [29.75, -95.18]] },
                        { floor: 1800, ceiling: 4000, polygon: [[29.82, -95.08], [29.88, -95.28], [29.80, -95.48], [29.62, -95.55], [29.45, -95.45], [29.40, -95.25], [29.50, -95.05], [29.70, -94.98], [29.82, -95.08]] }
                    ]
                },
                {
                    name: 'Las Vegas Class C',
                    center: [36.0840, -115.1537],
                    tiers: [
                        { floor: 0, ceiling: 10000, polygon: [[36.20, -115.05], [36.25, -115.18], [36.20, -115.32], [36.05, -115.38], [35.92, -115.30], [35.88, -115.15], [35.95, -115.02], [36.10, -114.98], [36.20, -115.05]] },
                        { floor: 3000, ceiling: 10000, polygon: [[36.30, -114.92], [36.38, -115.15], [36.30, -115.42], [36.08, -115.52], [35.85, -115.40], [35.78, -115.15], [35.88, -114.90], [36.12, -114.82], [36.30, -114.92]] }
                    ]
                },
                {
                    name: 'Portland Class C',
                    center: [45.5898, -122.5951],
                    tiers: [
                        { floor: 0, ceiling: 7000, polygon: [[45.72, -122.48], [45.75, -122.62], [45.70, -122.78], [45.55, -122.85], [45.42, -122.78], [45.38, -122.60], [45.45, -122.45], [45.60, -122.40], [45.72, -122.48]] },
                        { floor: 2000, ceiling: 7000, polygon: [[45.82, -122.35], [45.88, -122.58], [45.80, -122.88], [45.58, -123.00], [45.35, -122.90], [45.28, -122.60], [45.38, -122.32], [45.62, -122.22], [45.82, -122.35]] }
                    ]
                },
                {
                    name: 'Austin Class C',
                    center: [30.1945, -97.6699],
                    tiers: [
                        { floor: 0, ceiling: 6000, polygon: [[30.32, -97.55], [30.35, -97.70], [30.30, -97.85], [30.15, -97.92], [30.02, -97.85], [29.98, -97.68], [30.05, -97.52], [30.20, -97.48], [30.32, -97.55]] },
                        { floor: 2000, ceiling: 6000, polygon: [[30.42, -97.42], [30.48, -97.65], [30.40, -97.95], [30.18, -98.05], [29.95, -97.95], [29.88, -97.65], [29.98, -97.38], [30.22, -97.28], [30.42, -97.42]] }
                    ]
                },
                {
                    name: 'San Antonio Class C',
                    center: [29.5337, -98.4698],
                    tiers: [
                        { floor: 0, ceiling: 5000, polygon: [[29.65, -98.35], [29.68, -98.50], [29.63, -98.65], [29.48, -98.72], [29.35, -98.65], [29.32, -98.48], [29.38, -98.32], [29.53, -98.28], [29.65, -98.35]] },
                        { floor: 1800, ceiling: 5000, polygon: [[29.75, -98.22], [29.80, -98.45], [29.73, -98.75], [29.52, -98.85], [29.28, -98.75], [29.22, -98.45], [29.30, -98.18], [29.55, -98.08], [29.75, -98.22]] }
                    ]
                },
                {
                    name: 'Nashville Class C',
                    center: [36.1245, -86.6782],
                    tiers: [
                        { floor: 0, ceiling: 5000, polygon: [[36.25, -86.55], [36.28, -86.70], [36.23, -86.85], [36.08, -86.92], [35.95, -86.85], [35.92, -86.68], [35.98, -86.52], [36.13, -86.48], [36.25, -86.55]] },
                        { floor: 1800, ceiling: 5000, polygon: [[36.35, -86.42], [36.40, -86.65], [36.33, -86.95], [36.12, -87.05], [35.88, -86.95], [35.82, -86.65], [35.90, -86.38], [36.15, -86.28], [36.35, -86.42]] }
                    ]
                },
                {
                    name: 'Indianapolis Class C',
                    center: [39.7173, -86.2944],
                    tiers: [
                        { floor: 0, ceiling: 8000, polygon: [[39.85, -86.15], [39.88, -86.32], [39.83, -86.48], [39.68, -86.55], [39.52, -86.48], [39.48, -86.30], [39.55, -86.12], [39.72, -86.08], [39.85, -86.15]] },
                        { floor: 2500, ceiling: 8000, polygon: [[39.95, -86.00], [40.00, -86.28], [39.93, -86.60], [39.72, -86.72], [39.45, -86.60], [39.38, -86.28], [39.48, -85.98], [39.75, -85.88], [39.95, -86.00]] }
                    ]
                },
                {
                    name: 'Columbus Class C',
                    center: [39.9980, -82.8919],
                    tiers: [
                        { floor: 0, ceiling: 5000, polygon: [[40.12, -82.75], [40.15, -82.92], [40.10, -83.08], [39.95, -83.15], [39.82, -83.08], [39.78, -82.90], [39.85, -82.72], [40.00, -82.68], [40.12, -82.75]] },
                        { floor: 1800, ceiling: 5000, polygon: [[40.22, -82.62], [40.28, -82.88], [40.20, -83.18], [39.98, -83.28], [39.72, -83.18], [39.65, -82.88], [39.75, -82.58], [40.02, -82.48], [40.22, -82.62]] }
                    ]
                },
                {
                    name: 'Raleigh-Durham Class C',
                    center: [35.8776, -78.7875],
                    tiers: [
                        { floor: 0, ceiling: 5000, polygon: [[36.00, -78.65], [36.03, -78.82], [35.98, -78.98], [35.83, -79.05], [35.70, -78.98], [35.67, -78.80], [35.73, -78.62], [35.88, -78.58], [36.00, -78.65]] },
                        { floor: 1800, ceiling: 5000, polygon: [[36.10, -78.52], [36.15, -78.78], [36.08, -79.08], [35.87, -79.18], [35.62, -79.08], [35.55, -78.78], [35.65, -78.48], [35.90, -78.38], [36.10, -78.52]] }
                    ]
                },
                {
                    name: 'Baltimore Class C',
                    center: [39.1754, -76.6683],
                    tiers: [
                        { floor: 0, ceiling: 4000, polygon: [[39.30, -76.55], [39.33, -76.70], [39.28, -76.85], [39.13, -76.92], [39.00, -76.85], [38.97, -76.68], [39.03, -76.52], [39.18, -76.48], [39.30, -76.55]] },
                        { floor: 1500, ceiling: 4000, polygon: [[39.40, -76.42], [39.45, -76.65], [39.38, -76.95], [39.17, -77.05], [38.92, -76.95], [38.85, -76.65], [38.95, -76.38], [39.20, -76.28], [39.40, -76.42]] }
                    ]
                },
                {
                    name: 'New Orleans Class C',
                    center: [29.9934, -90.2580],
                    tiers: [
                        { floor: 0, ceiling: 5000, polygon: [[30.12, -90.15], [30.15, -90.28], [30.10, -90.42], [29.95, -90.48], [29.82, -90.42], [29.78, -90.25], [29.85, -90.12], [30.00, -90.08], [30.12, -90.15]] },
                        { floor: 1800, ceiling: 5000, polygon: [[30.22, -90.02], [30.28, -90.25], [30.20, -90.52], [29.98, -90.62], [29.72, -90.52], [29.65, -90.25], [29.75, -89.98], [30.02, -89.88], [30.22, -90.02]] }
                    ]
                },
                {
                    name: 'Memphis Class C',
                    center: [35.0424, -89.9767],
                    tiers: [
                        { floor: 0, ceiling: 5000, polygon: [[35.17, -89.85], [35.20, -90.00], [35.15, -90.15], [35.00, -90.22], [34.87, -90.15], [34.83, -89.98], [34.90, -89.82], [35.05, -89.78], [35.17, -89.85]] },
                        { floor: 1800, ceiling: 5000, polygon: [[35.27, -89.72], [35.32, -89.95], [35.25, -90.25], [35.03, -90.35], [34.78, -90.25], [34.72, -89.95], [34.80, -89.68], [35.07, -89.58], [35.27, -89.72]] }
                    ]
                },
                {
                    name: 'Jacksonville Class C',
                    center: [30.4941, -81.6879],
                    tiers: [
                        { floor: 0, ceiling: 5000, polygon: [[30.62, -81.55], [30.65, -81.72], [30.60, -81.88], [30.45, -81.95], [30.32, -81.88], [30.28, -81.70], [30.35, -81.52], [30.50, -81.48], [30.62, -81.55]] },
                        { floor: 1800, ceiling: 5000, polygon: [[30.72, -81.42], [30.78, -81.68], [30.70, -81.98], [30.48, -82.08], [30.22, -81.98], [30.15, -81.68], [30.25, -81.38], [30.52, -81.28], [30.72, -81.42]] }
                    ]
                },
                {
                    name: 'Albuquerque Class C',
                    center: [35.0402, -106.6094],
                    tiers: [
                        { floor: 0, ceiling: 10800, polygon: [[35.17, -106.48], [35.20, -106.63], [35.15, -106.78], [35.00, -106.85], [34.87, -106.78], [34.83, -106.61], [34.90, -106.45], [35.05, -106.41], [35.17, -106.48]] },
                        { floor: 3500, ceiling: 10800, polygon: [[35.27, -106.35], [35.32, -106.58], [35.25, -106.88], [35.03, -106.98], [34.78, -106.88], [34.72, -106.58], [34.80, -106.31], [35.07, -106.21], [35.27, -106.35]] }
                    ]
                },
                {
                    name: 'Oklahoma City Class C',
                    center: [35.3931, -97.6007],
                    tiers: [
                        { floor: 0, ceiling: 5000, polygon: [[35.52, -97.48], [35.55, -97.62], [35.50, -97.78], [35.35, -97.85], [35.22, -97.78], [35.18, -97.60], [35.25, -97.45], [35.40, -97.41], [35.52, -97.48]] },
                        { floor: 1800, ceiling: 5000, polygon: [[35.62, -97.35], [35.68, -97.58], [35.60, -97.88], [35.38, -97.98], [35.12, -97.88], [35.05, -97.58], [35.15, -97.31], [35.42, -97.21], [35.62, -97.35]] }
                    ]
                },
                {
                    name: 'Tucson Class C',
                    center: [32.1161, -110.9410],
                    tiers: [
                        { floor: 0, ceiling: 9000, polygon: [[32.24, -110.82], [32.27, -110.96], [32.22, -111.12], [32.07, -111.18], [31.94, -111.12], [31.90, -110.94], [31.97, -110.78], [32.12, -110.74], [32.24, -110.82]] },
                        { floor: 3000, ceiling: 9000, polygon: [[32.34, -110.68], [32.40, -110.92], [32.32, -111.22], [32.10, -111.32], [31.85, -111.22], [31.78, -110.92], [31.88, -110.64], [32.15, -110.54], [32.34, -110.68]] }
                    ]
                },
                {
                    name: 'Buffalo Class C',
                    center: [42.9405, -78.7322],
                    tiers: [
                        { floor: 0, ceiling: 4500, polygon: [[43.07, -78.60], [43.10, -78.75], [43.05, -78.90], [42.90, -78.97], [42.77, -78.90], [42.73, -78.73], [42.80, -78.57], [42.95, -78.53], [43.07, -78.60]] },
                        { floor: 1800, ceiling: 4500, polygon: [[43.17, -78.47], [43.22, -78.72], [43.15, -79.00], [42.93, -79.10], [42.68, -79.00], [42.62, -78.72], [42.70, -78.44], [42.97, -78.34], [43.17, -78.47]] }
                    ]
                },
                {
                    name: 'Anchorage Class C',
                    center: [61.1743, -149.9962],
                    tiers: [
                        { floor: 0, ceiling: 6000, polygon: [[61.32, -149.80], [61.35, -150.05], [61.28, -150.28], [61.10, -150.38], [60.95, -150.28], [60.90, -150.02], [60.98, -149.78], [61.18, -149.68], [61.32, -149.80]] },
                        { floor: 2000, ceiling: 6000, polygon: [[61.42, -149.60], [61.48, -149.98], [61.38, -150.40], [61.15, -150.55], [60.92, -150.42], [60.82, -150.00], [60.95, -149.58], [61.22, -149.45], [61.42, -149.60]] }
                    ]
                },
                {
                    name: 'Fort Lauderdale Class C',
                    center: [26.0726, -80.1527],
                    tiers: [
                        { floor: 0, ceiling: 3000, polygon: [[26.20, -80.05], [26.23, -80.18], [26.18, -80.32], [26.03, -80.38], [25.90, -80.32], [25.87, -80.15], [25.93, -80.00], [26.08, -79.96], [26.20, -80.05]] },
                        { floor: 1200, ceiling: 3000, polygon: [[26.30, -79.92], [26.35, -80.12], [26.28, -80.40], [26.07, -80.50], [25.82, -80.40], [25.75, -80.12], [25.85, -79.85], [26.12, -79.75], [26.30, -79.92]] }
                    ]
                },
                {
                    name: 'Birmingham Class C',
                    center: [33.5629, -86.7535],
                    tiers: [
                        { floor: 0, ceiling: 5000, polygon: [[33.69, -86.62], [33.72, -86.78], [33.67, -86.92], [33.52, -86.98], [33.39, -86.92], [33.35, -86.75], [33.42, -86.60], [33.57, -86.56], [33.69, -86.62]] },
                        { floor: 2000, ceiling: 5000, polygon: [[33.79, -86.50], [33.85, -86.72], [33.77, -87.00], [33.55, -87.10], [33.30, -87.00], [33.23, -86.72], [33.33, -86.46], [33.60, -86.36], [33.79, -86.50]] }
                    ]
                }
            ],
            // MOAs (Military Operating Areas)
            moa: [
                // Southwest US
                { name: 'Tombstone MOA', polygon: [[32.5, -110.5], [32.5, -109.5], [31.5, -109.5], [31.5, -110.5]], floor: 500, ceiling: 17999 },
                { name: 'Gladden MOA', polygon: [[33.0, -112.5], [33.0, -111.5], [32.0, -111.5], [32.0, -112.5]], floor: 500, ceiling: 17999 },
                { name: 'Sells MOA', polygon: [[32.5, -112.5], [32.5, -111.5], [31.5, -111.5], [31.5, -112.5]], floor: 500, ceiling: 17999 },
                { name: 'Jackal MOA', polygon: [[33.5, -110.0], [33.5, -109.0], [32.5, -109.0], [32.5, -110.0]], floor: 500, ceiling: 17999 },
                // Texas
                { name: 'Brownwood MOA', polygon: [[32.5, -99.5], [32.5, -98.5], [31.5, -98.5], [31.5, -99.5]], floor: 8000, ceiling: 17999 },
                { name: 'Lancer MOA', polygon: [[33.0, -102.0], [33.0, -101.0], [32.0, -101.0], [32.0, -102.0]], floor: 100, ceiling: 17999 },
                { name: 'Texon MOA', polygon: [[31.5, -102.5], [31.5, -101.5], [30.5, -101.5], [30.5, -102.5]], floor: 500, ceiling: 17999 },
                { name: 'Sheppard MOA', polygon: [[34.5, -99.0], [34.5, -98.0], [33.5, -98.0], [33.5, -99.0]], floor: 500, ceiling: 17999 },
                // Southeast US
                { name: 'Bulldog MOA', polygon: [[32.0, -84.5], [32.0, -83.5], [31.0, -83.5], [31.0, -84.5]], floor: 8000, ceiling: 17999 },
                { name: 'Moody MOA', polygon: [[31.5, -84.0], [31.5, -83.0], [30.5, -83.0], [30.5, -84.0]], floor: 8000, ceiling: 17999 },
                { name: 'Pinehill MOA', polygon: [[32.5, -92.5], [32.5, -91.5], [31.5, -91.5], [31.5, -92.5]], floor: 500, ceiling: 17999 },
                { name: 'Beaumont MOA', polygon: [[30.5, -94.5], [30.5, -93.5], [29.5, -93.5], [29.5, -94.5]], floor: 500, ceiling: 17999 },
                // East Coast
                { name: 'Pamlico MOA', polygon: [[35.5, -76.5], [35.5, -75.5], [34.5, -75.5], [34.5, -76.5]], floor: 500, ceiling: 17999 },
                { name: 'Stumpy Point MOA', polygon: [[36.0, -76.0], [36.0, -75.0], [35.0, -75.0], [35.0, -76.0]], floor: 500, ceiling: 17999 },
                { name: 'Dare County MOA', polygon: [[36.5, -76.0], [36.5, -75.0], [35.5, -75.0], [35.5, -76.0]], floor: 8000, ceiling: 17999 },
                // Pacific Coast
                { name: 'Warning W-289', polygon: [[36.5, -122.5], [36.5, -121.5], [35.5, -121.5], [35.5, -122.5]], floor: 0, ceiling: 99999 },
                { name: 'Warning W-290', polygon: [[37.5, -123.0], [37.5, -122.0], [36.5, -122.0], [36.5, -123.0]], floor: 0, ceiling: 99999 },
                { name: 'Olympic MOA', polygon: [[48.0, -124.0], [48.0, -123.0], [47.0, -123.0], [47.0, -124.0]], floor: 6000, ceiling: 17999 },
                // Central US
                { name: 'Eureka MOA', polygon: [[39.5, -100.0], [39.5, -99.0], [38.5, -99.0], [38.5, -100.0]], floor: 500, ceiling: 17999 },
                { name: 'Smoky MOA', polygon: [[39.0, -101.0], [39.0, -100.0], [38.0, -100.0], [38.0, -101.0]], floor: 8000, ceiling: 17999 },
                { name: 'Jefferson City MOA', polygon: [[39.0, -92.5], [39.0, -91.5], [38.0, -91.5], [38.0, -92.5]], floor: 3000, ceiling: 17999 },
                // Northern US
                { name: 'Volk MOA', polygon: [[44.5, -90.5], [44.5, -89.5], [43.5, -89.5], [43.5, -90.5]], floor: 7000, ceiling: 17999 },
                { name: 'Grayling MOA', polygon: [[45.0, -84.5], [45.0, -83.5], [44.0, -83.5], [44.0, -84.5]], floor: 500, ceiling: 17999 },
                { name: 'Alpena MOA', polygon: [[45.5, -84.0], [45.5, -83.0], [44.5, -83.0], [44.5, -84.0]], floor: 5000, ceiling: 17999 },
                // Mountain West
                { name: 'Sundance MOA', polygon: [[44.0, -105.5], [44.0, -104.5], [43.0, -104.5], [43.0, -105.5]], floor: 100, ceiling: 17999 },
                { name: 'Hart MOA', polygon: [[43.5, -109.5], [43.5, -108.5], [42.5, -108.5], [42.5, -109.5]], floor: 500, ceiling: 17999 },
                { name: 'Jarbidge MOA', polygon: [[42.0, -115.5], [42.0, -114.5], [41.0, -114.5], [41.0, -115.5]], floor: 100, ceiling: 17999 },
            ],
            // Restricted areas with polygon shapes
            restricted: [
                // California/Nevada
                { name: 'R-2508 Complex', polygon: [[36.5, -118.5], [36.5, -116.5], [35.0, -116.5], [35.0, -117.5], [34.5, -117.5], [34.5, -118.5]], floor: 0, ceiling: 99999 },
                { name: 'R-4807 (Nellis Range)', polygon: [[38.0, -116.5], [38.0, -115.0], [36.5, -115.0], [36.5, -116.5]], floor: 0, ceiling: 99999 },
                { name: 'R-4809 (Nellis South)', polygon: [[36.5, -116.0], [36.5, -115.0], [35.5, -115.0], [35.5, -116.0]], floor: 0, ceiling: 50000 },
                { name: 'R-5107 (Ft Irwin)', polygon: [[35.5, -117.0], [35.5, -116.0], [34.8, -116.0], [34.8, -117.0]], floor: 0, ceiling: 30000 },
                { name: 'R-2502 (Twentynine Palms)', polygon: [[34.5, -116.5], [34.5, -115.5], [33.8, -115.5], [33.8, -116.5]], floor: 0, ceiling: 99999 },
                { name: 'R-2505 (China Lake)', polygon: [[36.0, -118.0], [36.0, -117.0], [35.2, -117.0], [35.2, -118.0]], floor: 0, ceiling: 99999 },
                // Southeast
                { name: 'R-2301 (Eglin)', polygon: [[30.8, -86.8], [30.8, -85.8], [30.2, -85.8], [30.2, -86.8]], floor: 0, ceiling: 50000 },
                { name: 'R-2914 (Avon Park)', polygon: [[27.8, -81.5], [27.8, -81.0], [27.3, -81.0], [27.3, -81.5]], floor: 0, ceiling: 25000 },
                { name: 'R-2915 (Pinecastle)', polygon: [[29.2, -81.5], [29.2, -81.0], [28.8, -81.0], [28.8, -81.5]], floor: 0, ceiling: 10000 },
                { name: 'R-5306 (Dare County)', polygon: [[35.8, -76.2], [35.8, -75.8], [35.4, -75.8], [35.4, -76.2]], floor: 0, ceiling: 50000 },
                // East Coast
                { name: 'R-5601 (Cherry Point)', polygon: [[35.0, -77.2], [35.0, -76.5], [34.5, -76.5], [34.5, -77.2]], floor: 0, ceiling: 50000 },
                { name: 'R-6609 (Beaufort)', polygon: [[32.8, -80.8], [32.8, -80.4], [32.4, -80.4], [32.4, -80.8]], floor: 0, ceiling: 8000 },
                { name: 'R-5302 (Ft Bragg)', polygon: [[35.3, -79.5], [35.3, -79.0], [34.9, -79.0], [34.9, -79.5]], floor: 0, ceiling: 12000 },
                // Southwest
                { name: 'R-2310 (White Sands)', polygon: [[33.5, -107.0], [33.5, -105.5], [32.0, -105.5], [32.0, -107.0]], floor: 0, ceiling: 99999 },
                { name: 'R-5103 (Yuma)', polygon: [[33.0, -114.5], [33.0, -113.5], [32.2, -113.5], [32.2, -114.5]], floor: 0, ceiling: 99999 },
                { name: 'R-2311 (Holloman)', polygon: [[33.2, -106.5], [33.2, -106.0], [32.8, -106.0], [32.8, -106.5]], floor: 0, ceiling: 50000 },
                // Mountain/Plains
                { name: 'R-6401 (Warren AFB)', polygon: [[41.5, -105.0], [41.5, -104.5], [41.0, -104.5], [41.0, -105.0]], floor: 0, ceiling: 15000 },
                { name: 'R-2601 (Ft Hood)', polygon: [[31.5, -98.0], [31.5, -97.5], [31.0, -97.5], [31.0, -98.0]], floor: 0, ceiling: 7000 },
                // Alaska
                { name: 'R-2205 (Fairbanks)', polygon: [[65.0, -147.5], [65.0, -146.5], [64.5, -146.5], [64.5, -147.5]], floor: 0, ceiling: 99999 },
                { name: 'R-2206 (Eielson)', polygon: [[64.8, -147.0], [64.8, -146.0], [64.3, -146.0], [64.3, -147.0]], floor: 0, ceiling: 50000 },
            ],
            // Prohibited areas
            prohibited: [
                // Washington DC Area
                { name: 'P-56A (White House)', polygon: [[38.905, -77.045], [38.905, -77.028], [38.890, -77.028], [38.890, -77.045]], floor: 0, ceiling: 18000 },
                { name: 'P-56B (Naval Observatory)', polygon: [[38.930, -77.075], [38.930, -77.058], [38.915, -77.058], [38.915, -77.075]], floor: 0, ceiling: 18000 },
                { name: 'P-40 (Camp David)', polygon: [[39.655, -77.475], [39.655, -77.445], [39.635, -77.445], [39.635, -77.475]], floor: 0, ceiling: 99999 },
                { name: 'P-49 (Mt Vernon)', polygon: [[38.715, -77.095], [38.715, -77.075], [38.700, -77.075], [38.700, -77.095]], floor: 0, ceiling: 1500 },
                // Other National Sites
                { name: 'P-73 (Kennedy Space Center)', polygon: [[28.65, -80.70], [28.65, -80.55], [28.50, -80.55], [28.50, -80.70]], floor: 0, ceiling: 99999 },
                { name: 'P-67 (Pantex Nuclear)', polygon: [[35.35, -101.58], [35.35, -101.52], [35.30, -101.52], [35.30, -101.58]], floor: 0, ceiling: 5000 },
            ],
            // TFRs (simulated - would need real-time API) with polygon shapes
            tfr: [
                { name: 'TFR - VIP Movement', polygon: [[39.35, -77.0], [39.20, -76.55], [38.90, -76.45], [38.55, -76.60], [38.45, -77.0], [38.55, -77.40], [38.90, -77.55], [39.20, -77.45]], floor: 0, ceiling: 18000, active: true },
            ],
            // Class D airports with irregular polygon shapes (4nm radius approximated)
            classD: [
                // New York Metro
                { name: 'Teterboro (KTEB)', center: [40.8501, -74.0608], polygon: [[40.92, -74.06], [40.89, -73.98], [40.85, -73.96], [40.80, -73.99], [40.78, -74.06], [40.80, -74.13], [40.85, -74.15], [40.90, -74.12]], floor: 0, ceiling: 2500 },
                { name: 'Republic (KFRG)', center: [40.7288, -73.4134], polygon: [[40.80, -73.41], [40.77, -73.33], [40.73, -73.31], [40.68, -73.34], [40.66, -73.41], [40.68, -73.48], [40.73, -73.50], [40.78, -73.47]], floor: 0, ceiling: 2500 },
                { name: 'Westchester (KHPN)', center: [41.0670, -73.7076], polygon: [[41.14, -73.71], [41.11, -73.63], [41.07, -73.61], [41.02, -73.64], [40.99, -73.71], [41.02, -73.78], [41.07, -73.80], [41.12, -73.77]], floor: 0, ceiling: 2500 },
                // Los Angeles Area
                { name: 'Van Nuys (KVNY)', center: [34.2098, -118.4895], polygon: [[34.28, -118.49], [34.25, -118.41], [34.21, -118.39], [34.16, -118.42], [34.14, -118.49], [34.16, -118.56], [34.21, -118.58], [34.26, -118.55]], floor: 0, ceiling: 3500 },
                { name: 'Long Beach (KLGB)', center: [33.8177, -118.1516], polygon: [[33.88, -118.15], [33.86, -118.08], [33.82, -118.06], [33.77, -118.09], [33.75, -118.15], [33.77, -118.21], [33.82, -118.23], [33.86, -118.20]], floor: 0, ceiling: 2500 },
                { name: 'Santa Monica (KSMO)', center: [34.0158, -118.4513], polygon: [[34.08, -118.45], [34.06, -118.38], [34.02, -118.36], [33.97, -118.39], [33.95, -118.45], [33.97, -118.51], [34.02, -118.53], [34.06, -118.50]], floor: 0, ceiling: 2500 },
                { name: 'Burbank (KBUR)', center: [34.2007, -118.3585], polygon: [[34.27, -118.36], [34.24, -118.28], [34.20, -118.26], [34.15, -118.29], [34.13, -118.36], [34.15, -118.43], [34.20, -118.45], [34.25, -118.42]], floor: 0, ceiling: 3000 },
                { name: 'John Wayne (KSNA)', center: [33.6757, -117.8682], polygon: [[33.74, -117.87], [33.72, -117.79], [33.68, -117.77], [33.63, -117.80], [33.61, -117.87], [33.63, -117.94], [33.68, -117.96], [33.72, -117.93]], floor: 0, ceiling: 2700 },
                { name: 'Torrance (KTOA)', center: [33.8034, -118.3396], polygon: [[33.87, -118.34], [33.85, -118.26], [33.80, -118.24], [33.75, -118.27], [33.73, -118.34], [33.75, -118.41], [33.80, -118.43], [33.85, -118.40]], floor: 0, ceiling: 2500 },
                // San Francisco Bay Area
                { name: 'Oakland (KOAK)', center: [37.7213, -122.2208], polygon: [[37.79, -122.22], [37.76, -122.14], [37.72, -122.12], [37.67, -122.15], [37.65, -122.22], [37.67, -122.29], [37.72, -122.31], [37.77, -122.28]], floor: 0, ceiling: 2500 },
                { name: 'San Jose (KSJC)', center: [37.3626, -121.9291], polygon: [[37.43, -121.93], [37.40, -121.85], [37.36, -121.83], [37.31, -121.86], [37.29, -121.93], [37.31, -122.00], [37.36, -122.02], [37.41, -121.99]], floor: 0, ceiling: 2500 },
                { name: 'Palo Alto (KPAO)', center: [37.4613, -122.1150], polygon: [[37.53, -122.12], [37.50, -122.04], [37.46, -122.02], [37.41, -122.05], [37.39, -122.12], [37.41, -122.19], [37.46, -122.21], [37.51, -122.18]], floor: 0, ceiling: 2500 },
                { name: 'Hayward (KHWD)', center: [37.6591, -122.1217], polygon: [[37.73, -122.12], [37.70, -122.04], [37.66, -122.02], [37.61, -122.05], [37.59, -122.12], [37.61, -122.19], [37.66, -122.21], [37.71, -122.18]], floor: 0, ceiling: 2500 },
                // Chicago Area
                { name: 'Midway (KMDW)', center: [41.7868, -87.7522], polygon: [[41.85, -87.75], [41.83, -87.68], [41.79, -87.66], [41.74, -87.69], [41.72, -87.75], [41.74, -87.81], [41.79, -87.83], [41.83, -87.80]], floor: 0, ceiling: 3000 },
                { name: 'DuPage (KDPA)', center: [41.9078, -88.2486], polygon: [[41.98, -88.25], [41.95, -88.17], [41.91, -88.15], [41.86, -88.18], [41.84, -88.25], [41.86, -88.32], [41.91, -88.34], [41.96, -88.31]], floor: 0, ceiling: 3000 },
                { name: 'Aurora (KARR)', center: [41.7719, -88.4756], polygon: [[41.84, -88.48], [41.81, -88.40], [41.77, -88.38], [41.72, -88.41], [41.70, -88.48], [41.72, -88.55], [41.77, -88.57], [41.82, -88.54]], floor: 0, ceiling: 2800 },
                // Texas
                { name: 'Love Field (KDAL)', center: [32.8471, -96.8518], polygon: [[32.91, -96.85], [32.89, -96.78], [32.85, -96.76], [32.80, -96.79], [32.78, -96.85], [32.80, -96.91], [32.85, -96.93], [32.89, -96.90]], floor: 0, ceiling: 3500 },
                { name: 'Addison (KADS)', center: [32.9686, -96.8364], polygon: [[33.04, -96.84], [33.01, -96.76], [32.97, -96.74], [32.92, -96.77], [32.90, -96.84], [32.92, -96.91], [32.97, -96.93], [33.02, -96.90]], floor: 0, ceiling: 3000 },
                { name: 'Hobby (KHOU)', center: [29.6454, -95.2789], polygon: [[29.71, -95.28], [29.69, -95.20], [29.65, -95.18], [29.60, -95.21], [29.58, -95.28], [29.60, -95.35], [29.65, -95.37], [29.69, -95.34]], floor: 0, ceiling: 3000 },
                // Washington DC
                { name: 'Reagan National (KDCA)', center: [38.8512, -77.0402], polygon: [[38.92, -77.04], [38.89, -76.97], [38.85, -76.95], [38.80, -76.98], [38.78, -77.04], [38.80, -77.10], [38.85, -77.12], [38.90, -77.09]], floor: 0, ceiling: 2500 },
                { name: 'College Park (KCGS)', center: [38.9806, -76.9224], polygon: [[39.05, -76.92], [39.02, -76.84], [38.98, -76.82], [38.93, -76.85], [38.91, -76.92], [38.93, -76.99], [38.98, -77.01], [39.03, -76.98]], floor: 0, ceiling: 2500 },
                { name: 'Manassas (KHEF)', center: [38.7214, -77.5155], polygon: [[38.79, -77.52], [38.76, -77.44], [38.72, -77.42], [38.67, -77.45], [38.65, -77.52], [38.67, -77.59], [38.72, -77.61], [38.77, -77.58]], floor: 0, ceiling: 2500 },
                // Florida
                { name: 'Boca Raton (KBCT)', center: [26.3785, -80.1077], polygon: [[26.45, -80.11], [26.42, -80.03], [26.38, -80.01], [26.33, -80.04], [26.31, -80.11], [26.33, -80.18], [26.38, -80.20], [26.43, -80.17]], floor: 0, ceiling: 2000 },
                { name: 'Naples (KAPF)', center: [26.1526, -81.7753], polygon: [[26.22, -81.78], [26.19, -81.70], [26.15, -81.68], [26.10, -81.71], [26.08, -81.78], [26.10, -81.85], [26.15, -81.87], [26.20, -81.84]], floor: 0, ceiling: 2500 },
                { name: 'Sarasota (KSRQ)', center: [27.3954, -82.5544], polygon: [[27.47, -82.55], [27.44, -82.47], [27.40, -82.45], [27.35, -82.48], [27.32, -82.55], [27.35, -82.62], [27.40, -82.64], [27.45, -82.61]], floor: 0, ceiling: 2500 },
                { name: 'St Petersburg (KPIE)', center: [27.9102, -82.6874], polygon: [[27.98, -82.69], [27.95, -82.61], [27.91, -82.59], [27.86, -82.62], [27.84, -82.69], [27.86, -82.76], [27.91, -82.78], [27.96, -82.75]], floor: 0, ceiling: 2500 },
                // Pacific Northwest
                { name: 'Boeing Field (KBFI)', center: [47.5300, -122.3019], polygon: [[47.60, -122.30], [47.57, -122.22], [47.53, -122.20], [47.48, -122.23], [47.46, -122.30], [47.48, -122.37], [47.53, -122.39], [47.58, -122.36]], floor: 0, ceiling: 2500 },
                { name: 'Paine Field (KPAE)', center: [47.9063, -122.2816], polygon: [[47.98, -122.28], [47.95, -122.20], [47.91, -122.18], [47.86, -122.21], [47.83, -122.28], [47.86, -122.35], [47.91, -122.37], [47.96, -122.34]], floor: 0, ceiling: 2500 },
                { name: 'Hillsboro (KHIO)', center: [45.5404, -122.9499], polygon: [[45.61, -122.95], [45.58, -122.87], [45.54, -122.85], [45.49, -122.88], [45.47, -122.95], [45.49, -123.02], [45.54, -123.04], [45.59, -123.01]], floor: 0, ceiling: 2500 },
                // Arizona
                { name: 'Scottsdale (KSDL)', center: [33.6229, -111.9107], polygon: [[33.69, -111.91], [33.66, -111.83], [33.62, -111.81], [33.57, -111.84], [33.55, -111.91], [33.57, -111.98], [33.62, -112.00], [33.67, -111.97]], floor: 0, ceiling: 3000 },
                { name: 'Deer Valley (KDVT)', center: [33.6883, -112.0833], polygon: [[33.76, -112.08], [33.73, -112.00], [33.69, -111.98], [33.64, -112.01], [33.62, -112.08], [33.64, -112.15], [33.69, -112.17], [33.74, -112.14]], floor: 0, ceiling: 2800 },
                { name: 'Chandler (KCHD)', center: [33.2691, -111.8111], polygon: [[33.34, -111.81], [33.31, -111.73], [33.27, -111.71], [33.22, -111.74], [33.20, -111.81], [33.22, -111.88], [33.27, -111.90], [33.32, -111.87]], floor: 0, ceiling: 2500 },
                // Colorado
                { name: 'Centennial (KAPA)', center: [39.5701, -104.8493], polygon: [[39.64, -104.85], [39.61, -104.77], [39.57, -104.75], [39.52, -104.78], [39.50, -104.85], [39.52, -104.92], [39.57, -104.94], [39.62, -104.91]], floor: 0, ceiling: 8000 },
                { name: 'Rocky Mountain (KBJC)', center: [39.9088, -105.1173], polygon: [[39.98, -105.12], [39.95, -105.04], [39.91, -105.02], [39.86, -105.05], [39.84, -105.12], [39.86, -105.19], [39.91, -105.21], [39.96, -105.18]], floor: 0, ceiling: 7500 },
                // Mountain/Plains
                { name: 'Spirit of St Louis (KSUS)', center: [38.6620, -90.6520], polygon: [[38.73, -90.65], [38.70, -90.57], [38.66, -90.55], [38.61, -90.58], [38.59, -90.65], [38.61, -90.72], [38.66, -90.74], [38.71, -90.71]], floor: 0, ceiling: 2600 },
                // Georgia
                { name: 'PDK DeKalb (KPDK)', center: [33.8756, -84.3020], polygon: [[33.95, -84.30], [33.92, -84.22], [33.88, -84.20], [33.83, -84.23], [33.80, -84.30], [33.83, -84.37], [33.88, -84.39], [33.93, -84.36]], floor: 0, ceiling: 2500 },
                { name: 'Cobb County (KRYY)', center: [34.0132, -84.5971], polygon: [[34.08, -84.60], [34.05, -84.52], [34.01, -84.50], [33.96, -84.53], [33.94, -84.60], [33.96, -84.67], [34.01, -84.69], [34.06, -84.66]], floor: 0, ceiling: 2500 }
            ]
        };

        function createAirspaceOverlay() {
            airspaceLayer.clearLayers();
            const zoomLevel = map.getZoom();

            // Class B - Blue with multiple tiers
            airspaceData.classB.forEach(airspace => {
                // Check if any tier intersects route
                if (routeOverlaysActive && !airspace.tiers.some(t => zoneIntersectsRoute(t.polygon))) return;
                airspace.tiers.forEach((tier, index) => {
                    const refinedCoords = refinePolygon(tier.polygon, zoomLevel);
                    const polygon = L.polygon(refinedCoords, {
                        color: '#3b82f6',
                        fillColor: '#3b82f6',
                        fillOpacity: 0.05 + (index * 0.03),
                        weight: index === 0 ? 2 : 1,
                        dashArray: index === 0 ? null : '4, 4'
                    });
                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:#3b82f6">${airspace.name}</div>
                        <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Class B Airspace - ATC Clearance Required</div>
                        <div><b>Tier:</b> ${index === 0 ? 'Core (Mode C Veil)' : 'Shelf ' + index}</div>
                        <div><b>Floor:</b> ${tier.floor === 0 ? 'Surface' : tier.floor.toLocaleString() + ' ft MSL'}</div>
                        <div><b>Ceiling:</b> ${tier.ceiling.toLocaleString()} ft MSL</div>
                        <div style="margin-top:4px;font-size:10px;opacity:0.9"><b>Requirements:</b> ATC clearance, Mode C transponder, two-way radio</div>
                    `, { sticky: true });
                    airspaceLayer.addLayer(polygon);
                });
            });

            // Class C - Magenta with tiers
            airspaceData.classC.forEach(airspace => {
                // Check if any tier intersects route
                if (routeOverlaysActive && !airspace.tiers.some(t => zoneIntersectsRoute(t.polygon))) return;
                airspace.tiers.forEach((tier, index) => {
                    const refinedCoords = refinePolygon(tier.polygon, zoomLevel);
                    const polygon = L.polygon(refinedCoords, {
                        color: '#ec4899',
                        fillColor: '#ec4899',
                        fillOpacity: 0.08 + (index * 0.04),
                        weight: index === 0 ? 2 : 1,
                        dashArray: index === 0 ? null : '3, 3'
                    });
                    polygon.bindTooltip(`
                        <div style="font-weight:600;margin-bottom:4px;color:#ec4899">${airspace.name}</div>
                        <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Class C Airspace - Two-Way Radio Required</div>
                        <div><b>Tier:</b> ${index === 0 ? 'Core (5 NM radius)' : 'Shelf (10 NM radius)'}</div>
                        <div><b>Floor:</b> ${tier.floor === 0 ? 'Surface' : tier.floor.toLocaleString() + ' ft MSL'}</div>
                        <div><b>Ceiling:</b> ${tier.ceiling.toLocaleString()} ft MSL</div>
                        <div style="margin-top:4px;font-size:10px;opacity:0.9"><b>Requirements:</b> Radio contact, Mode C transponder</div>
                    `, { sticky: true });
                    airspaceLayer.addLayer(polygon);
                });
            });

            // Class D - Dashed blue polygons
            airspaceData.classD.forEach(zone => {
                if (routeOverlaysActive && !zoneIntersectsRoute(zone.polygon)) return;
                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const polygon = L.polygon(refinedCoords, {
                    color: '#60a5fa',
                    fillColor: '#60a5fa',
                    fillOpacity: 0.05,
                    weight: 2,
                    dashArray: '6, 4'
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#60a5fa">${zone.name}</div>
                    <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Class D Airspace - Control Tower Active</div>
                    <div><b>Radius:</b> ~4 NM</div>
                    <div><b>Floor:</b> Surface</div>
                    <div><b>Ceiling:</b> ${zone.ceiling.toLocaleString()} ft AGL</div>
                    <div style="margin-top:4px;font-size:10px;opacity:0.9"><b>Requirements:</b> Two-way radio, establish communication</div>
                `, { sticky: true });
                airspaceLayer.addLayer(polygon);
            });

            // Get cruise altitude for filtering (default 12500 ft if no route)
            const cruiseAltitude = currentRouteData?.cruiseAltitude || 12500;

            // MOAs - Orange/Brown
            airspaceData.moa.forEach(zone => {
                if (routeOverlaysActive && !zoneIntersectsRoute(zone.polygon)) return;
                // Skip zones we fly over (cruise altitude above zone ceiling)
                if (routeOverlaysActive && cruiseAltitude > zone.ceiling) return;

                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const polygon = L.polygon(refinedCoords, {
                    color: '#d97706',
                    fillColor: '#d97706',
                    fillOpacity: 0.1,
                    weight: 2,
                    dashArray: '8, 4'
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#d97706">${zone.name}</div>
                    <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Military Operations Area - Caution Advised</div>
                    <div><b>Floor:</b> ${zone.floor.toLocaleString()} ft MSL</div>
                    <div><b>Ceiling:</b> ${zone.ceiling.toLocaleString()} ft MSL</div>
                    <div style="margin-top:4px;font-size:10px;opacity:0.9"><b>Note:</b> VFR flight permitted but exercise extreme caution. Contact FSS for activity status.</div>
                `, { sticky: true });
                airspaceLayer.addLayer(polygon);
            });

            // Restricted - Red hatched

            airspaceData.restricted.forEach(zone => {
                if (routeOverlaysActive && !zoneIntersectsRoute(zone.polygon)) return;
                // Skip zones we fly over (cruise altitude above zone ceiling)
                if (routeOverlaysActive && cruiseAltitude > zone.ceiling) return;

                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const strictlyIntersects = routeOverlaysActive && zoneIntersectsRoute(zone.polygon, 10);
                const polygon = L.polygon(refinedCoords, {
                    color: '#ef4444',
                    fillColor: '#ef4444',
                    fillOpacity: 0.12,
                    weight: 2,
                    dashArray: '6, 3',
                    className: strictlyIntersects ? 'restricted-pulse' : ''
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#ef4444">${zone.name}</div>
                    <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Restricted Area - Authorization Required</div>
                    <div><b>Floor:</b> Surface</div>
                    <div><b>Ceiling:</b> ${zone.ceiling >= 99999 ? 'Unlimited' : zone.ceiling.toLocaleString() + ' ft MSL'}</div>
                    <div style="margin-top:4px;font-size:10px;opacity:0.9;color:#fca5a5"><b> Warning:</b> Flight prohibited without authorization from controlling agency.</div>
                `, { sticky: true });
                airspaceLayer.addLayer(polygon);
            });

            // Prohibited - Solid red
            airspaceData.prohibited.forEach(zone => {
                if (routeOverlaysActive && !zoneIntersectsRoute(zone.polygon)) return;
                // Skip zones we fly over (cruise altitude above zone ceiling)
                if (routeOverlaysActive && cruiseAltitude > zone.ceiling) return;

                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const strictlyIntersects = routeOverlaysActive && zoneIntersectsRoute(zone.polygon, 10);
                const polygon = L.polygon(refinedCoords, {
                    color: '#dc2626',
                    fillColor: '#dc2626',
                    fillOpacity: 0.25,
                    weight: 3,
                    className: strictlyIntersects ? 'restricted-pulse' : ''
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#dc2626">${zone.name}</div>
                    <div style="font-size:10px;opacity:0.8;margin-bottom:6px">Prohibited Area - NO ENTRY</div>
                    <div><b>Floor:</b> Surface</div>
                    <div><b>Ceiling:</b> ${zone.ceiling >= 99999 ? 'Unlimited' : zone.ceiling.toLocaleString() + ' ft MSL'}</div>
                    <div style="margin-top:4px;font-size:10px;opacity:0.9;color:#fca5a5"><b> PROHIBITED:</b> Flight is strictly forbidden. Interception/prosecution possible.</div>
                `, { sticky: true });
                airspaceLayer.addLayer(polygon);
            });

            // TFRs - Red polygons with warning
            airspaceData.tfr.forEach(zone => {
                if (!zone.active) return;
                if (routeOverlaysActive && !zoneIntersectsRoute(zone.polygon)) return;
                const refinedCoords = refinePolygon(zone.polygon, zoomLevel);
                const polygon = L.polygon(refinedCoords, {
                    color: '#ff0000',
                    fillColor: '#ff0000',
                    fillOpacity: 0.2,
                    weight: 3,
                    dashArray: '5, 5'
                });
                polygon.bindTooltip(`
                    <div style="font-weight:600;margin-bottom:4px;color:#ff0000"> ${zone.name}</div>
                    <div style="font-size:10px;opacity:0.8;margin-bottom:6px;color:#fca5a5">TEMPORARY FLIGHT RESTRICTION - ACTIVE</div>
                    <div><b>Floor:</b> Surface</div>
                    <div><b>Ceiling:</b> ${zone.ceiling.toLocaleString()} ft AGL</div>
                    <div style="margin-top:4px;font-size:10px;opacity:0.9;color:#fca5a5"><b> ACTIVE TFR:</b> Check NOTAMs for specific times and requirements. Interception likely.</div>
                `, { sticky: true });
                airspaceLayer.addLayer(polygon);
            });
        }

        // Initialize airspace
        createAirspaceOverlay();

        // Initialize overlay layers
        createIcingOverlay();
        createTurbulenceOverlay();

        // Refresh polygon overlays when zoom changes for higher fidelity at close zoom
        let zoomRefreshTimeout = null;
        function refreshPolygonOverlays() {
            // Refresh all polygon-based overlays to show higher detail at current zoom
            if (overlayState.terrain) {
                createTerrainOverlay();
            }
            if (overlayState.airspace) {
                createAirspaceOverlay();
            }
            if (overlayState.icing) {
                createIcingOverlay();
            }
            if (overlayState.turbulence) {
                createTurbulenceOverlay();
            }
            if (overlayState.conditions) {
                createConditionsOverlay();
            }
            if (overlayState.temperature) {
                createTemperatureOverlay();
            }
            if (overlayState.dewpoint) {
                createDewpointOverlay();
            }
        }

        // Debounced zoom handler for performance
        map.on('zoomend', function() {
            if (zoomRefreshTimeout) clearTimeout(zoomRefreshTimeout);
            zoomRefreshTimeout = setTimeout(refreshPolygonOverlays, 150);
        });

        // Refresh traffic when map moves significantly
        map.on('moveend', function() {
            if (overlayState.traffic) {
                loadTrafficData();
            }
        });

        // Radar layer (RainViewer API - free weather radar)
        let radarLayer = null;
        let radarTimestamp = null;

        async function loadRadarLayer() {
            try {

                // Get radar timestamps from RainViewer
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                const data = await response.json();

                if (data.radar && data.radar.past && data.radar.past.length > 0) {
                    // Get the most recent radar frame
                    const latestFrame = data.radar.past[data.radar.past.length - 1];
                    radarTimestamp = new Date(latestFrame.time * 1000);

                    // Remove old layer if exists
                    if (radarLayer) {
                        map.removeLayer(radarLayer);
                    }

                    // Add new radar layer
                    radarLayer = L.tileLayer(`https://tilecache.rainviewer.com${latestFrame.path}/256/{z}/{x}/{y}/4/1_1.png`, {
                        opacity: 0.7,
                        zIndex: 100
                    });

                    if (overlayState.radar) {
                        radarLayer.addTo(map);
                    }

                    // Update timestamp display
                    document.getElementById('radarTimestamp').textContent =
                        `Radar: ${radarTimestamp.toLocaleTimeString()} UTC`;
                }
            } catch (error) {
                console.error('Failed to load radar:', error);
                document.getElementById('radarTimestamp').textContent = 'Radar: Error';
            }
        }

        // METAR stations layer
        let metarMarkers = L.layerGroup();
        let dynamicStationsLoaded = false;
        let ourAirportsLoaded = false;

        // Traffic layer (ADS-B)
        const trafficLayer = L.layerGroup();
        let trafficData = [];
        let trafficRefreshTimer = null;
        const TRAFFIC_REFRESH_INTERVAL = 5000; // 5 seconds

        // Load ADS-B traffic data from backend proxy
        async function loadTrafficData() {
            const center = map.getCenter();
            const bounds = map.getBounds();

            // Calculate radius based on map view (approximate)
            const radiusNm = Math.min(100, Math.max(30,
                Math.abs(bounds.getNorth() - bounds.getSouth()) * 30));

            try {
                const response = await fetch(
                    `/api/aviation/adsb?lat=${center.lat}&lon=${center.lng}&dist=${Math.round(radiusNm)}`
                );
                const data = await response.json();

                if (data.ac) {
                    trafficData = data.ac.filter(ac =>
                        ac.lat && ac.lon && ac.hex
                    );
                    renderTrafficMarkers();
                }
            } catch (error) {
                console.warn('Traffic fetch error:', error);
            }
        }

        // Render aircraft markers on the map
        function renderTrafficMarkers() {
            trafficLayer.clearLayers();

            trafficData.forEach(ac => {
                const isOnGround = (ac.alt_baro || 0) < 100;
                const heading = ac.track || 0;

                // Color based on altitude
                let color = '#22c55e'; // Green - low
                if (ac.alt_baro > 10000) color = '#3b82f6'; // Blue - mid
                if (ac.alt_baro > 12500) color = '#8b5cf6'; // Purple - high
                if (isOnGround) color = '#6b7280'; // Gray - ground

                // Aircraft icon with rotation
                const icon = L.divIcon({
                    className: 'traffic-marker',
                    html: `<div style="transform: rotate(${heading}deg); font-size: 18px; color: ${color}; text-shadow: 0 0 3px rgba(0,0,0,0.8);"></div>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });

                const marker = L.marker([ac.lat, ac.lon], { icon });

                // Popup with aircraft info
                const callsign = ac.flight?.trim() || ac.r || ac.hex;
                const altitude = ac.alt_baro ? `${ac.alt_baro.toLocaleString()} ft` : 'N/A';
                const speed = ac.gs ? `${Math.round(ac.gs)} kts` : 'N/A';
                const type = ac.t || 'Unknown';
                const vrate = ac.baro_rate || ac.geom_rate;
                const vrateStr = vrate ? ` (${vrate > 0 ? '+' : ''}${vrate} fpm)` : '';

                marker.bindPopup(`
                    <div class="traffic-popup">
                        <div class="callsign">${callsign}</div>
                        <div>${type}</div>
                        <div>Alt: ${altitude}${vrateStr}</div>
                        <div>GS: ${speed}</div>
                    </div>
                `);

                marker.bindTooltip(callsign, {
                    permanent: false,
                    direction: 'top',
                    offset: [0, -10]
                });

                trafficLayer.addLayer(marker);
            });

            console.log(`Traffic: ${trafficData.length} aircraft displayed`);
        }

        // ==================== X-PLANE 12 INTEGRATION ====================

        function connectXPlaneWebSocket() {
            if (xplaneState.websocket?.readyState === WebSocket.OPEN) return;

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/xplane`;

            console.log('Connecting to X-Plane WebSocket:', wsUrl);
            xplaneState.websocket = new WebSocket(wsUrl);

            xplaneState.websocket.onopen = () => {
                console.log('X-Plane WebSocket connected');
                xplaneState.connected = true;
                xplaneState.reconnectAttempts = 0;
                updateXPlaneStatus();
                updateAutomationButtons();
            };

            xplaneState.websocket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'ping') {
                    xplaneState.websocket.send(JSON.stringify({ type: 'pong' }));
                    return;
                }
                if (data.type === 'automation_status') {
                    handleAutomationStatus(data);
                    return;
                }
                if (data.lat !== undefined) {
                    handleXPlaneData(data);
                }
            };

            xplaneState.websocket.onclose = () => {
                console.log('X-Plane WebSocket disconnected');
                xplaneState.connected = false;
                xplaneState.receiving = false;
                updateXPlaneStatus();
                updateAutomationButtons();
                // Auto-reconnect
                if (xplaneState.enabled && xplaneState.reconnectAttempts < xplaneState.maxReconnectAttempts) {
                    xplaneState.reconnectAttempts++;
                    console.log(`Reconnecting in ${xplaneState.reconnectDelay}ms (attempt ${xplaneState.reconnectAttempts})`);
                    setTimeout(connectXPlaneWebSocket, xplaneState.reconnectDelay);
                }
            };

            xplaneState.websocket.onerror = (error) => {
                console.error('X-Plane WebSocket error:', error);
            };
        }

        function disconnectXPlaneWebSocket() {
            if (xplaneState.websocket) {
                xplaneState.websocket.close();
                xplaneState.websocket = null;
            }
        }

        function handleXPlaneData(data) {
            const wasReceiving = xplaneState.receiving;
            xplaneState.receiving = true;
            xplaneState.lastPacketTime = Date.now();
            xplaneState.packetsReceived = data.packets_received || 0;

            // Update automation buttons when we first start receiving
            if (!wasReceiving) {
                updateAutomationButtons();
            }

            // Store flight data
            xplaneState.flightData = {
                lat: data.lat,
                lon: data.lon,
                alt_msl: data.alt_msl,
                alt_agl: data.alt_agl,
                heading_true: data.heading_true,
                heading_mag: data.heading_mag > -900 ? data.heading_mag : data.heading_true,
                pitch: data.pitch,
                roll: data.roll,
                airspeed_ind: data.airspeed_ind,
                groundspeed: data.groundspeed,
                vertical_speed: data.vertical_speed
            };

            // Update map marker
            updateXPlaneMapMarker();

            // Update profile marker (only if route is loaded)
            if (currentRoute.dep && currentRoute.dest) {
                updateXPlaneProfileMarker();
            }

            // Update status display
            updateXPlaneStatus();
        }

        function initXPlaneMapMarker() {
            const icon = L.divIcon({
                className: 'xplane-aircraft-marker',
                html: `<div class="xplane-aircraft-icon" style="transform: rotate(0deg);">
                    <svg viewBox="0 0 24 24" width="36" height="36">
                        <path fill="#3b82f6" d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"/>
                    </svg>
                </div>`,
                iconSize: [36, 36],
                iconAnchor: [18, 18]
            });

            xplaneMarker = L.marker([0, 0], {
                icon,
                zIndexOffset: 2000,
                interactive: false
            });
        }

        function updateXPlaneMapMarker() {
            if (!xplaneMarker || !xplaneState.enabled) return;

            const { lat, lon, heading_mag } = xplaneState.flightData;

            // Update position
            xplaneMarker.setLatLng([lat, lon]);

            // Update rotation
            const iconEl = xplaneMarker.getElement()?.querySelector('.xplane-aircraft-icon');
            if (iconEl) {
                iconEl.style.transform = `rotate(${heading_mag}deg)`;
            }

            // Add to map if not already
            if (!map.hasLayer(xplaneMarker)) {
                xplaneMarker.addTo(map);
            }
        }

        function updateXPlaneProfileMarker() {
            if (!xplaneState.enabled || !currentRoute.dep || !currentRoute.dest) {
                xplaneState.profilePosition = null;
                return;
            }

            const { lat, lon, alt_msl } = xplaneState.flightData;
            const canvas = document.getElementById('profileCanvas');
            if (!canvas) return;

            // Get route path
            const routePath = getRouteWaypoints();
            if (routePath.length < 2) return;

            // Helper: Find closest point on a line segment and return interpolation factor
            function closestPointOnSegment(px, py, ax, ay, bx, by) {
                const dx = bx - ax;
                const dy = by - ay;
                const lenSq = dx * dx + dy * dy;

                if (lenSq === 0) return { t: 0, dist: Math.sqrt((px - ax) ** 2 + (py - ay) ** 2) };

                // Project point onto line, clamped to segment
                let t = ((px - ax) * dx + (py - ay) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));

                // Closest point on segment
                const closestX = ax + t * dx;
                const closestY = ay + t * dy;
                const dist = Math.sqrt((px - closestX) ** 2 + (py - closestY) ** 2);

                return { t, dist };
            }

            // Calculate cumulative distances for each waypoint
            let totalDist = 0;
            const segmentDists = [0];
            const segmentLengths = [];

            for (let i = 1; i < routePath.length; i++) {
                const segLen = haversineDistanceNM(
                    routePath[i-1].lat, routePath[i-1].lon,
                    routePath[i].lat, routePath[i].lon
                );
                segmentLengths.push(segLen);
                totalDist += segLen;
                segmentDists.push(totalDist);
            }

            // Find closest point on any segment of the route
            let minDist = Infinity;
            let bestProgress = 0;

            for (let i = 0; i < routePath.length - 1; i++) {
                const p1 = routePath[i];
                const p2 = routePath[i + 1];

                // Find closest point on this segment (using lat/lon as x/y for simplicity)
                const result = closestPointOnSegment(
                    lon, lat,  // Aircraft position (lon=x, lat=y)
                    p1.lon, p1.lat,
                    p2.lon, p2.lat
                );

                // Convert to actual distance using haversine for the perpendicular distance
                const closestLat = p1.lat + result.t * (p2.lat - p1.lat);
                const closestLon = p1.lon + result.t * (p2.lon - p1.lon);
                const actualDist = haversineDistanceNM(lat, lon, closestLat, closestLon);

                if (actualDist < minDist) {
                    minDist = actualDist;
                    // Calculate progress: distance to start of segment + interpolated distance within segment
                    const distToSegmentStart = segmentDists[i];
                    const distWithinSegment = result.t * segmentLengths[i];
                    bestProgress = (distToSegmentStart + distWithinSegment) / totalDist;
                }
            }

            // Clamp progress to [0, 1]
            bestProgress = Math.max(0, Math.min(1, bestProgress));

            // Store position for profile redraw
            xplaneState.profilePosition = {
                progress: bestProgress,
                alt: alt_msl,
                nearRoute: minDist < 25  // Within 25nm of route
            };

            // Update floating progress bar with current journey progress
            if (currentRouteData && currentRouteData.estimatedTime) {
                const totalMinutes = Math.round(currentRouteData.estimatedTime * 60);
                const remainingMinutes = Math.round(totalMinutes * (1 - bestProgress));
                const remHrs = Math.floor(remainingMinutes / 60);
                const remMins = remainingMinutes % 60;
                const timeText = remHrs > 0 ? `${remHrs}h ${remMins}m` : `${remMins}m`;
                setTripProgress(timeText, Math.round(bestProgress * 100));
            }

            // Throttle profile redraws to max 10Hz to prevent performance issues
            const now = Date.now();
            if (!xplaneState.lastProfileRedraw || now - xplaneState.lastProfileRedraw > 100) {
                xplaneState.lastProfileRedraw = now;
                if (currentRoute.dep && currentRoute.dest) {
                    drawProfile(currentRoute.dep, currentRoute.dest);
                }
            }
        }

        function updateXPlaneStatus() {
            const toggle = document.getElementById('xplaneToggle');
            const dot = toggle?.querySelector('.xplane-status-dot');
            const label = toggle?.querySelector('.xplane-label');

            if (!toggle) return;

            toggle.classList.toggle('active', xplaneState.enabled);

            if (dot) {
                if (!xplaneState.enabled) {
                    dot.style.background = '#666';
                    dot.title = 'X-Plane mode disabled';
                } else if (!xplaneState.connected) {
                    dot.style.background = '#f59e0b';
                    dot.title = 'Connecting...';
                } else if (!xplaneState.receiving) {
                    dot.style.background = '#3b82f6';
                    dot.title = 'Connected - awaiting X-Plane data';
                } else {
                    dot.style.background = '#3b82f6';
                    dot.title = `Live: ${Math.round(xplaneState.flightData.alt_msl).toLocaleString()} ft MSL`;
                }
            }

            if (label) {
                if (xplaneState.enabled && xplaneState.receiving) {
                    label.textContent = `LIVE ${Math.round(xplaneState.flightData.alt_msl).toLocaleString()}ft`;
                } else {
                    label.textContent = 'X-PLANE';
                }
            }
        }

        function toggleXPlaneMode() {
            xplaneState.enabled = !xplaneState.enabled;

            if (xplaneState.enabled) {
                initXPlaneMapMarker();
                connectXPlaneWebSocket();
            } else {
                disconnectXPlaneWebSocket();
                xplaneState.profilePosition = null;
                if (xplaneMarker && map.hasLayer(xplaneMarker)) {
                    map.removeLayer(xplaneMarker);
                }
                // Redraw profile without X-Plane marker
                if (currentRoute.dep && currentRoute.dest) {
                    drawProfile(currentRoute.dep, currentRoute.dest);
                }
            }

            updateXPlaneStatus();
        }

        // ==================== END X-PLANE INTEGRATION ====================

        // ==================== FLIGHT AUTOMATION ====================

        const automationState = {
            planUploaded: false,
            isActive: false,
            phase: 'IDLE',  // IDLE, POSITIONING, UPLOADING, TAKEOFF, CLIMBING, CRUISE, DESCENDING, APPROACH
            statusInterval: null,
            positioned: false,  // True once aircraft is at departure
            inFlight: false     // True once airborne
        };

        // Update automation button states based on route and X-Plane connection
        function updateAutomationButtons() {
            const hasRoute = currentRoute.dep && currentRoute.dest;
            const xplaneConnected = xplaneState.enabled && xplaneState.websocket?.readyState === WebSocket.OPEN;

            console.log('updateAutomationButtons:', { hasRoute, xplaneConnected, phase: automationState.phase });

            // Get all autopilot buttons (panel and floating)
            const btn = document.getElementById('btnAutopilot');
            const btnFloat = document.getElementById('btnAutopilotFloat');
            const floatPhase = document.getElementById('autopilotFloatPhase');

            // Enable buttons if we have route and X-Plane connected
            if (btn) btn.disabled = !hasRoute || !xplaneConnected;
            if (btnFloat) btnFloat.disabled = !hasRoute || !xplaneConnected;

            // Update button appearance based on current state
            const buttons = [btn, btnFloat].filter(b => b);
            buttons.forEach(b => {
                b.classList.remove('engaged', 'positioning', 'uploading', 'takeoff-active');
            });

            let phaseText = 'IDLE';
            let phaseClass = 'idle';

            if (automationState.isActive) {
                phaseClass = 'active';
                if (automationState.phase === 'POSITIONING') {
                    buttons.forEach(b => b.classList.add('positioning'));
                    phaseText = 'POSITIONING';
                } else if (automationState.phase === 'UPLOADING') {
                    buttons.forEach(b => b.classList.add('uploading'));
                    phaseText = 'UPLOADING';
                } else if (automationState.phase === 'TAKEOFF') {
                    buttons.forEach(b => b.classList.add('takeoff-active'));
                    phaseText = 'TAKEOFF';
                } else if (['CLIMBING', 'CRUISE', 'DESCENDING', 'APPROACH'].includes(automationState.phase)) {
                    buttons.forEach(b => b.classList.add('engaged'));
                    phaseText = automationState.phase;
                } else {
                    buttons.forEach(b => b.classList.add('engaged'));
                    phaseText = 'ACTIVE';
                }
            }

            // Update floating status
            if (floatPhase) {
                floatPhase.textContent = phaseText;
                floatPhase.classList.remove('idle', 'active');
                floatPhase.classList.add(phaseClass);
            }
        }

        // Disengage autopilot (combined disconnect/release function)
        function disengageAutopilot() {
            console.log('Disengaging autopilot...');

            if (xplaneState.websocket) {
                xplaneState.websocket.send(JSON.stringify({
                    type: 'emergency_stop'
                }));
            }

            automationState.isActive = false;
            automationState.planUploaded = false;
            automationState.positioned = false;
            automationState.inFlight = false;
            automationState.phase = 'IDLE';
            stopAutomationStatusPolling();
            resetAutomationDisplay();
            updateAutomationButtons();
        }

        // Build waypoints from current route with proper altitude profile
        function buildRouteWaypoints() {
            const waypoints = [];

            if (!currentRoute.dep || !currentRoute.dest) return waypoints;

            const depElev = currentRoute.dep.elevation || 0;
            const destElev = currentRoute.dest.elevation || 0;
            const cruiseAlt = currentRoute.cruiseAltitude || 10000;

            // Calculate total route distance
            let totalDistance = haversineNM(
                currentRoute.dep.lat, currentRoute.dep.lon,
                currentRoute.dest.lat, currentRoute.dest.lon
            );

            // Flight profile parameters (same as profile canvas)
            const climbRate = 800; // ft/min
            const descentRate = 500; // ft/min
            const avgClimbSpeed = 100; // knots during climb
            const avgDescentSpeed = 120; // knots during descent

            // Calculate TOC and TOD distances
            const climbAltitude = cruiseAlt - depElev;
            const descentAltitude = cruiseAlt - destElev;

            // Time to climb/descend in hours
            const climbTimeHours = (climbAltitude / climbRate) / 60;
            const descentTimeHours = (descentAltitude / descentRate) / 60;

            // Distance to TOC and from TOD
            const tocDistance = climbTimeHours * avgClimbSpeed; // nm from departure to TOC
            const todDistanceFromEnd = descentTimeHours * avgDescentSpeed; // nm from TOD to destination
            const todDistance = totalDistance - todDistanceFromEnd; // nm from departure to TOD

            console.log(`Flight profile: TOC at ${tocDistance.toFixed(1)}nm, TOD at ${todDistance.toFixed(1)}nm, total ${totalDistance.toFixed(1)}nm`);

            // Departure airport
            waypoints.push({
                name: currentRoute.dep.icao || currentRoute.dep.id,
                lat: currentRoute.dep.lat,
                lon: currentRoute.dep.lon,
                altitude_ft: depElev,
                type: 'departure'
            });

            // Calculate route bearing for TOC/TOD position interpolation
            const routeBearing = calculateBearing(
                currentRoute.dep.lat, currentRoute.dep.lon,
                currentRoute.dest.lat, currentRoute.dest.lon
            );

            // Add TOC waypoint (where we reach cruise altitude)
            if (tocDistance > 5 && tocDistance < totalDistance - 10) {
                const tocPos = destinationPoint(
                    currentRoute.dep.lat, currentRoute.dep.lon,
                    routeBearing, tocDistance
                );
                waypoints.push({
                    name: 'TOC',
                    lat: tocPos.lat,
                    lon: tocPos.lon,
                    altitude_ft: cruiseAlt,
                    type: 'enroute'
                });
                console.log(`Added TOC waypoint at ${tocDistance.toFixed(1)}nm -> ${cruiseAlt}ft`);
            }

            // Enroute waypoints with altitude based on profile position
            if (currentRoute.waypoints && currentRoute.waypoints.length > 0) {
                for (const wpt of currentRoute.waypoints) {
                    // Calculate distance from departure to this waypoint
                    const distFromDep = haversineNM(
                        currentRoute.dep.lat, currentRoute.dep.lon,
                        wpt.lat, wpt.lon
                    );

                    // Calculate altitude based on profile phase
                    let waypointAlt;
                    if (distFromDep <= tocDistance) {
                        // In climb phase - linear interpolation
                        const climbProgress = distFromDep / tocDistance;
                        waypointAlt = depElev + (climbAltitude * climbProgress);
                    } else if (distFromDep >= todDistance) {
                        // In descent phase - linear interpolation
                        const descentProgress = (distFromDep - todDistance) / todDistanceFromEnd;
                        waypointAlt = cruiseAlt - (descentAltitude * descentProgress);
                    } else {
                        // At cruise altitude
                        waypointAlt = cruiseAlt;
                    }

                    waypoints.push({
                        name: wpt.name || wpt.id || 'WPT',
                        lat: wpt.lat,
                        lon: wpt.lon,
                        altitude_ft: Math.round(waypointAlt),
                        type: 'enroute'
                    });

                    console.log(`Waypoint ${wpt.name}: ${distFromDep.toFixed(1)}nm from dep -> ${Math.round(waypointAlt)}ft`);
                }
            }

            // Add TOD waypoint (where we start descent)
            if (todDistance > tocDistance + 10 && todDistance < totalDistance - 5) {
                const todPos = destinationPoint(
                    currentRoute.dep.lat, currentRoute.dep.lon,
                    routeBearing, todDistance
                );
                waypoints.push({
                    name: 'TOD',
                    lat: todPos.lat,
                    lon: todPos.lon,
                    altitude_ft: cruiseAlt, // Start descent from cruise
                    type: 'enroute'
                });
                console.log(`Added TOD waypoint at ${todDistance.toFixed(1)}nm -> ${cruiseAlt}ft (start descent)`);
            }

            // Destination airport
            waypoints.push({
                name: currentRoute.dest.icao || currentRoute.dest.id,
                lat: currentRoute.dest.lat,
                lon: currentRoute.dest.lon,
                altitude_ft: destElev,
                type: 'destination'
            });

            return waypoints;
        }

        // Intelligent Autopilot - understands context and executes appropriate action
        async function engageAutopilot() {
            console.log('engageAutopilot called - current phase:', automationState.phase);

            if (!currentRoute.dep || !currentRoute.dest || !xplaneState.websocket) {
                console.error('Cannot engage autopilot: no route or not connected');
                return;
            }

            // If already active, clicking again will disengage
            if (automationState.isActive && automationState.inFlight) {
                console.log('Autopilot already active and in flight - no action needed');
                return;
            }

            automationState.isActive = true;

            // Determine what action to take based on current state
            if (!automationState.positioned) {
                // Step 1: Position aircraft to departure
                automationState.phase = 'POSITIONING';
                updateAutomationButtons();
                await positionToDeparture();

                // Wait a moment for positioning to complete
                await new Promise(resolve => setTimeout(resolve, 2000));
                automationState.positioned = true;
            }

            if (!automationState.planUploaded) {
                // Step 2: Upload flight plan
                automationState.phase = 'UPLOADING';
                updateAutomationButtons();
                await uploadFlightPlan();

                // Wait a moment for upload to complete
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            if (!automationState.inFlight) {
                // Step 3: Start takeoff sequence
                automationState.phase = 'TAKEOFF';
                updateAutomationButtons();
                autoTakeoff();
            }

            // Status polling will update the phase as flight progresses
            startAutomationStatusPolling();
        }

        // Position aircraft to departure airport
        async function positionToDeparture() {
            console.log('positionToDeparture called');
            console.log('currentRoute.dep:', currentRoute.dep);
            console.log('xplaneState.websocket:', xplaneState.websocket);

            if (!currentRoute.dep || !xplaneState.websocket) {
                console.error('No departure airport or WebSocket not connected');
                return;
            }

            const dep = currentRoute.dep;
            console.log('Positioning to departure:', dep.icao || dep.id);

            // Send position command via WebSocket
            xplaneState.websocket.send(JSON.stringify({
                type: 'position_aircraft',
                lat: dep.lat,
                lon: dep.lon,
                altitude_ft: (dep.elevation || 0) + 50,  // 50ft above ground
                heading: 0  // Will need runway heading ideally
            }));

            // Update status
            updateAutomationStatus('Positioning to ' + (dep.icao || dep.id) + '...');
        }

        // Upload flight plan to backend
        async function uploadFlightPlan() {
            if (!xplaneState.websocket) {
                console.error('WebSocket not connected');
                return;
            }

            const waypoints = buildRouteWaypoints();
            if (waypoints.length < 2) {
                console.error('Need at least departure and destination');
                return;
            }

            console.log('Uploading flight plan with', waypoints.length, 'waypoints');

            xplaneState.websocket.send(JSON.stringify({
                type: 'upload_flight_plan',
                waypoints: waypoints,
                cruise_altitude: currentRoute.cruiseAltitude || 10000
            }));

            automationState.planUploaded = true;
            updateAutomationButtons();
            updateAutomationStatus('Flight plan uploaded');

            // Start polling for automation status
            startAutomationStatusPolling();
        }

        // Start auto-takeoff sequence
        function autoTakeoff() {
            if (!xplaneState.websocket || !automationState.planUploaded) {
                console.error('Cannot start takeoff: plan not uploaded or not connected');
                return;
            }

            console.log('Starting auto-takeoff sequence');

            xplaneState.websocket.send(JSON.stringify({
                type: 'auto_takeoff'
            }));

            automationState.isActive = true;
            updateAutomationStatus('Starting takeoff sequence...');
        }

        // Emergency disconnect - stop all automation
        // Alias for backwards compatibility
        function emergencyDisconnect() {
            disengageAutopilot();
        }

        // Alias for backwards compatibility
        function releaseToPilot() {
            disengageAutopilot();
        }

        // Poll for automation status updates
        function startAutomationStatusPolling() {
            if (automationState.statusInterval) return;

            automationState.statusInterval = setInterval(() => {
                if (xplaneState.websocket?.readyState === WebSocket.OPEN) {
                    xplaneState.websocket.send(JSON.stringify({
                        type: 'get_automation_status'
                    }));
                }
            }, 1000);  // Poll every second
        }

        function stopAutomationStatusPolling() {
            if (automationState.statusInterval) {
                clearInterval(automationState.statusInterval);
                automationState.statusInterval = null;
            }
        }

        // Update automation status display
        function updateAutomationStatus(message) {
            const phaseEl = document.getElementById('automationPhase');
            if (phaseEl && message) {
                phaseEl.textContent = message;
            }
        }

        // Handle automation status from WebSocket
        function handleAutomationStatus(data) {
            const statusEl = document.getElementById('automationStatus');
            const phaseEl = document.getElementById('automationPhase');
            const nextWptEl = document.getElementById('automationNextWpt');
            const distanceEl = document.getElementById('automationDistance');
            const targetHdgEl = document.getElementById('automationTargetHdg');
            const targetAltEl = document.getElementById('automationTargetAlt');

            if (!statusEl) return;

            // Update phase display
            automationState.phase = data.phase || 'IDLE';
            phaseEl.textContent = automationState.phase;

            // Update status box styling
            statusEl.classList.remove('idle', 'active', 'takeoff');
            if (automationState.phase === 'IDLE') {
                statusEl.classList.add('idle');
            } else if (['TAKEOFF_ROLL', 'ROTATION', 'INITIAL_CLIMB', 'CLIMB_OUT'].includes(automationState.phase)) {
                statusEl.classList.add('takeoff');
            } else {
                statusEl.classList.add('active');
            }

            // Update stats
            if (data.current_waypoint) {
                nextWptEl.textContent = data.current_waypoint;
            }
            if (data.distance_nm !== undefined) {
                distanceEl.textContent = data.distance_nm.toFixed(1) + ' NM';
            }
            if (data.target_heading !== undefined) {
                targetHdgEl.textContent = Math.round(data.target_heading) + '';
            }
            if (data.target_altitude !== undefined) {
                targetAltEl.textContent = Math.round(data.target_altitude) + ' ft';
            }

            // Update active state
            automationState.isActive = data.navigation_active || data.takeoff_active || false;

            // Update flight status flags based on phase
            const flightPhases = ['INITIAL_CLIMB', 'CLIMB_OUT', 'CLIMBING', 'CRUISE', 'DESCENDING', 'APPROACH', 'FINAL'];
            if (flightPhases.includes(automationState.phase)) {
                automationState.inFlight = true;
            }

            // Update the autopilot button appearance
            updateAutomationButtons();

            // If automation stopped, reset
            if (!automationState.isActive && automationState.phase === 'IDLE') {
                stopAutomationStatusPolling();
            }
        }

        // Reset automation display to default
        function resetAutomationDisplay() {
            const statusEl = document.getElementById('automationStatus');
            const phaseEl = document.getElementById('automationPhase');

            if (statusEl) {
                statusEl.classList.remove('active', 'takeoff');
                statusEl.classList.add('idle');
            }
            if (phaseEl) {
                phaseEl.textContent = 'IDLE';
            }

            document.getElementById('automationNextWpt').textContent = '--';
            document.getElementById('automationDistance').textContent = '-- NM';
            document.getElementById('automationTargetHdg').textContent = '---';
            document.getElementById('automationTargetAlt').textContent = '-----';

            // Reset automation state
            automationState.phase = 'IDLE';
            automationState.positioned = false;
            automationState.inFlight = false;
            updateAutomationButtons();
        }

        // ==================== END FLIGHT AUTOMATION ====================

        // Helper function to parse CSV line with quoted fields
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            return result;
        }

        // Fetch ALL airports from OurAirports (comprehensive database including small airports)
        async function fetchOurAirports() {
            if (ourAirportsLoaded) return;

            try {
                console.log('Loading comprehensive airport database from OurAirports...');

                const response = await fetch('https://davidmegginson.github.io/ourairports-data/airports.csv');
                if (!response.ok) throw new Error('Failed to fetch OurAirports data');

                const csvText = await response.text();
                const lines = csvText.split('\n');
                const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());

                // Find column indices
                const identIdx = headers.indexOf('ident');
                const typeIdx = headers.indexOf('type');
                const nameIdx = headers.indexOf('name');
                const latIdx = headers.indexOf('latitude_deg');
                const lonIdx = headers.indexOf('longitude_deg');
                const isoCountryIdx = headers.indexOf('iso_country');
                const localCodeIdx = headers.indexOf('local_code');

                const existingIds = new Set(metarStations.map(s => s.id));
                let addedCount = 0;

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];
                    if (!line.trim()) continue;

                    const cols = parseCSVLine(line);
                    if (cols.length < Math.max(identIdx, latIdx, lonIdx) + 1) continue;

                    const ident = cols[identIdx]?.replace(/"/g, '').trim();
                    const type = cols[typeIdx]?.replace(/"/g, '').trim();
                    const name = cols[nameIdx]?.replace(/"/g, '').trim();
                    const lat = parseFloat(cols[latIdx]);
                    const lon = parseFloat(cols[lonIdx]);
                    const country = cols[isoCountryIdx]?.replace(/"/g, '').trim();
                    const localCode = cols[localCodeIdx]?.replace(/"/g, '').trim();

                    if (!ident || isNaN(lat) || isNaN(lon)) continue;
                    if (type === 'closed') continue;
                    if (country !== 'US') continue;

                    if (!existingIds.has(ident)) {
                        metarStations.push({
                            id: ident,
                            name: name || ident,
                            lat: lat,
                            lon: lon,
                            type: type,
                            localCode: localCode
                        });
                        existingIds.add(ident);
                        addedCount++;

                        // Also add by local code for lookup
                        if (localCode && !existingIds.has(localCode)) {
                            existingIds.add(localCode);
                        }
                    }
                }

                console.log(`OurAirports: Loaded ${addedCount} US airports (total: ${metarStations.length})`);
                ourAirportsLoaded = true;

            } catch (error) {
                console.warn('Could not fetch OurAirports data:', error);
                fetchFAAairports();
            }
        }

        // Fetch from FAA AWC (backup - only has airports with weather stations)
        async function fetchFAAairports() {
            if (dynamicStationsLoaded) return;

            try {
                const response = await fetch('https://aviationweather.gov/api/data/stationinfo?format=json');
                if (response.ok) {
                    const stations = await response.json();

                    const usStations = stations.filter(s =>
                        s.lat && s.lon && s.icaoId &&
                        (s.icaoId.startsWith('K') || s.icaoId.startsWith('PA') ||
                         s.icaoId.startsWith('PH') || s.icaoId.startsWith('PF') ||
                         s.icaoId.startsWith('PP') || s.icaoId.startsWith('PG'))
                    );

                    const existingIds = new Set(metarStations.map(s => s.id));
                    let addedCount = 0;

                    usStations.forEach(station => {
                        if (!existingIds.has(station.icaoId)) {
                            metarStations.push({
                                id: station.icaoId,
                                name: station.name || station.icaoId,
                                lat: parseFloat(station.lat),
                                lon: parseFloat(station.lon)
                            });
                            addedCount++;
                        }
                    });

                    console.log(`FAA AWC: Loaded ${addedCount} additional airports (total: ${metarStations.length})`);
                    dynamicStationsLoaded = true;
                }
            } catch (error) {
                console.warn('Could not fetch FAA airport list:', error);
            }
        }

        // Airports - preloaded immediately for instant route loading
        let stationsDataLoaded = false;    // Airport list has been fetched
        let stationsMetarLoaded = false;   // METAR data has been loaded
        let stationsLoading = false;       // Currently loading stations

        // Preload airport database immediately on page load
        (function preloadAirports() {
            stationsLoading = true;
            console.log('Preloading airport database...');
            Promise.all([fetchOurAirports(), fetchFAAairports()])
                .then(() => {
                    stationsDataLoaded = true;
                    stationsLoading = false;
                    console.log('Airport database ready');
                })
                .catch(err => {
                    console.error('Failed to preload airports:', err);
                    stationsLoading = false;
                });
        })();

        // Simple loading bar functions
        function showLoading(progress = 0) {
            const container = document.getElementById('loadingBarContainer');
            const bar = document.getElementById('loadingBar');
            if (container) container.classList.add('active');
            if (bar) bar.style.width = `${progress}%`;
        }

        function updateLoading(progress) {
            const bar = document.getElementById('loadingBar');
            if (bar) bar.style.width = `${Math.min(100, progress)}%`;
        }

        function hideLoading() {
            const container = document.getElementById('loadingBarContainer');
            const bar = document.getElementById('loadingBar');
            if (bar) bar.style.width = '100%';
            setTimeout(() => {
                if (container) container.classList.remove('active');
                if (bar) bar.style.width = '0%';
            }, 300);
        }

        // Airways data storage (Victor airways, jet routes, etc.)
        let airwaysData = [];
        let airwaysLoaded = false;
        let airwaysLoading = false;
        let airwaysLayer = null;

        // Fetch airways data from backend proxy (avoids CORS issues)
        async function fetchAirways() {
            if (airwaysLoaded) return;

            try {
                showLoading(0);
                console.log('Loading airways data...');

                // Use backend proxy to avoid CORS
                const countResponse = await fetch('/api/aviation/airways/count');
                const countData = await countResponse.json();
                const totalCount = countData.count || 0;
                console.log(`Total airways: ${totalCount}`);

                // Fetch in batches
                const batchSize = 2000;
                let offset = 0;

                while (offset < totalCount) {
                    const response = await fetch(`/api/aviation/airways?offset=${offset}&limit=${batchSize}`);

                    if (!response.ok) throw new Error('Failed to fetch airways');

                    const data = await response.json();

                    if (data.features) {
                        data.features.forEach(feature => {
                            if (feature.geometry && feature.geometry.coordinates) {
                                airwaysData.push({
                                    ident: feature.properties.IDENT || '',
                                    usLow: feature.properties.US_LOW,
                                    usHigh: feature.properties.US_HIGH,
                                    akLow: feature.properties.AK_LOW,
                                    akHigh: feature.properties.AK_HIGH,
                                    coordinates: feature.geometry.coordinates
                                });
                            }
                        });
                    }

                    offset += batchSize;
                    const progress = Math.round((Math.min(offset, totalCount) / totalCount) * 100);
                    updateLoading(progress);
                    console.log(`Loaded ${Math.min(offset, totalCount)}/${totalCount} airways`);
                }

                console.log(`Loaded ${airwaysData.length} airways`);
                airwaysLoaded = true;
                hideLoading();

            } catch (error) {
                console.warn('Could not fetch airways data:', error);
                hideLoading();
            }
        }

        // Find airways that align with a route direction
        // Returns airways with segments usable for the route
        function findAirwaysAlongRoute(depLat, depLon, destLat, destLon, cruiseAltitude = 12500) {
            if (!airwaysLoaded || airwaysData.length === 0) return [];

            const matchedAirways = [];
            const routeBearing = calculateBearing(depLat, depLon, destLat, destLon);
            const routeDistance = haversineNM(depLat, depLon, destLat, destLon);

            // Create a corridor around the direct route (30nm wide)
            const corridorWidth = 30; // nm

            for (const airway of airwaysData) {
                if (!airway.coordinates || airway.coordinates.length < 2) continue;

                // Determine airway type and altitude range
                const ident = airway.ident || '';
                let minAlt = 0, maxAlt = 60000;

                // Victor airways (V): Low altitude (below 18,000)
                // Jet routes (J): High altitude (18,000+)
                // T-routes: Low RNAV
                // Q-routes: High RNAV
                if (ident.startsWith('V')) {
                    minAlt = 1200;
                    maxAlt = 18000;
                } else if (ident.startsWith('J')) {
                    minAlt = 18000;
                    maxAlt = 45000;
                } else if (ident.startsWith('T')) {
                    minAlt = 1200;
                    maxAlt = 18000;
                } else if (ident.startsWith('Q')) {
                    minAlt = 18000;
                    maxAlt = 45000;
                }

                // Skip if cruise altitude is outside airway altitude range
                if (cruiseAltitude < minAlt || cruiseAltitude > maxAlt) continue;

                // Check each segment of the airway
                let usableSegments = [];
                for (let i = 0; i < airway.coordinates.length - 1; i++) {
                    const [lon1, lat1] = airway.coordinates[i];
                    const [lon2, lat2] = airway.coordinates[i + 1];

                    // Calculate segment bearing
                    const segBearing = calculateBearing(lat1, lon1, lat2, lon2);

                    // Check if segment aligns with route (within 45 degrees)
                    let bearingDiff = Math.abs(routeBearing - segBearing);
                    if (bearingDiff > 180) bearingDiff = 360 - bearingDiff;

                    // Accept segment if it's within 45 degrees of route direction
                    // or within 45 degrees of reverse (for bidirectional airways)
                    const isAligned = bearingDiff <= 45 || bearingDiff >= 135;
                    if (!isAligned) continue;

                    // Check if segment is within corridor
                    const midLat = (lat1 + lat2) / 2;
                    const midLon = (lon1 + lon2) / 2;
                    const distToRoute = pointToLineDistance(midLat, midLon, depLat, depLon, destLat, destLon);

                    if (distToRoute <= corridorWidth) {
                        // Calculate how far along the route this segment is (0-1)
                        const progress = routeProgress(midLat, midLon, depLat, depLon, destLat, destLon);

                        if (progress >= 0 && progress <= 1) {
                            usableSegments.push({
                                startLat: lat1,
                                startLon: lon1,
                                endLat: lat2,
                                endLon: lon2,
                                progress: progress,
                                distance: haversineNM(lat1, lon1, lat2, lon2)
                            });
                        }
                    }
                }

                if (usableSegments.length > 0) {
                    // Calculate total usable distance on this airway
                    const totalAirwayDist = usableSegments.reduce((sum, seg) => sum + seg.distance, 0);
                    const avgProgress = usableSegments.reduce((sum, seg) => sum + seg.progress, 0) / usableSegments.length;

                    matchedAirways.push({
                        ident: ident,
                        type: ident.startsWith('J') ? 'Jet' : ident.startsWith('V') ? 'Victor' :
                              ident.startsWith('T') ? 'T-Route' : ident.startsWith('Q') ? 'Q-Route' : 'Other',
                        segments: usableSegments,
                        totalDistance: totalAirwayDist,
                        avgProgress: avgProgress,
                        minAlt: minAlt,
                        maxAlt: maxAlt
                    });
                }
            }

            // Sort by total usable distance (most useful airways first)
            matchedAirways.sort((a, b) => b.totalDistance - a.totalDistance);

            // Return top airways (limit to avoid cluttering)
            return matchedAirways.slice(0, 10);
        }

        // Calculate bearing between two points (degrees)
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        // Calculate perpendicular distance from point to line (nm)
        function pointToLineDistance(pLat, pLon, lineLat1, lineLon1, lineLat2, lineLon2) {
            // Use cross-track distance formula
            const d13 = haversineNM(lineLat1, lineLon1, pLat, pLon);
            const brng13 = calculateBearing(lineLat1, lineLon1, pLat, pLon) * Math.PI / 180;
            const brng12 = calculateBearing(lineLat1, lineLon1, lineLat2, lineLon2) * Math.PI / 180;
            const R = 3440.065; // Earth radius in nm
            return Math.abs(Math.asin(Math.sin(d13/R) * Math.sin(brng13 - brng12)) * R);
        }

        // Calculate how far along a route a point is (0 = start, 1 = end)
        function routeProgress(pLat, pLon, startLat, startLon, endLat, endLon) {
            const totalDist = haversineNM(startLat, startLon, endLat, endLon);
            if (totalDist === 0) return 0;

            // Project point onto line
            const d1 = haversineNM(startLat, startLon, pLat, pLon);
            const bearing1 = calculateBearing(startLat, startLon, pLat, pLon);
            const routeBearing = calculateBearing(startLat, startLon, endLat, endLon);
            const angleDiff = (bearing1 - routeBearing) * Math.PI / 180;
            const alongTrack = d1 * Math.cos(angleDiff);

            return alongTrack / totalDist;
        }

        // Runway data storage (from OurAirports)
        let runwayData = {}; // Keyed by airport ICAO code
        let runwaysLoaded = false;
        let runwaysLoading = false;
        let runwaysLayer = null;

        // Fetch runway data from OurAirports CSV
        async function fetchRunways() {
            if (runwaysLoaded || runwaysLoading) return;
            runwaysLoading = true;

            try {
                showLoading(0);
                console.log('Loading runway data...');

                const response = await fetch('https://davidmegginson.github.io/ourairports-data/runways.csv');
                if (!response.ok) throw new Error('Failed to fetch runways');

                const text = await response.text();
                const lines = text.split('\n');
                const headers = lines[0].split(',');

                // Find column indices
                const cols = {};
                headers.forEach((h, i) => cols[h.trim().replace(/"/g, '')] = i);

                const total = lines.length - 1;
                let processed = 0;

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];
                    if (!line.trim()) continue;

                    // Parse CSV properly (handling quoted fields)
                    const values = parseCSVLine(line);

                    const airportIdent = values[cols['airport_ident']]?.replace(/"/g, '').trim();
                    const closed = values[cols['closed']]?.replace(/"/g, '').trim();

                    // Skip closed runways and invalid entries
                    if (!airportIdent || closed === '1') continue;

                    const runway = {
                        leIdent: values[cols['le_ident']]?.replace(/"/g, '').trim() || '',
                        heIdent: values[cols['he_ident']]?.replace(/"/g, '').trim() || '',
                        leHeading: parseFloat(values[cols['le_heading_degT']]) || 0,
                        heHeading: parseFloat(values[cols['he_heading_degT']]) || 0,
                        length: parseInt(values[cols['length_ft']]) || 0,
                        width: parseInt(values[cols['width_ft']]) || 0,
                        surface: values[cols['surface']]?.replace(/"/g, '').trim() || '',
                        lighted: values[cols['lighted']]?.replace(/"/g, '').trim() === '1',
                        leLat: parseFloat(values[cols['le_latitude_deg']]) || null,
                        leLon: parseFloat(values[cols['le_longitude_deg']]) || null,
                        heLat: parseFloat(values[cols['he_latitude_deg']]) || null,
                        heLon: parseFloat(values[cols['he_longitude_deg']]) || null
                    };

                    // Only add runways with valid coordinates
                    if (runway.leLat && runway.leLon && runway.heLat && runway.heLon) {
                        if (!runwayData[airportIdent]) {
                            runwayData[airportIdent] = [];
                        }
                        runwayData[airportIdent].push(runway);
                    }

                    processed++;
                    if (processed % 5000 === 0) {
                        updateLoading(Math.round((processed / total) * 100));
                    }
                }

                console.log(`Loaded runways for ${Object.keys(runwayData).length} airports`);
                runwaysLoaded = true;
                hideLoading();

            } catch (error) {
                console.warn('Could not fetch runway data:', error);
                hideLoading();
            } finally {
                runwaysLoading = false;
            }
        }

        // Parse CSV line handling quoted fields
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            return result;
        }

        // Select optimal runway based on wind direction and speed
        function selectOptimalRunway(airportCode, windDir, windSpeed) {
            const runways = runwayData[airportCode];
            if (!runways || runways.length === 0) return null;

            // If calm winds, return the longest runway
            if (windSpeed < 3 || windDir === null || windDir === undefined) {
                const longest = runways.reduce((a, b) => a.length > b.length ? a : b);
                return {
                    runway: longest.leIdent,
                    headwind: 0,
                    crosswind: 0,
                    score: 0,
                    runwayData: longest
                };
            }

            let bestResult = null;
            let bestScore = -Infinity;

            for (const rwy of runways) {
                // Check both runway ends
                for (const [ident, heading] of [[rwy.leIdent, rwy.leHeading], [rwy.heIdent, rwy.heHeading]]) {
                    if (!ident || !heading) continue;

                    // Calculate wind angle relative to runway
                    let windAngle = windDir - heading;
                    // Normalize to -180 to 180
                    while (windAngle > 180) windAngle -= 360;
                    while (windAngle < -180) windAngle += 360;

                    const angleRad = Math.abs(windAngle) * Math.PI / 180;

                    // Headwind component (positive = headwind, negative = tailwind)
                    const headwind = windSpeed * Math.cos(angleRad);
                    // Crosswind component (always positive)
                    const crosswind = Math.abs(windSpeed * Math.sin(angleRad));

                    // Score: reward headwind, heavily penalize crosswind
                    const score = headwind - (crosswind * 2);

                    if (score > bestScore) {
                        bestScore = score;
                        bestResult = {
                            runway: ident,
                            headwind: Math.round(headwind),
                            crosswind: Math.round(crosswind),
                            score: score,
                            runwayData: rwy
                        };
                    }
                }
            }

            return bestResult;
        }

        // Find suitable fuel stop airports along a route
        function findFuelStops(depStation, destStation, maxLegRange, numStops) {
            if (numStops === 0) return [];

            const fuelStops = [];
            const totalDistance = haversineNM(depStation.lat, depStation.lon, destStation.lat, destStation.lon);

            // Calculate ideal positions for fuel stops (evenly spaced)
            for (let i = 1; i <= numStops; i++) {
                const targetProgress = i / (numStops + 1);
                const targetDistance = totalDistance * targetProgress;

                // Calculate position along great circle route
                const bearing = calculateBearing(depStation.lat, depStation.lon, destStation.lat, destStation.lon);
                const targetPos = destinationPoint(depStation.lat, depStation.lon, bearing, targetDistance);

                // Find nearest airports to this position (within 50nm search radius)
                const searchRadius = 50; // nm
                const candidates = [];

                for (const station of metarStations) {
                    // Only consider airports with ICAO codes (likely to have fuel)
                    if (!station.id || station.id.length !== 4) continue;
                    if (!station.id.startsWith('K') && !station.id.startsWith('P')) continue;

                    const dist = haversineNM(targetPos.lat, targetPos.lon, station.lat, station.lon);
                    if (dist <= searchRadius) {
                        // Calculate deviation from direct route
                        const deviation = pointToLineDistance(station.lat, station.lon,
                            depStation.lat, depStation.lon, destStation.lat, destStation.lon);

                        // Check if runway data exists (indicates larger airport)
                        const hasRunways = runwayData[station.id] && runwayData[station.id].length > 0;
                        const longestRunway = hasRunways
                            ? Math.max(...runwayData[station.id].map(r => r.length || 0))
                            : 0;

                        candidates.push({
                            station: station,
                            distanceFromIdeal: dist,
                            deviation: deviation,
                            hasRunways: hasRunways,
                            longestRunway: longestRunway,
                            distanceFromDep: haversineNM(depStation.lat, depStation.lon, station.lat, station.lon)
                        });
                    }
                }

                // Score and sort candidates (prefer: longer runway, less deviation, closer to ideal)
                candidates.sort((a, b) => {
                    // Prefer airports with longer runways (3000+ ft strongly preferred)
                    const runwayScoreA = a.longestRunway >= 3000 ? 100 : a.longestRunway / 30;
                    const runwayScoreB = b.longestRunway >= 3000 ? 100 : b.longestRunway / 30;

                    // Penalize deviation from route
                    const deviationPenaltyA = a.deviation * 2;
                    const deviationPenaltyB = b.deviation * 2;

                    // Penalize distance from ideal position
                    const distPenaltyA = a.distanceFromIdeal;
                    const distPenaltyB = b.distanceFromIdeal;

                    const scoreA = runwayScoreA - deviationPenaltyA - distPenaltyA;
                    const scoreB = runwayScoreB - deviationPenaltyB - distPenaltyB;

                    return scoreB - scoreA;
                });

                if (candidates.length > 0) {
                    const best = candidates[0];
                    fuelStops.push({
                        station: best.station,
                        distanceFromDep: Math.round(best.distanceFromDep),
                        deviation: Math.round(best.deviation),
                        longestRunway: best.longestRunway,
                        stopNumber: i
                    });
                }
            }

            return fuelStops;
        }

        // Calculate destination point given start, bearing, and distance
        function destinationPoint(lat, lon, bearing, distance) {
            const R = 3440.065; // Earth radius in nm
            const d = distance / R;
            const brng = bearing * Math.PI / 180;
            const lat1 = lat * Math.PI / 180;
            const lon1 = lon * Math.PI / 180;

            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(brng));
            const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(d) * Math.cos(lat1), Math.cos(d) - Math.sin(lat1) * Math.sin(lat2));

            return {
                lat: lat2 * 180 / Math.PI,
                lon: lon2 * 180 / Math.PI
            };
        }

        // Resolve airport code to station object (handles various formats)
        function findAirportStation(code) {
            if (!code) return null;
            const upper = code.toUpperCase().trim();

            // Direct match
            let station = metarStations.find(s => s.id === upper);
            if (station) return station;

            // Try with K prefix (continental US)
            station = metarStations.find(s => s.id === 'K' + upper);
            if (station) return station;

            // Try P prefixes (Pacific/Alaska/Hawaii)
            station = metarStations.find(s => s.id === 'P' + upper);
            if (station) return station;
            station = metarStations.find(s => s.id === 'PA' + upper);
            if (station) return station;
            station = metarStations.find(s => s.id === 'PH' + upper);
            if (station) return station;

            // Try by local code (FAA identifier)
            station = metarStations.find(s => s.localCode === upper);
            if (station) return station;

            // Try without K prefix
            if (upper.startsWith('K')) {
                station = metarStations.find(s => s.id === upper.substring(1));
                if (station) return station;
            }

            return null;
        }

        // Base airport list (dynamically expanded by fetchOurAirports)
        let metarStations = [
            // Major Hubs
            { id: 'KJFK', name: 'New York JFK', lat: 40.6413, lon: -73.7781 },
            { id: 'KLAX', name: 'Los Angeles', lat: 33.9425, lon: -118.4081 },
            { id: 'KORD', name: 'Chicago O\'Hare', lat: 41.9742, lon: -87.9073 },
            { id: 'KATL', name: 'Atlanta', lat: 33.6407, lon: -84.4277 },
            { id: 'KDFW', name: 'Dallas/Fort Worth', lat: 32.8998, lon: -97.0403 },
            { id: 'KDEN', name: 'Denver', lat: 39.8561, lon: -104.6737 },
            { id: 'KSFO', name: 'San Francisco', lat: 37.6213, lon: -122.3790 },
            { id: 'KSEA', name: 'Seattle', lat: 47.4502, lon: -122.3088 },
            { id: 'KMIA', name: 'Miami', lat: 25.7959, lon: -80.2870 },
            { id: 'KBOS', name: 'Boston', lat: 42.3656, lon: -71.0096 },
            { id: 'KPHX', name: 'Phoenix', lat: 33.4373, lon: -112.0078 },
            { id: 'KMSP', name: 'Minneapolis', lat: 44.8848, lon: -93.2223 },
            { id: 'KDTW', name: 'Detroit', lat: 42.2162, lon: -83.3554 },
            { id: 'KIAH', name: 'Houston Intercontinental', lat: 29.9902, lon: -95.3368 },
            { id: 'KLGA', name: 'LaGuardia', lat: 40.7769, lon: -73.8740 },
            { id: 'KEWR', name: 'Newark', lat: 40.6895, lon: -74.1745 },
            { id: 'KPHL', name: 'Philadelphia', lat: 39.8744, lon: -75.2424 },
            { id: 'KDCA', name: 'Washington Reagan', lat: 38.8512, lon: -77.0402 },
            { id: 'KIAD', name: 'Washington Dulles', lat: 38.9531, lon: -77.4565 },
            { id: 'KLAS', name: 'Las Vegas', lat: 36.0840, lon: -115.1537 },
            // California
            { id: 'KSAN', name: 'San Diego', lat: 32.7336, lon: -117.1897 },
            { id: 'KOAK', name: 'Oakland', lat: 37.7213, lon: -122.2208 },
            { id: 'KSJC', name: 'San Jose', lat: 37.3626, lon: -121.9291 },
            { id: 'KONT', name: 'Ontario', lat: 34.0560, lon: -117.6012 },
            { id: 'KBUR', name: 'Burbank', lat: 34.2007, lon: -118.3585 },
            { id: 'KSNA', name: 'John Wayne Orange County', lat: 33.6757, lon: -117.8682 },
            { id: 'KPSP', name: 'Palm Springs', lat: 33.8303, lon: -116.5067 },
            { id: 'KSMF', name: 'Sacramento', lat: 38.6954, lon: -121.5908 },
            { id: 'KFAT', name: 'Fresno', lat: 36.7762, lon: -119.7181 },
            { id: 'KSBP', name: 'San Luis Obispo', lat: 35.2368, lon: -120.6424 },
            { id: 'KMRY', name: 'Monterey', lat: 36.5870, lon: -121.8430 },
            { id: 'KCRQ', name: 'Carlsbad', lat: 33.1283, lon: -117.2803 },
            { id: 'KSBA', name: 'Santa Barbara', lat: 34.4262, lon: -119.8404 },
            { id: 'KLGB', name: 'Long Beach', lat: 33.8177, lon: -118.1516 },
            // Southwest
            { id: 'KTUS', name: 'Tucson', lat: 32.1161, lon: -110.9410 },
            { id: 'KABQ', name: 'Albuquerque', lat: 35.0402, lon: -106.6094 },
            { id: 'KELP', name: 'El Paso', lat: 31.8072, lon: -106.3778 },
            { id: 'KSLC', name: 'Salt Lake City', lat: 40.7884, lon: -111.9778 },
            // Texas
            { id: 'KHOU', name: 'Houston Hobby', lat: 29.6454, lon: -95.2789 },
            { id: 'KAUS', name: 'Austin', lat: 30.1975, lon: -97.6664 },
            { id: 'KSAT', name: 'San Antonio', lat: 29.5337, lon: -98.4698 },
            { id: 'KDAL', name: 'Dallas Love Field', lat: 32.8471, lon: -96.8518 },
            { id: 'KMAF', name: 'Midland', lat: 31.9425, lon: -102.2019 },
            { id: 'KLBB', name: 'Lubbock', lat: 33.6636, lon: -101.8228 },
            { id: 'KAMA', name: 'Amarillo', lat: 35.2194, lon: -101.7059 },
            { id: 'KCRP', name: 'Corpus Christi', lat: 27.7704, lon: -97.5012 },
            // Florida
            { id: 'KTPA', name: 'Tampa', lat: 27.9755, lon: -82.5332 },
            { id: 'KMCO', name: 'Orlando', lat: 28.4294, lon: -81.3090 },
            { id: 'KFLL', name: 'Fort Lauderdale', lat: 26.0726, lon: -80.1527 },
            { id: 'KPBI', name: 'Palm Beach', lat: 26.6832, lon: -80.0956 },
            { id: 'KJAX', name: 'Jacksonville', lat: 30.4941, lon: -81.6879 },
            { id: 'KRSW', name: 'Fort Myers', lat: 26.5362, lon: -81.7552 },
            { id: 'KSRQ', name: 'Sarasota', lat: 27.3954, lon: -82.5544 },
            { id: 'KPNS', name: 'Pensacola', lat: 30.4734, lon: -87.1866 },
            { id: 'KEYW', name: 'Key West', lat: 24.5561, lon: -81.7596 },
            // Southeast
            { id: 'KCLT', name: 'Charlotte', lat: 35.2140, lon: -80.9431 },
            { id: 'KRDU', name: 'Raleigh-Durham', lat: 35.8776, lon: -78.7875 },
            { id: 'KBNA', name: 'Nashville', lat: 36.1245, lon: -86.6782 },
            { id: 'KMEM', name: 'Memphis', lat: 35.0424, lon: -89.9767 },
            { id: 'KBHM', name: 'Birmingham', lat: 33.5629, lon: -86.7535 },
            { id: 'KMSY', name: 'New Orleans', lat: 29.9934, lon: -90.2580 },
            { id: 'KSAV', name: 'Savannah', lat: 32.1276, lon: -81.2021 },
            { id: 'KCHS', name: 'Charleston', lat: 32.8986, lon: -80.0405 },
            // Midwest
            { id: 'KSTL', name: 'St. Louis', lat: 38.7487, lon: -90.3700 },
            { id: 'KMCI', name: 'Kansas City', lat: 39.2976, lon: -94.7139 },
            { id: 'KOMA', name: 'Omaha', lat: 41.3032, lon: -95.8941 },
            { id: 'KDSM', name: 'Des Moines', lat: 41.5340, lon: -93.6631 },
            { id: 'KIND', name: 'Indianapolis', lat: 39.7173, lon: -86.2944 },
            { id: 'KCMH', name: 'Columbus', lat: 39.9980, lon: -82.8919 },
            { id: 'KCLE', name: 'Cleveland', lat: 41.4117, lon: -81.8498 },
            { id: 'KCVG', name: 'Cincinnati', lat: 39.0489, lon: -84.6678 },
            { id: 'KPIT', name: 'Pittsburgh', lat: 40.4915, lon: -80.2329 },
            { id: 'KMDW', name: 'Chicago Midway', lat: 41.7868, lon: -87.7522 },
            { id: 'KMKE', name: 'Milwaukee', lat: 42.9472, lon: -87.8966 },
            { id: 'KOSH', name: 'Oshkosh', lat: 43.9844, lon: -88.5570 },
            // Northeast
            { id: 'KBWI', name: 'Baltimore', lat: 39.1754, lon: -76.6683 },
            { id: 'KBDL', name: 'Hartford', lat: 41.9389, lon: -72.6832 },
            { id: 'KPVD', name: 'Providence', lat: 41.7267, lon: -71.4284 },
            { id: 'KMHT', name: 'Manchester NH', lat: 42.9326, lon: -71.4357 },
            { id: 'KPWM', name: 'Portland ME', lat: 43.6462, lon: -70.3093 },
            { id: 'KBTV', name: 'Burlington VT', lat: 44.4720, lon: -73.1533 },
            { id: 'KSYR', name: 'Syracuse', lat: 43.1112, lon: -76.1063 },
            { id: 'KBUF', name: 'Buffalo', lat: 42.9405, lon: -78.7322 },
            { id: 'KROC', name: 'Rochester', lat: 43.1189, lon: -77.6724 },
            { id: 'KALB', name: 'Albany', lat: 42.7483, lon: -73.8017 },
            // Northwest
            { id: 'KPDX', name: 'Portland OR', lat: 45.5898, lon: -122.5951 },
            { id: 'KBOI', name: 'Boise', lat: 43.5644, lon: -116.2228 },
            { id: 'KGEG', name: 'Spokane', lat: 47.6199, lon: -117.5338 },
            { id: 'KBZN', name: 'Bozeman', lat: 45.7775, lon: -111.1530 },
            { id: 'KMSO', name: 'Missoula', lat: 46.9163, lon: -114.0906 },
            { id: 'KBIL', name: 'Billings', lat: 45.8077, lon: -108.5429 },
            // Mountain/West
            { id: 'KCOS', name: 'Colorado Springs', lat: 38.8058, lon: -104.7007 },
            { id: 'KASE', name: 'Aspen', lat: 39.2232, lon: -106.8689 },
            { id: 'KEGE', name: 'Eagle/Vail', lat: 39.6426, lon: -106.9176 },
            { id: 'KGJT', name: 'Grand Junction', lat: 39.1224, lon: -108.5267 },
            { id: 'KRAP', name: 'Rapid City', lat: 44.0453, lon: -103.0574 },
            { id: 'KFSD', name: 'Sioux Falls', lat: 43.5820, lon: -96.7419 },
            { id: 'KJAC', name: 'Jackson Hole', lat: 43.6073, lon: -110.7377 },
            { id: 'KRNO', name: 'Reno', lat: 39.4991, lon: -119.7681 },
            // Alaska & Hawaii
            { id: 'PANC', name: 'Anchorage', lat: 61.1744, lon: -149.9964 },
            { id: 'PAFA', name: 'Fairbanks', lat: 64.8151, lon: -147.8561 },
            { id: 'PAJN', name: 'Juneau', lat: 58.3549, lon: -134.5762 },
            { id: 'PHNL', name: 'Honolulu', lat: 21.3187, lon: -157.9225 },
            { id: 'PHOG', name: 'Maui/Kahului', lat: 20.8986, lon: -156.4305 },
            { id: 'PHKO', name: 'Kona', lat: 19.7388, lon: -156.0456 },
            { id: 'PHLI', name: 'Lihue', lat: 21.9760, lon: -159.3390 },
            // Additional Regional
            { id: 'KICT', name: 'Wichita', lat: 37.6499, lon: -97.4331 },
            { id: 'KTUL', name: 'Tulsa', lat: 36.1984, lon: -95.8881 },
            { id: 'KOKC', name: 'Oklahoma City', lat: 35.3931, lon: -97.6007 },
            { id: 'KLIT', name: 'Little Rock', lat: 34.7294, lon: -92.2243 },
            { id: 'KSGF', name: 'Springfield MO', lat: 37.2457, lon: -93.3886 },
            { id: 'KLEX', name: 'Lexington', lat: 38.0365, lon: -84.6059 },
            { id: 'KSDF', name: 'Louisville', lat: 38.1740, lon: -85.7360 },
            { id: 'KGRR', name: 'Grand Rapids', lat: 42.8808, lon: -85.5228 },
            { id: 'KLAN', name: 'Lansing', lat: 42.7787, lon: -84.5874 },
            { id: 'KFNT', name: 'Flint', lat: 42.9655, lon: -83.7436 },
            { id: 'KGSO', name: 'Greensboro', lat: 36.0978, lon: -79.9373 },
            { id: 'KAVL', name: 'Asheville', lat: 35.4362, lon: -82.5418 },
            { id: 'KMYR', name: 'Myrtle Beach', lat: 33.6797, lon: -78.9283 },
            { id: 'KILM', name: 'Wilmington NC', lat: 34.2706, lon: -77.9026 },
            { id: 'KRIC', name: 'Richmond', lat: 37.5052, lon: -77.3197 },
            { id: 'KORF', name: 'Norfolk', lat: 36.8946, lon: -76.2012 },
            { id: 'KROA', name: 'Roanoke', lat: 37.3255, lon: -79.9754 },
            // Additional GA & Regional - Mountain West
            { id: 'KGTF', name: 'Great Falls MT', lat: 47.4820, lon: -111.3707 },
            { id: 'KHLN', name: 'Helena MT', lat: 46.6068, lon: -111.9827 },
            { id: 'KBUT', name: 'Butte MT', lat: 45.9548, lon: -112.4972 },
            { id: 'KLWT', name: 'Lewistown MT', lat: 47.0493, lon: -109.4673 },
            { id: 'KGGW', name: 'Glasgow MT', lat: 48.2125, lon: -106.6147 },
            { id: 'KSDY', name: 'Sidney MT', lat: 47.7069, lon: -104.1926 },
            { id: 'KMLS', name: 'Miles City MT', lat: 46.4280, lon: -105.8862 },
            { id: 'KDIK', name: 'Dickinson ND', lat: 46.7974, lon: -102.8020 },
            { id: 'KBIS', name: 'Bismarck ND', lat: 46.7727, lon: -100.7468 },
            { id: 'KMOT', name: 'Minot ND', lat: 48.2594, lon: -101.2803 },
            { id: 'KGFK', name: 'Grand Forks ND', lat: 47.9493, lon: -97.1761 },
            { id: 'KFAR', name: 'Fargo ND', lat: 46.9207, lon: -96.8158 },
            { id: 'KABR', name: 'Aberdeen SD', lat: 45.4491, lon: -98.4218 },
            { id: 'KPIR', name: 'Pierre SD', lat: 44.3827, lon: -100.2860 },
            { id: 'KCUT', name: 'Custer SD', lat: 43.7333, lon: -103.6178 },
            // Wyoming
            { id: 'KSHR', name: 'Sheridan WY', lat: 44.7692, lon: -106.9803 },
            { id: 'KCOD', name: 'Cody WY', lat: 44.5202, lon: -109.0238 },
            { id: 'KRIW', name: 'Riverton WY', lat: 43.0642, lon: -108.4598 },
            { id: 'KCPR', name: 'Casper WY', lat: 42.9080, lon: -106.4644 },
            { id: 'KLAR', name: 'Laramie WY', lat: 41.3121, lon: -105.6750 },
            { id: 'KCYS', name: 'Cheyenne WY', lat: 41.1557, lon: -104.8118 },
            { id: 'KRKS', name: 'Rock Springs WY', lat: 41.5942, lon: -109.0652 },
            // Nebraska & Kansas Rural
            { id: 'KSNY', name: 'Sidney NE', lat: 41.1013, lon: -102.9853 },
            { id: 'KAIA', name: 'Alliance NE', lat: 42.0532, lon: -102.8037 },
            { id: 'KCDP', name: 'Chadron NE', lat: 42.8376, lon: -103.0954 },
            { id: 'KVTN', name: 'Valentine NE', lat: 42.8578, lon: -100.5480 },
            { id: 'KLBF', name: 'North Platte NE', lat: 41.1262, lon: -100.6837 },
            { id: 'KGRI', name: 'Grand Island NE', lat: 40.9675, lon: -98.3096 },
            { id: 'KEAR', name: 'Kearney NE', lat: 40.7270, lon: -99.0068 },
            { id: 'KLNK', name: 'Lincoln NE', lat: 40.8510, lon: -96.7592 },
            { id: 'KGLD', name: 'Goodland KS', lat: 39.3706, lon: -101.6990 },
            { id: 'KHYS', name: 'Hays KS', lat: 38.8422, lon: -99.2732 },
            { id: 'KSLN', name: 'Salina KS', lat: 38.7910, lon: -97.6522 },
            { id: 'KMHK', name: 'Manhattan KS', lat: 39.1410, lon: -96.6708 },
            { id: 'KDDC', name: 'Dodge City KS', lat: 37.7634, lon: -99.9656 },
            { id: 'KGCK', name: 'Garden City KS', lat: 37.9275, lon: -100.7244 },
            { id: 'KLBL', name: 'Liberal KS', lat: 37.0442, lon: -100.9599 },
            // New Mexico & West Texas
            { id: 'KSAF', name: 'Santa Fe NM', lat: 35.6171, lon: -106.0892 },
            { id: 'KLAM', name: 'Los Alamos NM', lat: 35.8798, lon: -106.2694 },
            { id: 'KSKX', name: 'Taos NM', lat: 36.4582, lon: -105.6724 },
            { id: 'KROW', name: 'Roswell NM', lat: 33.3016, lon: -104.5307 },
            { id: 'KCNM', name: 'Carlsbad NM', lat: 32.3375, lon: -104.2633 },
            { id: 'KLRU', name: 'Las Cruces NM', lat: 32.2894, lon: -106.9219 },
            { id: 'KFMN', name: 'Farmington NM', lat: 36.7412, lon: -108.2299 },
            { id: 'KGUP', name: 'Gallup NM', lat: 35.5111, lon: -108.7893 },
            { id: 'KSVC', name: 'Silver City NM', lat: 32.6365, lon: -108.1563 },
            { id: 'KINK', name: 'Wink TX', lat: 31.7796, lon: -103.2016 },
            { id: 'KPRX', name: 'Paris TX', lat: 33.6366, lon: -95.4507 },
            { id: 'KABI', name: 'Abilene TX', lat: 32.4113, lon: -99.6819 },
            { id: 'KSJT', name: 'San Angelo TX', lat: 31.3577, lon: -100.4963 },
            { id: 'KMFE', name: 'McAllen TX', lat: 26.1758, lon: -98.2386 },
            { id: 'KBRO', name: 'Brownsville TX', lat: 25.9068, lon: -97.4259 },
            { id: 'KHRL', name: 'Harlingen TX', lat: 26.2285, lon: -97.6544 },
            { id: 'KLRD', name: 'Laredo TX', lat: 27.5438, lon: -99.4617 },
            { id: 'KDRT', name: 'Del Rio TX', lat: 29.3742, lon: -100.9273 },
            // Arizona Rural
            { id: 'KFLG', name: 'Flagstaff AZ', lat: 35.1385, lon: -111.6712 },
            { id: 'KPRC', name: 'Prescott AZ', lat: 34.6545, lon: -112.4196 },
            { id: 'KSEZ', name: 'Sedona AZ', lat: 34.8486, lon: -111.7884 },
            { id: 'KPGA', name: 'Page AZ', lat: 36.9261, lon: -111.4483 },
            { id: 'KGCN', name: 'Grand Canyon AZ', lat: 35.9524, lon: -112.1470 },
            { id: 'KIGM', name: 'Kingman AZ', lat: 35.2595, lon: -113.9380 },
            { id: 'KIWA', name: 'Phoenix-Mesa Gateway', lat: 33.3078, lon: -111.6556 },
            { id: 'KCHD', name: 'Chandler AZ', lat: 33.2691, lon: -111.8111 },
            { id: 'KDVT', name: 'Phoenix Deer Valley', lat: 33.6883, lon: -112.0825 },
            { id: 'KFFZ', name: 'Mesa Falcon Field', lat: 33.4608, lon: -111.7285 },
            { id: 'KSDL', name: 'Scottsdale', lat: 33.6229, lon: -111.9105 },
            // Utah
            { id: 'KCDC', name: 'Cedar City UT', lat: 37.7010, lon: -113.0986 },
            { id: 'KSGU', name: 'St George UT', lat: 37.0364, lon: -113.5103 },
            { id: 'KPVU', name: 'Provo UT', lat: 40.2192, lon: -111.7235 },
            { id: 'KOGD', name: 'Ogden UT', lat: 41.1961, lon: -112.0122 },
            { id: 'KLGU', name: 'Logan UT', lat: 41.7912, lon: -111.8522 },
            { id: 'KVEL', name: 'Vernal UT', lat: 40.4409, lon: -109.5099 },
            { id: 'KPUC', name: 'Price UT', lat: 39.6094, lon: -110.7514 },
            { id: 'KCNY', name: 'Moab UT', lat: 38.7550, lon: -109.7549 },
            // Nevada
            { id: 'KVGT', name: 'Las Vegas North', lat: 36.2107, lon: -115.1944 },
            { id: 'KHND', name: 'Henderson NV', lat: 35.9728, lon: -115.1344 },
            { id: 'KELN', name: 'Elko NV', lat: 40.8249, lon: -115.7920 },
            { id: 'KEKO', name: 'Elko Regional', lat: 40.8249, lon: -115.7917 },
            { id: 'KWMC', name: 'Winnemucca NV', lat: 40.8966, lon: -117.8059 },
            { id: 'KELY', name: 'Ely NV', lat: 39.2997, lon: -114.8419 },
            { id: 'KTNX', name: 'Tonopah NV', lat: 38.0537, lon: -117.0873 },
            // Idaho
            { id: 'KTWF', name: 'Twin Falls ID', lat: 42.4818, lon: -114.4877 },
            { id: 'KPIH', name: 'Pocatello ID', lat: 42.9098, lon: -112.5959 },
            { id: 'KIDA', name: 'Idaho Falls ID', lat: 43.5146, lon: -112.0708 },
            { id: 'KLWS', name: 'Lewiston ID', lat: 46.3745, lon: -117.0154 },
            { id: 'KSUN', name: 'Sun Valley ID', lat: 43.5044, lon: -114.2962 },
            { id: 'KMYL', name: 'McCall ID', lat: 44.8897, lon: -116.1015 },
            // Oregon & Washington Rural
            { id: 'KEUG', name: 'Eugene OR', lat: 44.1246, lon: -123.2190 },
            { id: 'KMFR', name: 'Medford OR', lat: 42.3742, lon: -122.8735 },
            { id: 'KRDM', name: 'Redmond OR', lat: 44.2541, lon: -121.1500 },
            { id: 'KPDT', name: 'Pendleton OR', lat: 45.6951, lon: -118.8414 },
            { id: 'KLMT', name: 'Klamath Falls OR', lat: 42.1561, lon: -121.7332 },
            { id: 'KONP', name: 'Newport OR', lat: 44.5804, lon: -124.0579 },
            { id: 'KAST', name: 'Astoria OR', lat: 46.1580, lon: -123.8787 },
            { id: 'KYKM', name: 'Yakima WA', lat: 46.5682, lon: -120.5441 },
            { id: 'KPSC', name: 'Pasco WA', lat: 46.2647, lon: -119.1191 },
            { id: 'KEAT', name: 'Wenatchee WA', lat: 47.3986, lon: -120.2069 },
            { id: 'KEPH', name: 'Ephrata WA', lat: 47.3076, lon: -119.5159 },
            { id: 'KPUW', name: 'Pullman WA', lat: 46.7439, lon: -117.1096 },
            { id: 'KBLI', name: 'Bellingham WA', lat: 48.7928, lon: -122.5375 },
            { id: 'KCLM', name: 'Port Angeles WA', lat: 48.1202, lon: -123.4997 },
            // California Rural & GA
            { id: 'KRDD', name: 'Redding CA', lat: 40.5090, lon: -122.2934 },
            { id: 'KUKI', name: 'Ukiah CA', lat: 39.1260, lon: -123.2009 },
            { id: 'KEKA', name: 'Eureka CA', lat: 40.8034, lon: -124.1128 },
            { id: 'KCEC', name: 'Crescent City CA', lat: 41.7802, lon: -124.2365 },
            { id: 'KMCE', name: 'Merced CA', lat: 37.2847, lon: -120.5139 },
            { id: 'KMOD', name: 'Modesto CA', lat: 37.6258, lon: -120.9542 },
            { id: 'KVIS', name: 'Visalia CA', lat: 36.3187, lon: -119.3929 },
            { id: 'KBFL', name: 'Bakersfield CA', lat: 35.4336, lon: -119.0568 },
            { id: 'KTRM', name: 'Palm Springs Thermal', lat: 33.6267, lon: -116.1600 },
            { id: 'KIPL', name: 'Imperial CA', lat: 32.8342, lon: -115.5787 },
            { id: 'KEED', name: 'Needles CA', lat: 34.7663, lon: -114.6233 },
            { id: 'KDAG', name: 'Barstow-Daggett CA', lat: 34.8537, lon: -116.7867 },
            { id: 'KVNY', name: 'Van Nuys CA', lat: 34.2098, lon: -118.4900 },
            { id: 'KSMO', name: 'Santa Monica CA', lat: 34.0158, lon: -118.4513 },
            { id: 'KTOA', name: 'Torrance CA', lat: 33.8034, lon: -118.3396 },
            { id: 'KFUL', name: 'Fullerton CA', lat: 33.8720, lon: -117.9795 },
            { id: 'KCMA', name: 'Camarillo CA', lat: 34.2137, lon: -119.0943 },
            { id: 'KOXR', name: 'Oxnard CA', lat: 34.2008, lon: -119.2072 },
            { id: 'KWHP', name: 'Whiteman CA', lat: 34.2593, lon: -118.4134 },
            { id: 'KCNO', name: 'Chino CA', lat: 33.9747, lon: -117.6368 },
            { id: 'KPOC', name: 'Pomona CA', lat: 34.0916, lon: -117.7817 },
            { id: 'KRAL', name: 'Riverside CA', lat: 33.9519, lon: -117.4451 },
            { id: 'KRNM', name: 'Ramona CA', lat: 33.0392, lon: -116.9153 },
            { id: 'KSEE', name: 'San Diego Gillespie', lat: 32.8262, lon: -116.9724 },
            { id: 'KMYF', name: 'San Diego Montgomery', lat: 32.8158, lon: -117.1397 },
            // Popular GA Destinations & Training Airports
            { id: 'KFXE', name: 'Fort Lauderdale Exec', lat: 26.1973, lon: -80.1707 },
            { id: 'KOPF', name: 'Miami Opa-Locka', lat: 25.9070, lon: -80.2784 },
            { id: 'KTMB', name: 'Miami Kendall-Tamiami', lat: 25.6479, lon: -80.4328 },
            { id: 'KAPF', name: 'Naples FL', lat: 26.1526, lon: -81.7753 },
            { id: 'KPGD', name: 'Punta Gorda FL', lat: 26.9202, lon: -81.9905 },
            { id: 'KLAL', name: 'Lakeland FL', lat: 27.9889, lon: -82.0186 },
            { id: 'KOCF', name: 'Ocala FL', lat: 29.1726, lon: -82.2241 },
            { id: 'KGNV', name: 'Gainesville FL', lat: 29.6901, lon: -82.2718 },
            { id: 'KSGJ', name: 'St Augustine FL', lat: 29.9592, lon: -81.3397 },
            { id: 'KDAB', name: 'Daytona Beach FL', lat: 29.1799, lon: -81.0581 },
            { id: 'KMLB', name: 'Melbourne FL', lat: 28.1028, lon: -80.6453 },
            { id: 'KVRB', name: 'Vero Beach FL', lat: 27.6556, lon: -80.4179 },
            { id: 'KSPG', name: 'St Petersburg FL', lat: 27.7651, lon: -82.6270 },
            { id: 'KPIE', name: 'St Pete-Clearwater FL', lat: 27.9102, lon: -82.6874 },
            { id: 'KVDF', name: 'Tampa Vandenberg', lat: 28.0140, lon: -82.3453 },
            { id: 'KISM', name: 'Orlando Kissimmee', lat: 28.2898, lon: -81.4371 },
            { id: 'KORL', name: 'Orlando Executive', lat: 28.5455, lon: -81.3329 },
            { id: 'KSFB', name: 'Orlando Sanford', lat: 28.7776, lon: -81.2375 },
            // Georgia & South
            { id: 'KPDK', name: 'Atlanta Peachtree-DeKalb', lat: 33.8756, lon: -84.3020 },
            { id: 'KFTY', name: 'Atlanta Fulton County', lat: 33.7791, lon: -84.5214 },
            { id: 'KRYY', name: 'Atlanta Cobb County', lat: 34.0132, lon: -84.5971 },
            { id: 'KLZU', name: 'Atlanta Gwinnett County', lat: 33.9781, lon: -83.9624 },
            { id: 'KAHN', name: 'Athens GA', lat: 33.9486, lon: -83.3263 },
            { id: 'KMCN', name: 'Macon GA', lat: 32.6927, lon: -83.6492 },
            { id: 'KABY', name: 'Albany GA', lat: 31.5355, lon: -84.1945 },
            { id: 'KVLD', name: 'Valdosta GA', lat: 30.7825, lon: -83.2767 },
            { id: 'KBQK', name: 'Brunswick GA', lat: 31.2588, lon: -81.4665 },
            { id: 'KMOB', name: 'Mobile AL', lat: 30.6914, lon: -88.2428 },
            { id: 'KMGM', name: 'Montgomery AL', lat: 32.3006, lon: -86.3940 },
            { id: 'KHSV', name: 'Huntsville AL', lat: 34.6372, lon: -86.7751 },
            { id: 'KGPT', name: 'Gulfport MS', lat: 30.4073, lon: -89.0701 },
            { id: 'KJAN', name: 'Jackson MS', lat: 32.3112, lon: -90.0759 },
            { id: 'KGTR', name: 'Columbus-Golden Triangle MS', lat: 33.4503, lon: -88.5914 },
            // Arkansas & Louisiana
            { id: 'KXNA', name: 'Fayetteville AR', lat: 36.2819, lon: -94.3068 },
            { id: 'KFSM', name: 'Fort Smith AR', lat: 35.3366, lon: -94.3674 },
            { id: 'KJBR', name: 'Jonesboro AR', lat: 35.8317, lon: -90.6462 },
            { id: 'KTXK', name: 'Texarkana AR', lat: 33.4537, lon: -93.9910 },
            { id: 'KHOT', name: 'Hot Springs AR', lat: 34.4780, lon: -93.0962 },
            { id: 'KSHV', name: 'Shreveport LA', lat: 32.4466, lon: -93.8256 },
            { id: 'KMLB', name: 'Monroe LA', lat: 32.5109, lon: -92.0377 },
            { id: 'KAEX', name: 'Alexandria LA', lat: 31.3274, lon: -92.5498 },
            { id: 'KLFT', name: 'Lafayette LA', lat: 30.2053, lon: -91.9876 },
            { id: 'KBTR', name: 'Baton Rouge LA', lat: 30.5332, lon: -91.1496 },
            { id: 'KLCH', name: 'Lake Charles LA', lat: 30.1261, lon: -93.2234 },
            // North Carolina & Virginia
            { id: 'KPOB', name: 'Fayetteville Pope NC', lat: 35.1709, lon: -79.0145 },
            { id: 'KEWN', name: 'New Bern NC', lat: 35.0730, lon: -77.0429 },
            { id: 'KOAJ', name: 'Jacksonville NC', lat: 34.8292, lon: -77.6121 },
            { id: 'KPGV', name: 'Greenville NC', lat: 35.6352, lon: -77.3853 },
            { id: 'KINT', name: 'Winston-Salem NC', lat: 36.1337, lon: -80.2220 },
            { id: 'KHKY', name: 'Hickory NC', lat: 35.7411, lon: -81.3895 },
            { id: 'KCPK', name: 'Chesapeake VA', lat: 36.6656, lon: -76.3206 },
            { id: 'KPHF', name: 'Newport News VA', lat: 37.1319, lon: -76.4930 },
            { id: 'KLYH', name: 'Lynchburg VA', lat: 37.3267, lon: -79.2004 },
            { id: 'KCHO', name: 'Charlottesville VA', lat: 38.1386, lon: -78.4529 },
            { id: 'KSHD', name: 'Staunton VA', lat: 38.2638, lon: -78.8964 },
            // Additional Northeast
            { id: 'KAVP', name: 'Wilkes-Barre PA', lat: 41.3385, lon: -75.7234 },
            { id: 'KMDT', name: 'Harrisburg PA', lat: 40.1935, lon: -76.7634 },
            { id: 'KIPT', name: 'Williamsport PA', lat: 41.2419, lon: -76.9211 },
            { id: 'KERI', name: 'Erie PA', lat: 42.0831, lon: -80.1762 },
            { id: 'KLBE', name: 'Latrobe PA', lat: 40.2759, lon: -79.4048 },
            { id: 'KAOO', name: 'Altoona PA', lat: 40.2964, lon: -78.3200 },
            { id: 'KUNV', name: 'State College PA', lat: 40.8493, lon: -77.8487 },
            { id: 'KABE', name: 'Allentown PA', lat: 40.6521, lon: -75.4408 },
            { id: 'KILG', name: 'Wilmington DE', lat: 39.6787, lon: -75.6065 },
            { id: 'KACY', name: 'Atlantic City NJ', lat: 39.4576, lon: -74.5772 },
            { id: 'KCDW', name: 'Caldwell NJ', lat: 40.8752, lon: -74.2814 },
            { id: 'KTEB', name: 'Teterboro NJ', lat: 40.8501, lon: -74.0608 },
            { id: 'KMMK', name: 'Morristown NJ', lat: 40.7994, lon: -74.4149 },
            { id: 'KSWF', name: 'Newburgh NY', lat: 41.5041, lon: -74.1048 },
            { id: 'KHPN', name: 'White Plains NY', lat: 41.0670, lon: -73.7076 },
            { id: 'KFRG', name: 'Farmingdale NY', lat: 40.7288, lon: -73.4134 },
            { id: 'KISP', name: 'Islip NY', lat: 40.7952, lon: -73.1002 },
            { id: 'KFOK', name: 'Westhampton NY', lat: 40.8437, lon: -72.6318 },
            { id: 'KBGM', name: 'Binghamton NY', lat: 42.2087, lon: -75.9798 },
            { id: 'KELM', name: 'Elmira NY', lat: 42.1599, lon: -76.8916 },
            { id: 'KITH', name: 'Ithaca NY', lat: 42.4910, lon: -76.4584 },
            { id: 'KPOU', name: 'Poughkeepsie NY', lat: 41.6266, lon: -73.8842 },
            // New England
            { id: 'KBGR', name: 'Bangor ME', lat: 44.8074, lon: -68.8281 },
            { id: 'KAUG', name: 'Augusta ME', lat: 44.3206, lon: -69.7973 },
            { id: 'KLEB', name: 'Lebanon NH', lat: 43.6261, lon: -72.3042 },
            { id: 'KPSM', name: 'Portsmouth NH', lat: 43.0779, lon: -70.8233 },
            { id: 'KORH', name: 'Worcester MA', lat: 42.2673, lon: -71.8757 },
            { id: 'KBAF', name: 'Westfield MA', lat: 42.1578, lon: -72.7156 },
            { id: 'KACK', name: 'Nantucket MA', lat: 41.2531, lon: -70.0602 },
            { id: 'KMVY', name: 'Martha\'s Vineyard MA', lat: 41.3931, lon: -70.6143 },
            { id: 'KHYA', name: 'Hyannis MA', lat: 41.6693, lon: -70.2804 },
            { id: 'KGON', name: 'Groton CT', lat: 41.3301, lon: -72.0451 },
            { id: 'KHVN', name: 'New Haven CT', lat: 41.2637, lon: -72.8868 },
            { id: 'KDXR', name: 'Danbury CT', lat: 41.3715, lon: -73.4822 },
            { id: 'KOQU', name: 'North Kingstown RI', lat: 41.5971, lon: -71.4121 },
            // Midwest Additional
            { id: 'KBMI', name: 'Bloomington IL', lat: 40.4771, lon: -88.9159 },
            { id: 'KSPI', name: 'Springfield IL', lat: 39.8441, lon: -89.6779 },
            { id: 'KMLI', name: 'Moline IL', lat: 41.4485, lon: -90.5075 },
            { id: 'KPIA', name: 'Peoria IL', lat: 40.6642, lon: -89.6933 },
            { id: 'KDEC', name: 'Decatur IL', lat: 39.8346, lon: -88.8657 },
            { id: 'KCMI', name: 'Champaign IL', lat: 40.0392, lon: -88.2781 },
            { id: 'KPWK', name: 'Chicago Executive', lat: 42.1142, lon: -87.9015 },
            { id: 'KDPA', name: 'DuPage IL', lat: 41.9078, lon: -88.2486 },
            { id: 'KARR', name: 'Aurora IL', lat: 41.7719, lon: -88.4757 },
            { id: 'KLOT', name: 'Joliet IL', lat: 41.6073, lon: -88.0962 },
            { id: 'KIGQ', name: 'Lansing IL', lat: 41.5350, lon: -87.5297 },
            { id: 'KGYY', name: 'Gary IN', lat: 41.6163, lon: -87.4128 },
            { id: 'KSBN', name: 'South Bend IN', lat: 41.7087, lon: -86.3173 },
            { id: 'KFWA', name: 'Fort Wayne IN', lat: 40.9785, lon: -85.1951 },
            { id: 'KEVV', name: 'Evansville IN', lat: 38.0370, lon: -87.5324 },
            { id: 'KTYQ', name: 'Indianapolis Executive', lat: 40.0303, lon: -86.2514 },
            { id: 'KEYE', name: 'Indianapolis Eagle Creek', lat: 39.8306, lon: -86.2944 },
            { id: 'KMIE', name: 'Muncie IN', lat: 40.2423, lon: -85.3959 },
            { id: 'KLAF', name: 'Lafayette IN', lat: 40.4123, lon: -86.9369 },
            { id: 'KTOL', name: 'Toledo OH', lat: 41.5868, lon: -83.8078 },
            { id: 'KYNG', name: 'Youngstown OH', lat: 41.2607, lon: -80.6790 },
            { id: 'KCAK', name: 'Akron-Canton OH', lat: 40.9161, lon: -81.4422 },
            { id: 'KDAY', name: 'Dayton OH', lat: 39.9024, lon: -84.2194 },
            { id: 'KLUK', name: 'Cincinnati Lunken', lat: 39.1033, lon: -84.4186 },
            { id: 'KILN', name: 'Wilmington OH', lat: 39.4279, lon: -83.7921 },
            { id: 'KOSU', name: 'Columbus Ohio State', lat: 40.0798, lon: -83.0730 },
            { id: 'KTZR', name: 'Columbus Bolton', lat: 39.9010, lon: -83.1371 },
            { id: 'KCGF', name: 'Cleveland Cuyahoga', lat: 41.5651, lon: -81.4864 },
            { id: 'KBKL', name: 'Cleveland Burke Lakefront', lat: 41.5175, lon: -81.6833 },
            { id: 'KAPN', name: 'Alpena MI', lat: 45.0781, lon: -83.5603 },
            { id: 'KTVC', name: 'Traverse City MI', lat: 44.7414, lon: -85.5822 },
            { id: 'KESC', name: 'Escanaba MI', lat: 45.7227, lon: -87.0937 },
            { id: 'KMQT', name: 'Marquette MI', lat: 46.3536, lon: -87.3954 },
            { id: 'KCMX', name: 'Hancock MI', lat: 47.1684, lon: -88.4891 },
            { id: 'KIWD', name: 'Ironwood MI', lat: 46.5275, lon: -90.1314 },
            { id: 'KSAW', name: 'Sault Ste Marie MI', lat: 46.4854, lon: -84.3514 },
            { id: 'KPLN', name: 'Pellston MI', lat: 45.5709, lon: -84.7967 },
            { id: 'KMKG', name: 'Muskegon MI', lat: 43.1695, lon: -86.2382 },
            { id: 'KAZO', name: 'Kalamazoo MI', lat: 42.2350, lon: -85.5521 },
            { id: 'KJXN', name: 'Jackson MI', lat: 42.2598, lon: -84.4594 },
            { id: 'KARB', name: 'Ann Arbor MI', lat: 42.2230, lon: -83.7456 },
            { id: 'KPTK', name: 'Pontiac MI', lat: 42.6655, lon: -83.4201 },
            { id: 'KYIP', name: 'Detroit Willow Run', lat: 42.2379, lon: -83.5304 },
            { id: 'KDUH', name: 'Duluth MN', lat: 46.8422, lon: -92.1936 },
            { id: 'KHIB', name: 'Hibbing MN', lat: 47.3866, lon: -92.8390 },
            { id: 'KINL', name: 'International Falls MN', lat: 48.5662, lon: -93.4031 },
            { id: 'KBRD', name: 'Brainerd MN', lat: 46.3983, lon: -94.1372 },
            { id: 'KSTC', name: 'St Cloud MN', lat: 45.5466, lon: -94.0599 },
            { id: 'KRST', name: 'Rochester MN', lat: 43.9083, lon: -92.5000 },
            { id: 'KFCM', name: 'Minneapolis Flying Cloud', lat: 44.8272, lon: -93.4571 },
            { id: 'KANE', name: 'Minneapolis Anoka', lat: 45.1450, lon: -93.2114 },
            { id: 'KEAU', name: 'Eau Claire WI', lat: 44.8658, lon: -91.4843 },
            { id: 'KLSE', name: 'La Crosse WI', lat: 43.8793, lon: -91.2567 },
            { id: 'KMSN', name: 'Madison WI', lat: 43.1399, lon: -89.3375 },
            { id: 'KATW', name: 'Appleton WI', lat: 44.2581, lon: -88.5191 },
            { id: 'KGRB', name: 'Green Bay WI', lat: 44.4851, lon: -88.1296 },
            { id: 'KUES', name: 'Waukesha WI', lat: 43.0410, lon: -88.2370 },
            { id: 'KENW', name: 'Kenosha WI', lat: 42.5957, lon: -87.9278 },
            { id: 'KRAC', name: 'Racine WI', lat: 42.7610, lon: -87.8152 },
            { id: 'KRHI', name: 'Rhinelander WI', lat: 45.6312, lon: -89.4675 },
            { id: 'KCWA', name: 'Wausau WI', lat: 44.7776, lon: -89.6668 },
            // Iowa & Missouri
            { id: 'KDBQ', name: 'Dubuque IA', lat: 42.4020, lon: -90.7095 },
            { id: 'KCID', name: 'Cedar Rapids IA', lat: 41.8847, lon: -91.7108 },
            { id: 'KALO', name: 'Waterloo IA', lat: 42.5571, lon: -92.4003 },
            { id: 'KMCW', name: 'Mason City IA', lat: 43.1578, lon: -93.3313 },
            { id: 'KSUX', name: 'Sioux City IA', lat: 42.4026, lon: -96.3844 },
            { id: 'KJEF', name: 'Jefferson City MO', lat: 38.5912, lon: -92.1561 },
            { id: 'KCOU', name: 'Columbia MO', lat: 38.8181, lon: -92.2196 },
            { id: 'KIRK', name: 'Kirksville MO', lat: 40.0935, lon: -92.5449 },
            { id: 'KJLN', name: 'Joplin MO', lat: 37.1518, lon: -94.4983 },
            { id: 'KCGI', name: 'Cape Girardeau MO', lat: 37.2253, lon: -89.5708 },
            { id: 'KSPD', name: 'Springfield Downtown MO', lat: 37.2392, lon: -93.2839 }
        ];

        // Flight rules colors
        const flightRulesColors = {
            'VFR': '#22c55e',
            'MVFR': '#3b82f6',
            'IFR': '#ef4444',
            'LIFR': '#a855f7'
        };

        // Store METAR data
        const metarData = {};

        // Overlay states (for both map and profile)
        const overlayState = {
            terrain: false,
            clouds: false,
            conditions: false,
            airspace: false,
            icing: false,
            turbulence: false,
            winds: false,
            temperature: false,
            dewpoint: false,
            radar: false,
            stations: false,
            traffic: false,
            airways: false,
            runways: false
        };

        // Alias for profile drawing compatibility
        const profileOverlays = overlayState;

        // X-Plane 12 Integration State
        const xplaneState = {
            enabled: false,
            connected: false,
            receiving: false,
            websocket: null,
            lastPacketTime: 0,
            reconnectAttempts: 0,
            maxReconnectAttempts: 10,
            reconnectDelay: 2000,
            packetsReceived: 0,
            profilePosition: null,
            flightData: {
                lat: 0, lon: 0,
                alt_msl: 0, alt_agl: 0,
                heading_true: 0, heading_mag: 0,
                pitch: 0, roll: 0,
                airspeed_ind: 0, groundspeed: 0,
                vertical_speed: 0
            }
        };

        // X-Plane aircraft marker
        let xplaneMarker = null;

        // Custom waypoint state (currentRoute, customWaypoints, customStops defined earlier)
        let waypointMode = false;
        let snapMode = false;
        let waypointMarkers = [];
        let waypointPreviewLine = null;
        let waypointCounter = 0;

        // Custom stop state (landing stops along route)
        let stopMode = false;
        let stopMarkers = [];
        let stopCounter = 0;

        // Profile zoom and pan state
        const profileView = {
            zoom: 1,
            panX: 0,  // Pan offset in pixels (horizontal)
            panY: 0,  // Pan offset in pixels (vertical)
            isDragging: false,
            lastMouseX: 0,
            minimized: true,  // Start minimized - user must click to expand
            lastMouseY: 0
        };

        // Constrain pan to keep content visible within viewport
        function constrainPan() {
            const canvas = document.getElementById('profileCanvas');
            if (!canvas) return;

            const width = canvas.width;
            const height = canvas.height;
            const zoom = profileView.zoom;
            const padding = 40; // Match the profile drawing padding
            const paddingRight = 60; // Match the profile drawing paddingRight
            const paddingBottom = 80; // Match the profile drawing padding

            // At zoom 1, no panning (everything fits)
            if (zoom <= 1) {
                profileView.panX = 0;
                profileView.panY = 0;
                return;
            }

            // Calculate the visible canvas coordinate range for current pan
            // Screen coords 0 to width map to canvas coords based on transform:
            // screenX = (canvasX - centerX) * zoom + centerX + panX
            // So: canvasX = (screenX - centerX - panX) / zoom + centerX

            const centerX = width / 2;
            const centerY = height / 2;

            // Content bounds in canvas coordinates
            const contentLeft = padding;
            const contentRight = width - paddingRight;
            const contentTop = padding;
            const contentBottom = height - paddingBottom;

            // Calculate max pan to keep content edges within view
            // We want: when panned max right, content left edge is at screen left (+ small margin)
            // And: when panned max left, content right edge is at screen right (- small margin)

            // Content left edge on screen: (contentLeft - centerX) * zoom + centerX + panX
            // For this to be <= some margin (e.g., width * 0.1): panX <= margin - (contentLeft - centerX) * zoom - centerX

            // Content right edge on screen: (contentRight - centerX) * zoom + centerX + panX
            // For this to be >= width - margin: panX >= width - margin - (contentRight - centerX) * zoom - centerX

            const margin = width * 0.15; // Keep at least 15% content visible

            // Max pan right (content shifts left): content left edge should stay at least at margin
            const maxPanRight = margin - (contentLeft - centerX) * zoom - centerX;

            // Max pan left (content shifts right): content right edge should stay at least at width - margin
            const maxPanLeft = (width - margin) - (contentRight - centerX) * zoom - centerX;

            // Vertical constraints (similar logic)
            const marginY = height * 0.15;
            const maxPanDown = marginY - (contentTop - centerY) * zoom - centerY;
            const maxPanUp = (height - marginY) - (contentBottom - centerY) * zoom - centerY;

            // Apply constraints
            profileView.panX = Math.max(maxPanLeft, Math.min(maxPanRight, profileView.panX));
            profileView.panY = Math.max(maxPanUp, Math.min(maxPanDown, profileView.panY));
        }

        // Zoom functions
        function profileZoom(factor) {
            const oldZoom = profileView.zoom;
            profileView.zoom = Math.max(1, Math.min(10, profileView.zoom * factor));

            // Scale pan proportionally when zooming
            if (oldZoom !== profileView.zoom) {
                const zoomRatio = profileView.zoom / oldZoom;
                profileView.panX *= zoomRatio;
                profileView.panY *= zoomRatio;
            }

            constrainPan();
            updateZoomDisplay();
            if (currentRoute.dep && currentRoute.dest) {
                drawProfile(currentRoute.dep, currentRoute.dest);
            }
        }

        function profileResetZoom() {
            profileView.zoom = 1;
            profileView.panX = 0;
            profileView.panY = 0;
            updateZoomDisplay();
            if (currentRoute.dep && currentRoute.dest) {
                drawProfile(currentRoute.dep, currentRoute.dest);
            }
        }

        function updateZoomDisplay() {
            document.getElementById('profileZoomLevel').textContent = profileView.zoom.toFixed(1) + 'x';
        }

        // Setup profile zoom/pan events
        function setupProfileZoomPan() {
            const canvas = document.getElementById('profileCanvas');

            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const oldZoom = profileView.zoom;
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                profileView.zoom = Math.max(1, Math.min(10, profileView.zoom * zoomFactor));

                if (oldZoom !== profileView.zoom) {
                    // Zoom toward mouse position
                    // Calculate offset from center
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const offsetX = mouseX - centerX;
                    const offsetY = mouseY - centerY;

                    // Adjust pan to keep mouse position stable
                    const zoomRatio = profileView.zoom / oldZoom;
                    profileView.panX = profileView.panX * zoomRatio - offsetX * (zoomRatio - 1);
                    profileView.panY = profileView.panY * zoomRatio - offsetY * (zoomRatio - 1);

                    constrainPan();
                    updateZoomDisplay();
                    if (currentRoute.dep && currentRoute.dest) {
                        drawProfile(currentRoute.dep, currentRoute.dest);
                    }
                }
            }, { passive: false });

            // Mouse drag pan
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0 && profileView.zoom > 1) { // Left click and zoomed in
                    profileView.isDragging = true;
                    profileView.lastMouseX = e.clientX;
                    profileView.lastMouseY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (profileView.isDragging) {
                    const dx = e.clientX - profileView.lastMouseX;
                    const dy = e.clientY - profileView.lastMouseY;
                    profileView.panX += dx;
                    profileView.panY += dy;
                    profileView.lastMouseX = e.clientX;
                    profileView.lastMouseY = e.clientY;

                    constrainPan();
                    if (currentRoute.dep && currentRoute.dest) {
                        drawProfile(currentRoute.dep, currentRoute.dest);
                    }
                }
            });

            canvas.addEventListener('mouseup', () => {
                profileView.isDragging = false;
                canvas.style.cursor = 'crosshair';
            });

            canvas.addEventListener('mouseleave', () => {
                profileView.isDragging = false;
                canvas.style.cursor = 'crosshair';
            });
        }

        // Helper function to remove an overlay layer from the map
        function removeOverlayLayer(overlay) {
            switch (overlay) {
                case 'terrain':
                    map.removeLayer(terrainLayer);
                    break;
                case 'clouds':
                    if (cloudsLayer) map.removeLayer(cloudsLayer);
                    break;
                case 'conditions':
                    map.removeLayer(conditionsLayer);
                    break;
                case 'airspace':
                    map.removeLayer(airspaceLayer);
                    break;
                case 'icing':
                    map.removeLayer(icingLayer);
                    break;
                case 'turbulence':
                    map.removeLayer(turbulenceLayer);
                    break;
                case 'winds':
                    map.removeLayer(windsLayer);
                    break;
                case 'temperature':
                    map.removeLayer(temperatureLayer);
                    break;
                case 'dewpoint':
                    map.removeLayer(dewpointLayer);
                    break;
            }
        }

        // Toggle overlay (affects both map and profile)
        // All overlays can now be active simultaneously
        async function toggleOverlay(btn) {
            const overlay = btn.dataset.overlay;

            // Simply toggle this overlay - no mutual exclusion
            overlayState[overlay] = !overlayState[overlay];
            btn.classList.toggle('active');

            // Handle map layers
            switch (overlay) {
                case 'terrain':
                    if (overlayState.terrain) {
                        createTerrainOverlay();
                        terrainLayer.addTo(map);
                    } else {
                        map.removeLayer(terrainLayer);
                    }
                    break;

                case 'clouds':
                    if (overlayState.clouds && cloudsLayer) {
                        cloudsLayer.addTo(map);
                    } else if (cloudsLayer) {
                        map.removeLayer(cloudsLayer);
                    }
                    break;

                case 'conditions':
                    if (overlayState.conditions) {
                        // Auto-load METAR if not loaded
                        if (!stationsMetarLoaded && !stationsLoading) {
                            stationsLoading = true;
                            Promise.all([fetchOurAirports(), fetchFAAairports()]).then(() => {
                                stationsDataLoaded = true;
                                loadMetarStations().then(() => {
                                    stationsMetarLoaded = true;
                                    stationsLoading = false;
                                    if (overlayState.conditions) {
                                        createConditionsOverlay();
                                        conditionsLayer.addTo(map);
                                    }
                                });
                            });
                        } else if (stationsMetarLoaded) {
                            createConditionsOverlay();
                            conditionsLayer.addTo(map);
                        }
                    } else {
                        map.removeLayer(conditionsLayer);
                    }
                    break;

                case 'airspace':
                    if (overlayState.airspace) {
                        createAirspaceOverlay(); // Recreate with current zoom level
                        airspaceLayer.addTo(map);
                    } else {
                        map.removeLayer(airspaceLayer);
                    }
                    break;

                case 'icing':
                    if (overlayState.icing) {
                        createIcingOverlay(); // Recreate with current zoom level
                        icingLayer.addTo(map);
                    } else {
                        map.removeLayer(icingLayer);
                    }
                    break;

                case 'turbulence':
                    if (overlayState.turbulence) {
                        createTurbulenceOverlay(); // Recreate with current zoom level
                        turbulenceLayer.addTo(map);
                    } else {
                        map.removeLayer(turbulenceLayer);
                    }
                    break;

                case 'winds':
                    if (overlayState.winds) {
                        // Auto-load METAR if not loaded
                        if (!stationsMetarLoaded && !stationsLoading) {
                            stationsLoading = true;
                            Promise.all([fetchOurAirports(), fetchFAAairports()]).then(() => {
                                stationsDataLoaded = true;
                                loadMetarStations().then(() => {
                                    stationsMetarLoaded = true;
                                    stationsLoading = false;
                                    if (overlayState.winds) {
                                        createWindsOverlay();
                                        windsLayer.addTo(map);
                                    }
                                });
                            });
                        } else if (stationsMetarLoaded) {
                            createWindsOverlay();
                            windsLayer.addTo(map);
                        }
                    } else {
                        map.removeLayer(windsLayer);
                    }
                    break;

                case 'temperature':
                    if (overlayState.temperature) {
                        // Auto-load METAR if not loaded
                        if (!stationsMetarLoaded && !stationsLoading) {
                            stationsLoading = true;
                            Promise.all([fetchOurAirports(), fetchFAAairports()]).then(() => {
                                stationsDataLoaded = true;
                                loadMetarStations().then(() => {
                                    stationsMetarLoaded = true;
                                    stationsLoading = false;
                                    if (overlayState.temperature) {
                                        createTemperatureOverlay();
                                        temperatureLayer.addTo(map);
                                    }
                                });
                            });
                        } else if (stationsMetarLoaded) {
                            createTemperatureOverlay();
                            temperatureLayer.addTo(map);
                        }
                    } else {
                        map.removeLayer(temperatureLayer);
                    }
                    break;

                case 'dewpoint':
                    if (overlayState.dewpoint) {
                        // Auto-load METAR if not loaded
                        if (!stationsMetarLoaded && !stationsLoading) {
                            stationsLoading = true;
                            Promise.all([fetchOurAirports(), fetchFAAairports()]).then(() => {
                                stationsDataLoaded = true;
                                loadMetarStations().then(() => {
                                    stationsMetarLoaded = true;
                                    stationsLoading = false;
                                    if (overlayState.dewpoint) {
                                        createDewpointOverlay();
                                        dewpointLayer.addTo(map);
                                    }
                                });
                            });
                        } else if (stationsMetarLoaded) {
                            createDewpointOverlay();
                            dewpointLayer.addTo(map);
                        }
                    } else {
                        map.removeLayer(dewpointLayer);
                    }
                    break;

                case 'radar':
                    if (overlayState.radar && radarLayer) {
                        radarLayer.addTo(map);
                    } else if (radarLayer) {
                        map.removeLayer(radarLayer);
                    }
                    break;

                case 'stations':
                    if (overlayState.stations) {
                        // Load airport data on first enable (deferred for faster page load)
                        if (!stationsDataLoaded && !stationsLoading) {
                            stationsLoading = true;
                            showLoading(0);
                            // Fetch airport databases in PARALLEL for faster loading
                            Promise.all([fetchOurAirports(), fetchFAAairports()]).then(() => {
                                stationsDataLoaded = true;
                                updateLoading(50);
                                // Only load METAR if still enabled
                                if (overlayState.stations) {
                                    loadMetarStations().then(() => {
                                        stationsMetarLoaded = true;
                                        stationsLoading = false;
                                        hideLoading();
                                    });
                                } else {
                                    stationsLoading = false;
                                    hideLoading();
                                }
                            });
                        } else if (stationsMetarLoaded) {
                            // METAR already loaded, just show the layer
                            metarMarkers.addTo(map);
                        }
                        // If stationsLoading is true, do nothing - loading will add layer when done
                    } else {
                        map.removeLayer(metarMarkers);
                    }
                    break;

                case 'traffic':
                    if (overlayState.traffic) {
                        loadTrafficData();
                        trafficLayer.addTo(map);
                        // Start auto-refresh
                        trafficRefreshTimer = setInterval(loadTrafficData, TRAFFIC_REFRESH_INTERVAL);
                    } else {
                        map.removeLayer(trafficLayer);
                        // Stop auto-refresh
                        if (trafficRefreshTimer) {
                            clearInterval(trafficRefreshTimer);
                            trafficRefreshTimer = null;
                        }
                    }
                    break;

                case 'airways':
                    if (overlayState.airways) {
                        // Lazy load airways data
                        if (!airwaysLoaded) {
                            await fetchAirways();
                        }
                        createAirwaysOverlay();
                    } else {
                        if (airwaysLayer) {
                            map.removeLayer(airwaysLayer);
                        }
                    }
                    break;

                case 'runways':
                    if (overlayState.runways) {
                        // Lazy load runway data
                        if (!runwaysLoaded) {
                            await fetchRunways();
                        }
                        createRunwayOverlay();
                    } else {
                        if (runwaysLayer) {
                            map.removeLayer(runwaysLayer);
                        }
                    }
                    break;
            }

            // Redraw profile if route is loaded
            if (currentRoute.dep && currentRoute.dest) {
                drawProfile(currentRoute.dep, currentRoute.dest);
            }
        }

        // Create airways overlay on map
        function createAirwaysOverlay() {
            if (airwaysLayer) {
                map.removeLayer(airwaysLayer);
            }
            airwaysLayer = L.layerGroup();

            const bounds = map.getBounds();
            const zoom = map.getZoom();

            // Only show at zoom >= 4 for performance (airways cover large areas)
            if (zoom < 4) {
                airwaysLayer.addTo(map);
                return;
            }

            // Filter airways in view and render
            let renderedCount = 0;
            const maxRender = zoom < 6 ? 300 : zoom < 8 ? 800 : 2000; // Limit based on zoom

            for (const airway of airwaysData) {
                if (renderedCount >= maxRender) break;

                // Check if any part of the airway is in view
                const coords = airway.coordinates;
                if (!coords || coords.length === 0) continue;

                // For LineString, check if line intersects bounds
                let inView = false;
                for (const coord of coords) {
                    const lon = coord[0];
                    const lat = coord[1];
                    if (bounds.contains([lat, lon])) {
                        inView = true;
                        break;
                    }
                }

                if (!inView) continue;

                // Convert coordinates to Leaflet format [lat, lon]
                const latLngs = coords.map(c => [c[1], c[0]]);

                // Determine airway type and color by identifier prefix
                let color = '#06b6d4'; // Cyan for Victor airways
                let dashArray = null;
                const ident = airway.ident || '';

                if (ident.startsWith('J')) {
                    color = '#f59e0b'; // Amber for Jet routes
                } else if (ident.startsWith('T')) {
                    color = '#10b981'; // Emerald for T-routes
                } else if (ident.startsWith('Q')) {
                    color = '#8b5cf6'; // Purple for Q-routes
                }

                const line = L.polyline(latLngs, {
                    color: color,
                    weight: zoom >= 10 ? 3 : 2,
                    opacity: 0.7,
                    dashArray: dashArray
                });

                // Add popup with airway info
                const lowAlt = airway.usLow || airway.akLow || '--';
                const highAlt = airway.usHigh || airway.akHigh || '--';
                const airwayType = ident.startsWith('J') ? 'Jet Route' :
                                   ident.startsWith('V') ? 'Victor Airway' :
                                   ident.startsWith('T') ? 'T-Route (RNAV)' :
                                   ident.startsWith('Q') ? 'Q-Route (RNAV)' : 'Airway';

                line.bindPopup(`
                    <div style="font-family: system-ui; min-width: 150px;">
                        <div style="font-weight: 700; color: ${color}; font-size: 18px; margin-bottom: 6px;">${ident || 'Unknown'}</div>
                        <div style="font-size: 13px; color: rgba(255,255,255,0.7); margin-bottom: 8px;">${airwayType}</div>
                        <div style="font-size: 14px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: rgba(255,255,255,0.6);">MEA</span>
                                <span style="font-weight: 500;">${lowAlt} - ${highAlt}</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 11px; color: rgba(255,255,255,0.4); text-align: center;">
                            Tap to pin
                        </div>
                    </div>
                `, { closeButton: true, className: 'airway-popup' });

                // Add click handler for tap-to-pin
                line.on('click', function(e) {
                    const popup = this.getPopup();
                    if (popup && popup._container) {
                        popup._container.classList.toggle('pinned');
                    }
                });

                airwaysLayer.addLayer(line);
                renderedCount++;
            }

            airwaysLayer.addTo(map);
            console.log(`Rendered ${renderedCount} airways in view`);
        }

        // Update airways overlay on map move/zoom
        map.on('moveend zoomend', () => {
            if (overlayState.airways && airwaysLoaded) {
                createAirwaysOverlay();
            }
            if (overlayState.runways && runwaysLoaded) {
                createRunwayOverlay();
            }
        });

        // Create runway overlay showing runway orientations
        function createRunwayOverlay() {
            if (runwaysLayer) {
                map.removeLayer(runwaysLayer);
            }
            runwaysLayer = L.layerGroup();

            const bounds = map.getBounds();
            const zoom = map.getZoom();

            // Only show at zoom >= 10 for performance (runways are small)
            if (zoom < 10) {
                runwaysLayer.addTo(map);
                return;
            }

            let renderedCount = 0;
            const maxRender = 500; // Limit runway rendering

            // Iterate over all airports with runways
            for (const [icao, runways] of Object.entries(runwayData)) {
                if (renderedCount >= maxRender) break;

                for (const rwy of runways) {
                    // Check if runway is in view
                    if (!rwy.leLat || !rwy.leLon || !rwy.heLat || !rwy.heLon) continue;

                    const centerLat = (rwy.leLat + rwy.heLat) / 2;
                    const centerLon = (rwy.leLon + rwy.heLon) / 2;

                    if (!bounds.contains([centerLat, centerLon])) continue;

                    // Determine runway color by surface type
                    let color = '#a855f7'; // Default purple
                    let weight = 4;
                    const surface = (rwy.surface || '').toUpperCase();

                    if (surface.includes('ASP') || surface.includes('CON') || surface.includes('PEM')) {
                        color = '#a855f7'; // Purple for paved (asphalt/concrete)
                        weight = zoom >= 14 ? 6 : 4;
                    } else if (surface.includes('GRS') || surface.includes('TURF')) {
                        color = '#22c55e'; // Green for grass
                        weight = zoom >= 14 ? 5 : 3;
                    } else if (surface.includes('GVL') || surface.includes('DIRT')) {
                        color = '#d97706'; // Amber for gravel/dirt
                        weight = zoom >= 14 ? 5 : 3;
                    } else if (surface.includes('WATER')) {
                        color = '#3b82f6'; // Blue for water (seaplane)
                        weight = zoom >= 14 ? 5 : 3;
                    }

                    // Draw runway line
                    const line = L.polyline(
                        [[rwy.leLat, rwy.leLon], [rwy.heLat, rwy.heLon]],
                        {
                            color: color,
                            weight: weight,
                            opacity: 0.9,
                            lineCap: 'butt'
                        }
                    );

                    // Create popup with runway info
                    const lengthFt = rwy.length || '--';
                    const widthFt = rwy.width || '--';
                    const surfaceType = rwy.surface || 'Unknown';
                    const lighting = rwy.lighted ? 'Yes' : 'No';
                    const rwyName = `${rwy.leIdent}/${rwy.heIdent}`;

                    line.bindPopup(`
                        <div style="font-family: system-ui; min-width: 160px;">
                            <div style="font-weight: 700; color: ${color}; font-size: 18px; margin-bottom: 4px;">${icao}</div>
                            <div style="font-size: 15px; font-weight: 600; margin-bottom: 8px;">Runway ${rwyName}</div>
                            <div style="font-size: 13px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span style="color: rgba(255,255,255,0.6);">Length</span>
                                    <span style="font-weight: 500;">${lengthFt.toLocaleString()} ft</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span style="color: rgba(255,255,255,0.6);">Width</span>
                                    <span style="font-weight: 500;">${widthFt} ft</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span style="color: rgba(255,255,255,0.6);">Surface</span>
                                    <span style="font-weight: 500;">${surfaceType}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span style="color: rgba(255,255,255,0.6);">Lighted</span>
                                    <span style="font-weight: 500;">${lighting}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.6);">Heading</span>
                                    <span style="font-weight: 500;">${Math.round(rwy.leHeading)} / ${Math.round(rwy.heHeading)}</span>
                                </div>
                            </div>
                            <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 11px; color: rgba(255,255,255,0.4); text-align: center;">
                                Tap to pin
                            </div>
                        </div>
                    `, { closeButton: true, className: 'runway-popup' });

                    // Add click handler for tap-to-pin
                    line.on('click', function(e) {
                        const popup = this.getPopup();
                        if (popup && popup._container) {
                            popup._container.classList.toggle('pinned');
                        }
                    });

                    runwaysLayer.addLayer(line);
                    renderedCount++;
                }
            }

            runwaysLayer.addTo(map);
            console.log(`Rendered ${renderedCount} runways in view`);
        }

        async function loadMetarStations() {
            metarMarkers.clearLayers();

            // Add layer to map first so stations appear as they load
            if (overlayState.stations) {
                metarMarkers.addTo(map);
            }

            // Show loading bar
            const loadingBar = document.getElementById('overlayLoadingBar');
            const barFill = loadingBar.querySelector('.bar-fill');
            const loadingLabel = document.getElementById('loadingLabel');
            const totalStations = metarStations.length;

            loadingBar.classList.add('active');
            loadingLabel.textContent = `Loading METAR data...`;
            barFill.style.width = '10%';

            // Use BULK API for MUCH faster loading (single request instead of 400+)
            // Only request METAR for ICAO stations (K*, P*) - others don't have METAR
            try {
                const icaoStations = metarStations.filter(s =>
                    s.id.startsWith('K') || s.id.startsWith('P') ||
                    (s.id.length === 4 && /^[A-Z]{4}$/.test(s.id))
                );
                const stationIds = icaoStations.map(s => s.id);
                console.log(`Requesting METAR for ${stationIds.length} ICAO stations`);

                const response = await fetch('/api/aviation/metar/bulk', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(stationIds)
                });

                barFill.style.width = '60%';
                loadingLabel.textContent = `Processing stations...`;

                if (response.ok) {
                    const bulkData = await response.json();
                    barFill.style.width = '80%';

                    // Create markers for all stations with data
                    let loadedCount = 0;
                    metarStations.forEach(station => {
                        const data = bulkData[station.id];
                        if (data) {
                            metarData[station.id] = data;

                            const flightRules = data.flight_rules || 'VFR';
                            const color = flightRulesColors[flightRules] || '#22c55e';

                            const marker = L.circleMarker([station.lat, station.lon], {
                                radius: 8,
                                fillColor: color,
                                color: '#ffffff',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.8
                            });

                            marker.on('click', (e) => {
                                if (waypointMode) return;
                                L.DomEvent.stopPropagation(e);
                                showStationInfo(station.id, data);
                            });
                            marker.bindTooltip(station.id, {
                                permanent: false,
                                direction: 'top',
                                className: 'station-tooltip'
                            });

                            metarMarkers.addLayer(marker);
                            loadedCount++;
                        }
                    });

                    barFill.style.width = '100%';
                    loadingLabel.textContent = `Loaded ${loadedCount} stations`;
                    console.log(`Bulk METAR: Loaded ${loadedCount}/${totalStations} stations`);
                }
            } catch (error) {
                console.error('Bulk METAR fetch failed:', error);
                loadingLabel.textContent = 'Error loading stations';
            }

            // Hide loading bar after completion
            setTimeout(() => {
                loadingBar.classList.remove('active');
                barFill.style.width = '0%';
            }, 500);

            // Update conditions and winds overlays with new METAR data
            if (overlayState.conditions) {
                createConditionsOverlay();
                if (!map.hasLayer(conditionsLayer)) {
                    conditionsLayer.addTo(map);
                }
            }

            if (overlayState.winds) {
                createWindsOverlay();
                if (!map.hasLayer(windsLayer)) {
                    windsLayer.addTo(map);
                }
            }

            if (overlayState.temperature) {
                createTemperatureOverlay();
                if (!map.hasLayer(temperatureLayer)) {
                    temperatureLayer.addTo(map);
                }
            }

            if (overlayState.dewpoint) {
                createDewpointOverlay();
                if (!map.hasLayer(dewpointLayer)) {
                    dewpointLayer.addTo(map);
                }
            }
        }

        // Show station info panel
        function showStationInfo(stationId, data) {
            const panel = document.getElementById('stationInfo');
            const station = findAirportStation(stationId);

            document.getElementById('stationName').textContent = `${stationId} - ${station?.name || ''}`;

            const flightRules = data.flight_rules || 'VFR';
            const frElement = document.getElementById('stationFlightRules');
            frElement.textContent = flightRules;
            frElement.className = `flight-rules ${flightRules.toLowerCase()}`;

            document.getElementById('stationMetar').textContent = data.raw_text || 'No METAR available';

            // Wind
            const windDir = data.wind_direction !== null ? `${data.wind_direction}` : '--';
            const windSpd = data.wind_speed !== null ? `${data.wind_speed}kt` : '--';
            const windGust = data.wind_gust ? `G${data.wind_gust}` : '';
            document.getElementById('stationWind').textContent = `${windDir} ${windSpd}${windGust}`;

            // Visibility
            document.getElementById('stationVis').textContent =
                data.visibility !== null ? `${data.visibility} SM` : '--';

            // Ceiling
            document.getElementById('stationCeiling').textContent =
                data.ceiling !== null ? `${data.ceiling} ft` : 'CLR';

            // Altimeter
            document.getElementById('stationAltimeter').textContent =
                data.altimeter !== null ? `${data.altimeter.toFixed(2)}"` : '--';

            panel.classList.add('visible');
        }

        function closeStationInfo() {
            document.getElementById('stationInfo').classList.remove('visible');
        }

        // Close station info when clicking on map (but not on markers)
        map.on('click', function(e) {
            // Don't close if in waypoint mode (that has its own handler)
            if (!waypointMode) {
                closeStationInfo();
            }
        });

        // Trip Summary Panel Functions
        function toggleTripSummary() {
            const panel = document.getElementById('tripSummary');
            panel.classList.toggle('expanded');
            updateFloatingProgress();
        }

        function showTripSummary() {
            const panel = document.getElementById('tripSummary');
            panel.classList.add('visible');
            // Keep minimized on route load - floating progress shows time
            updateFloatingProgress();
        }

        function hideTripSummary() {
            const panel = document.getElementById('tripSummary');
            panel.classList.remove('visible');
            panel.classList.remove('expanded');
            // Hide floating elements when panel hidden
            document.getElementById('tripProgressFloat').classList.remove('visible');
            document.getElementById('autopilotFloat').classList.remove('visible');
        }

        // Update floating progress bar visibility and content
        function updateFloatingProgress() {
            const panel = document.getElementById('tripSummary');
            const floatProgress = document.getElementById('tripProgressFloat');
            const floatAutopilot = document.getElementById('autopilotFloat');
            const isMinimized = panel.classList.contains('visible') && !panel.classList.contains('expanded');

            if (isMinimized) {
                floatProgress.classList.add('visible');
                floatAutopilot.classList.add('visible');
            } else {
                floatProgress.classList.remove('visible');
                floatAutopilot.classList.remove('visible');
            }
        }

        // Set floating progress bar values
        function setTripProgress(timeText, progressPercent) {
            document.getElementById('tripFloatTime').textContent = timeText;
            document.getElementById('tripProgressBar').style.width = progressPercent + '%';
        }

        // Toggle profile canvas minimize/maximize
        function toggleProfileCanvas() {
            const profileSection = document.getElementById('profileSection');
            const profileContent = document.getElementById('profileContent');
            const toggleBtn = document.getElementById('profileToggleBtn');
            const expandBtn = document.getElementById('profileExpandBtn');

            if (profileView.minimized) {
                // Maximize - show profile content area and redraw
                profileView.minimized = false;
                profileSection.classList.remove('minimized');
                profileContent.style.display = 'flex';
                if (toggleBtn) {
                    toggleBtn.classList.remove('minimized');
                    toggleBtn.title = 'Minimize Profile';
                }
                if (expandBtn) {
                    expandBtn.classList.add('expanded');
                    expandBtn.title = 'Minimize Profile';
                    expandBtn.querySelector('.expand-label').textContent = 'Hide';
                }
                // Redraw profile with current route
                if (currentRoute.dep && currentRoute.dest) {
                    drawProfile(currentRoute.dep, currentRoute.dest);
                }
                // Invalidate map size after layout change
                setTimeout(() => map.invalidateSize(), 350);
            } else {
                // Minimize - hide profile content area completely
                profileView.minimized = true;
                profileSection.classList.add('minimized');
                profileContent.style.display = 'none';
                if (toggleBtn) {
                    toggleBtn.classList.add('minimized');
                    toggleBtn.title = 'Maximize Profile';
                }
                if (expandBtn) {
                    expandBtn.classList.remove('expanded');
                    expandBtn.title = 'Expand Profile';
                    expandBtn.querySelector('.expand-label').textContent = 'Profile';
                }
                // Invalidate map size after layout change
                setTimeout(() => map.invalidateSize(), 350);
            }
        }

        // Calculate avoidance waypoints around a restricted polygon
        function calculateAvoidanceWaypoints(entryLat, entryLon, exitLat, exitLon, polygon, zoneName, depStation, destStation) {
            if (!polygon || polygon.length < 3) return [];

            // Calculate polygon centroid
            let centroidLat = 0, centroidLon = 0;
            polygon.forEach(p => {
                centroidLat += p[0];
                centroidLon += p[1];
            });
            centroidLat /= polygon.length;
            centroidLon /= polygon.length;

            // Use MAIN ROUTE direction (dep to dest) for consistent perpendicular
            const mainRouteDirLat = destStation.lat - depStation.lat;
            const mainRouteDirLon = destStation.lon - depStation.lon;
            const mainRouteLen = Math.sqrt(mainRouteDirLat * mainRouteDirLat + mainRouteDirLon * mainRouteDirLon);

            if (mainRouteLen < 0.0001) return [];

            // Normalize main route direction
            const normRouteLat = mainRouteDirLat / mainRouteLen;
            const normRouteLon = mainRouteDirLon / mainRouteLen;

            // Calculate perpendicular vector (rotated 90 degrees from main route)
            const perpLat = -normRouteLon;
            const perpLon = normRouteLat;

            // Determine which side of the route the centroid is on
            const toCentroidLat = centroidLat - depStation.lat;
            const toCentroidLon = centroidLon - depStation.lon;
            const dot = toCentroidLat * perpLat + toCentroidLon * perpLon;

            // Calculate polygon bounding box for offset distance
            let minLat = Infinity, maxLat = -Infinity;
            let minLon = Infinity, maxLon = -Infinity;
            polygon.forEach(p => {
                minLat = Math.min(minLat, p[0]);
                maxLat = Math.max(maxLat, p[0]);
                minLon = Math.min(minLon, p[1]);
                maxLon = Math.max(maxLon, p[1]);
            });

            const polyWidth = Math.abs(maxLon - minLon);
            const polyHeight = Math.abs(maxLat - minLat);

            // Perpendicular offset: enough to clear the zone plus buffer
            // Use larger offset for big zones to ensure we actually clear them
            const zoneSize = Math.max(polyWidth, polyHeight);
            const perpOffset = zoneSize * 1.2 + 0.3; // Increased from 0.7 to 1.2

            // Along-route offset: move waypoints before/after the zone
            const alongOffset = Math.max(polyWidth, polyHeight) * 0.3 + 0.1;

            // Go around on the opposite side of the centroid
            const offsetDir = dot > 0 ? -1 : 1;

            // Create waypoints that form a detour AROUND the zone
            // WP1: Before the zone entry, offset to the side
            const wp1Lat = entryLat - normRouteLat * alongOffset + perpLat * perpOffset * offsetDir;
            const wp1Lon = entryLon - normRouteLon * alongOffset + perpLon * perpOffset * offsetDir;

            // WP2: At the zone center (along route), maximum perpendicular offset
            const midLat = (entryLat + exitLat) / 2;
            const midLon = (entryLon + exitLon) / 2;
            const wpMidLat = midLat + perpLat * perpOffset * offsetDir * 1.3;
            const wpMidLon = midLon + perpLon * perpOffset * offsetDir * 1.3;

            // WP3: After the zone exit, offset to the side
            const wp3Lat = exitLat + normRouteLat * alongOffset + perpLat * perpOffset * offsetDir;
            const wp3Lon = exitLon + normRouteLon * alongOffset + perpLon * perpOffset * offsetDir;

            return [
                { lat: wp1Lat, lon: wp1Lon, name: `DVT-${zoneName.substring(0, 3)}1` },
                { lat: wpMidLat, lon: wpMidLon, name: `DVT-${zoneName.substring(0, 3)}2` },
                { lat: wp3Lat, lon: wp3Lon, name: `DVT-${zoneName.substring(0, 3)}3` }
            ];
        }

        // Wrapper to calculate avoidance waypoints for a zone intersection
        function calculateZoneAvoidanceWaypoints(depStation, destStation, zone, intersection) {
            // Calculate entry and exit points on the direct route
            const entryLat = depStation.lat + intersection.entryT * (destStation.lat - depStation.lat);
            const entryLon = depStation.lon + intersection.entryT * (destStation.lon - depStation.lon);
            const exitLat = depStation.lat + intersection.exitT * (destStation.lat - depStation.lat);
            const exitLon = depStation.lon + intersection.exitT * (destStation.lon - depStation.lon);

            // Get avoidance waypoints using the core function
            const rawWaypoints = calculateAvoidanceWaypoints(
                entryLat, entryLon,
                exitLat, exitLon,
                zone.polygon,
                zone.name,
                depStation,
                destStation
            );

            if (!rawWaypoints || rawWaypoints.length === 0) return [];

            // Filter out any invalid waypoints (NaN values)
            const validWaypoints = rawWaypoints.filter(wp =>
                !isNaN(wp.lat) && !isNaN(wp.lon) &&
                isFinite(wp.lat) && isFinite(wp.lon)
            );

            if (validWaypoints.length === 0) return [];

            // Verify the new waypoints actually avoid the zone
            const stillIntersects = validWaypoints.some(wp => pointInPolygon(wp.lat, wp.lon, zone.polygon));
            if (stillIntersects) return [];

            // Also verify route SEGMENTS between waypoints don't cross through ANY restricted zone
            // Build full route: dep -> wp1 -> wp2 -> wp3 -> dest
            const fullRoute = [
                { lat: depStation.lat, lon: depStation.lon },
                ...validWaypoints,
                { lat: destStation.lat, lon: destStation.lon }
            ];

            // Get all restricted zones with unlimited or high ceilings (ones we can't fly over)
            const allRestrictedZones = [
                ...(airspaceData.restricted || []).filter(z => (z.ceiling || 99999) >= 12500),
                ...(airspaceData.prohibited || [])
            ];

            // Check each segment against ALL restricted zones
            for (let i = 0; i < fullRoute.length - 1; i++) {
                const p1 = fullRoute[i];
                const p2 = fullRoute[i + 1];
                // Sample points along segment
                const numSamples = 15;
                for (let j = 1; j < numSamples; j++) {
                    const t = j / numSamples;
                    const sampleLat = p1.lat + t * (p2.lat - p1.lat);
                    const sampleLon = p1.lon + t * (p2.lon - p1.lon);

                    // Check against ALL high-ceiling restricted zones
                    for (const checkZone of allRestrictedZones) {
                        if (pointInPolygon(sampleLat, sampleLon, checkZone.polygon)) {
                            // Route crosses a restricted zone - avoidance failed
                            console.log(`Avoidance for ${zone.name} failed - segment ${i} crosses ${checkZone.name}`);
                            return [];
                        }
                    }
                }
            }

            // Convert to the format expected by the waypoint system
            return validWaypoints.map(wp => ({
                name: wp.name,
                type: 'divert',
                lat: wp.lat,
                lon: wp.lon,
                isCustom: false,
                isStop: false,
                isAvoidance: true,
                avoidingZone: zone.name
            }));
        }

        // Check if direct route intersects any restricted/prohibited airspace
        function findRestrictedIntersections(depStation, destStation, cruiseAltitude) {
            const intersections = [];
            const numPoints = 50;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const lat = depStation.lat + t * (destStation.lat - depStation.lat);
                const lon = depStation.lon + t * (destStation.lon - depStation.lon);

                // Calculate altitude at this point
                let altitude = cruiseAltitude;
                if (t < 0.15) altitude = (t / 0.15) * cruiseAltitude;
                else if (t > 0.85) altitude = ((1 - t) / 0.15) * cruiseAltitude;

                // Check restricted airspace
                airspaceData.restricted.forEach(zone => {
                    if (pointInPolygon(lat, lon, zone.polygon)) {
                        if (altitude >= (zone.floor || 0) && altitude <= zone.ceiling) {
                            const existing = intersections.find(x => x.zone.name === zone.name);
                            if (!existing) {
                                intersections.push({
                                    zone: zone,
                                    type: 'restricted',
                                    entryT: t,
                                    exitT: t,
                                    entryLat: lat,
                                    entryLon: lon,
                                    exitLat: lat,
                                    exitLon: lon
                                });
                            } else {
                                existing.exitT = t;
                                existing.exitLat = lat;
                                existing.exitLon = lon;
                            }
                        }
                    }
                });

                // Check prohibited airspace
                airspaceData.prohibited.forEach(zone => {
                    if (pointInPolygon(lat, lon, zone.polygon)) {
                        const existing = intersections.find(x => x.zone.name === zone.name);
                        if (!existing) {
                            intersections.push({
                                zone: zone,
                                type: 'prohibited',
                                entryT: t,
                                exitT: t,
                                entryLat: lat,
                                entryLon: lon,
                                exitLat: lat,
                                exitLon: lon
                            });
                        } else {
                            existing.exitT = t;
                            existing.exitLat = lat;
                            existing.exitLon = lon;
                        }
                    }
                });
            }

            return intersections;
        }

        // Find IFR/LIFR weather conditions along the route
        function findWeatherHazards(depStation, destStation) {
            const weatherHazards = [];
            const numPoints = 30;
            const weatherInfluenceRadius = 50; // NM - area affected by station's weather

            // Build list of stations with poor weather (IFR or LIFR)
            const poorWeatherStations = [];
            metarStations.forEach(station => {
                const data = metarData[station.id];
                if (data && (data.flight_rules === 'IFR' || data.flight_rules === 'LIFR')) {
                    poorWeatherStations.push({
                        id: station.id,
                        lat: station.lat,
                        lon: station.lon,
                        flightRules: data.flight_rules,
                        ceiling: data.ceiling,
                        visibility: data.visibility
                    });
                }
            });

            if (poorWeatherStations.length === 0) return weatherHazards;

            // Sample points along the route and check proximity to poor weather
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const lat = depStation.lat + t * (destStation.lat - depStation.lat);
                const lon = depStation.lon + t * (destStation.lon - depStation.lon);

                // Check each poor weather station
                poorWeatherStations.forEach(wxStation => {
                    const distToStation = haversineNM(lat, lon, wxStation.lat, wxStation.lon);

                    if (distToStation < weatherInfluenceRadius) {
                        // Route passes near this poor weather area
                        const existing = weatherHazards.find(h => h.station.id === wxStation.id);
                        if (!existing) {
                            weatherHazards.push({
                                station: wxStation,
                                type: 'weather',
                                severity: wxStation.flightRules === 'LIFR' ? 'critical' : 'warning',
                                entryT: t,
                                exitT: t,
                                entryLat: lat,
                                entryLon: lon,
                                exitLat: lat,
                                exitLon: lon,
                                influenceRadius: weatherInfluenceRadius
                            });
                        } else {
                            existing.exitT = t;
                            existing.exitLat = lat;
                            existing.exitLon = lon;
                        }
                    }
                });
            }

            return weatherHazards;
        }

        // Calculate waypoints to avoid weather hazard area
        function calculateWeatherAvoidanceWaypoints(depStation, destStation, weatherHazard) {
            const station = weatherHazard.station;
            const avoidRadius = weatherHazard.influenceRadius + 10; // Add buffer

            // Calculate perpendicular offset direction
            const routeBearing = Math.atan2(
                destStation.lon - depStation.lon,
                destStation.lat - depStation.lat
            ) * 180 / Math.PI;

            // Try both sides (perpendicular to route) and pick the shorter diversion
            const perpBearing1 = (routeBearing + 90) % 360;
            const perpBearing2 = (routeBearing - 90 + 360) % 360;

            // Calculate avoidance points on each side
            const avoidPoint1 = destinationPoint(station.lat, station.lon, perpBearing1, avoidRadius);
            const avoidPoint2 = destinationPoint(station.lat, station.lon, perpBearing2, avoidRadius);

            // Calculate total route distance through each avoidance point
            const dist1 = haversineNM(depStation.lat, depStation.lon, avoidPoint1.lat, avoidPoint1.lon) +
                         haversineNM(avoidPoint1.lat, avoidPoint1.lon, destStation.lat, destStation.lon);
            const dist2 = haversineNM(depStation.lat, depStation.lon, avoidPoint2.lat, avoidPoint2.lon) +
                         haversineNM(avoidPoint2.lat, avoidPoint2.lon, destStation.lat, destStation.lon);

            // Choose the shorter diversion
            const avoidPoint = dist1 < dist2 ? avoidPoint1 : avoidPoint2;
            const direction = dist1 < dist2 ? 'E' : 'W';

            return [{
                lat: avoidPoint.lat,
                lon: avoidPoint.lon,
                name: `WX-${direction}`,
                type: 'weather-avoidance',
                avoidingStation: station.id,
                reason: `Avoiding ${station.flightRules} at ${station.id}`
            }];
        }

        // Calculate comprehensive route with hazard avoidance
        function calculateEnhancedRoute(depStation, destStation, distance, customWaypointsInput = [], stopsInput = []) {
            const routeData = {
                departure: depStation,
                destination: destStation,
                distance: distance,
                waypoints: [],
                customWaypoints: customWaypointsInput, // Store custom waypoints
                stops: stopsInput, // Store stops (landings along route)
                airways: [], // Airways along the route
                departureRunway: null, // Optimal runway for departure
                destinationRunway: null, // Optimal runway for arrival
                phases: [],
                hazards: [],
                avoidanceManeuvers: [],
                fuelPlan: {},
                cruiseAltitude: 8000, // Will be calculated based on distance
                estimatedTime: 0
            };

            // Calculate optimal cruise altitude based on distance (capped at 12,500 ft for VFR)
            // Rule of thumb: ~1000ft per 10nm for efficient cruise, but no higher than 12,500
            const optimalAltitude = Math.min(12500, Math.max(5500, Math.round(distance * 8 / 100) * 1000));
            routeData.cruiseAltitude = optimalAltitude;

            // Aircraft performance assumptions (typical GA piston)
            const cruiseSpeed = 140; // knots (typical for piston single)
            const climbRate = 800; // ft/min
            const descentRate = 500; // ft/min
            const fuelBurnClimb = 14; // gal/hr
            const fuelBurnCruise = 10; // gal/hr
            const fuelBurnDescent = 6; // gal/hr
            const fuelReserve = 45; // minutes reserve
            const tankCapacity = 92; // gallons (user's aircraft)

            // Calculate phases
            const climbDistance = Math.min(distance * 0.15, 50); // ~15% or max 50nm for climb
            const descentDistance = Math.min(distance * 0.12, 40); // ~12% or max 40nm for descent
            const cruiseDistance = distance - climbDistance - descentDistance;

            // Time calculations
            const climbTime = (routeData.cruiseAltitude / climbRate) / 60; // hours
            const cruiseTime = cruiseDistance / cruiseSpeed; // hours
            const descentTime = (routeData.cruiseAltitude / descentRate) / 60; // hours
            routeData.estimatedTime = climbTime + cruiseTime + descentTime;

            // Fuel calculations
            const climbFuel = climbTime * fuelBurnClimb;
            const cruiseFuel = cruiseTime * fuelBurnCruise;
            const descentFuel = descentTime * fuelBurnDescent;
            const reserveFuel = (fuelReserve / 60) * fuelBurnCruise;
            const totalFuel = climbFuel + cruiseFuel + descentFuel + reserveFuel;

            // Calculate usable fuel (tank minus reserve)
            const usableFuel = tankCapacity - reserveFuel;

            // Calculate max range per leg based on cruise fuel burn (capped at 700nm)
            const maxLegRange = Math.min(700, (usableFuel / fuelBurnCruise) * cruiseSpeed);

            // Determine if fuel stops are needed
            const fuelStopRequired = totalFuel > tankCapacity;
            const numFuelStops = fuelStopRequired ? Math.ceil(distance / maxLegRange) - 1 : 0;

            // Find fuel stop airports if needed
            const fuelStops = numFuelStops > 0
                ? findFuelStops(depStation, destStation, maxLegRange, numFuelStops)
                : [];

            // Recalculate total distance including fuel stops
            let totalRouteDistance = 0;
            let prevPoint = { lat: depStation.lat, lon: depStation.lon };
            for (const stop of fuelStops) {
                totalRouteDistance += haversineNM(prevPoint.lat, prevPoint.lon, stop.station.lat, stop.station.lon);
                prevPoint = { lat: stop.station.lat, lon: stop.station.lon };
            }
            totalRouteDistance += haversineNM(prevPoint.lat, prevPoint.lon, destStation.lat, destStation.lon);

            // Recalculate fuel if route has changed
            const actualRouteDistance = fuelStops.length > 0 ? totalRouteDistance : distance;
            const actualCruiseDistance = actualRouteDistance - climbDistance - descentDistance;
            const actualCruiseTime = actualCruiseDistance / cruiseSpeed;
            const actualCruiseFuel = actualCruiseTime * fuelBurnCruise;
            const actualTotalFuel = climbFuel + actualCruiseFuel + descentFuel + reserveFuel;

            // Calculate fuel per leg
            const legs = [];
            let legStart = depStation;
            for (let i = 0; i <= fuelStops.length; i++) {
                const legEnd = i < fuelStops.length ? fuelStops[i].station : destStation;
                const legDist = haversineNM(legStart.lat, legStart.lon, legEnd.lat, legEnd.lon);
                const legTime = legDist / cruiseSpeed;
                const legFuel = legTime * fuelBurnCruise + (i === 0 ? climbFuel : 0) + (i === fuelStops.length ? descentFuel : 0);
                legs.push({
                    from: legStart.id,
                    to: legEnd.id,
                    distance: Math.round(legDist),
                    time: Math.round(legTime * 60),
                    fuel: Math.round(legFuel)
                });
                legStart = legEnd;
            }

            routeData.fuelPlan = {
                climb: Math.round(climbFuel),
                cruise: Math.round(actualCruiseFuel),
                descent: Math.round(descentFuel),
                reserve: Math.round(reserveFuel),
                total: Math.round(actualTotalFuel),
                tankCapacity: tankCapacity,
                usableFuel: Math.round(usableFuel),
                maxLegRange: Math.round(maxLegRange),
                fuelStopRequired: fuelStopRequired,
                numFuelStops: fuelStops.length,
                fuelStops: fuelStops,
                legs: legs,
                actualRouteDistance: Math.round(actualRouteDistance)
            };

            // Log fuel stops if any
            if (fuelStops.length > 0) {
                console.log(`Route requires ${fuelStops.length} fuel stop(s):`);
                fuelStops.forEach((stop, i) => {
                    console.log(`  Stop ${i + 1}: ${stop.station.id} (${stop.distanceFromDep}nm from dep, +${stop.deviation}nm deviation)`);
                });
            }

            // Add flight phases
            routeData.phases = [
                {
                    name: 'Climb',
                    type: 'climb',
                    startAlt: 0,
                    endAlt: routeData.cruiseAltitude,
                    distance: Math.round(climbDistance),
                    time: Math.round(climbTime * 60)
                },
                {
                    name: 'Cruise',
                    type: 'cruise',
                    startAlt: routeData.cruiseAltitude,
                    endAlt: routeData.cruiseAltitude,
                    distance: Math.round(cruiseDistance),
                    time: Math.round(cruiseTime * 60)
                },
                {
                    name: 'Descent',
                    type: 'descent',
                    startAlt: routeData.cruiseAltitude,
                    endAlt: 0,
                    distance: Math.round(descentDistance),
                    time: Math.round(descentTime * 60)
                }
            ];

            // Generate waypoints along route
            routeData.waypoints.push({
                name: depStation.id,
                type: 'departure',
                lat: depStation.lat,
                lon: depStation.lon,
                distance: 0
            });

            // Add departure procedure waypoints (SID-style)
            const departureProcedure = getDepartureWaypoints(depStation.id, destStation.lat, destStation.lon, depStation.lat, depStation.lon);
            const departureWaypoints = [];
            if (departureProcedure && departureProcedure.waypoints) {
                console.log(`Using departure procedure: ${departureProcedure.name} from ${depStation.id}`);
                routeData.departureProcedure = departureProcedure.name;
                let depCumulativeDist = 0;
                let lastDepPoint = { lat: depStation.lat, lon: depStation.lon };
                departureProcedure.waypoints.forEach((wp, idx) => {
                    const distFromLast = haversineNM(lastDepPoint.lat, lastDepPoint.lon, wp.lat, wp.lon);
                    depCumulativeDist += distFromLast;
                    departureWaypoints.push({
                        name: wp.name,
                        type: 'sid',
                        lat: wp.lat,
                        lon: wp.lon,
                        altitude: wp.alt,
                        distance: Math.round(depCumulativeDist),
                        description: wp.desc,
                        procedureName: departureProcedure.name,
                        isCustom: false,
                        isStop: false
                    });
                    lastDepPoint = { lat: wp.lat, lon: wp.lon };
                });
            }

            // Get arrival procedure waypoints (STAR-style) - we'll insert these later
            const arrivalProcedure = getArrivalWaypoints(destStation.id, depStation.lat, depStation.lon, destStation.lat, destStation.lon);
            const arrivalWaypoints = [];
            if (arrivalProcedure && arrivalProcedure.waypoints) {
                console.log(`Using arrival procedure: ${arrivalProcedure.name} to ${destStation.id}`);
                routeData.arrivalProcedure = arrivalProcedure.name;
                // Arrival waypoints will be processed after we know the route distance
                arrivalProcedure.waypoints.forEach((wp, idx) => {
                    arrivalWaypoints.push({
                        name: wp.name,
                        type: 'star',
                        lat: wp.lat,
                        lon: wp.lon,
                        altitude: wp.alt,
                        description: wp.desc,
                        procedureName: arrivalProcedure.name,
                        isCustom: false,
                        isStop: false
                    });
                });
            }

            // Find all restricted/prohibited airspace intersections first
            const restrictedIntersections = findRestrictedIntersections(depStation, destStation, routeData.cruiseAltitude);

            // Auto-calculate avoidance waypoints for restricted/prohibited zones
            // Aircraft max altitude is 12,500 ft - zones with higher ceilings MUST be avoided (can't fly over)
            const AIRCRAFT_MAX_ALT = 12500;
            const avoidanceWaypoints = [];
            const hazardsAdded = new Set();
            let totalAddedDistance = 0;
            const maxAddedDistancePercent = 40; // Don't add more than 40% to route

            // Sort intersections by entry point (earliest first)
            const sortedIntersections = [...restrictedIntersections].sort((a, b) => a.entryT - b.entryT);

            sortedIntersections.forEach(intersection => {
                const zone = intersection.zone;
                const zoneCeiling = zone.ceiling || 50000;
                const canFlyOver = zoneCeiling < AIRCRAFT_MAX_ALT; // Can we fly over this zone?

                // Skip zones we can fly over (ceiling below our cruise altitude)
                if (canFlyOver) {
                    return;
                }

                // Check if we've exceeded our distance budget
                const currentAddedPercent = (totalAddedDistance / distance) * 100;
                if (currentAddedPercent >= maxAddedDistancePercent) {
                    // Already added too much distance - just warn about this zone
                    if (!hazardsAdded.has(zone.name)) {
                        routeData.hazards.push({
                            type: intersection.type,
                            severity: 'critical',
                            name: zone.name,
                            description: `${intersection.type === 'prohibited' ? 'Prohibited' : 'Restricted'} airspace ${zone.name}`,
                            location: Math.round(intersection.entryT * distance),
                            action: 'Route limit reached - add waypoints manually'
                        });
                        hazardsAdded.add(zone.name);
                    }
                    return;
                }

                // Try to avoid this zone
                const avoidWps = calculateZoneAvoidanceWaypoints(depStation, destStation, zone, intersection);
                if (avoidWps && avoidWps.length > 0) {
                    // Calculate how much distance this avoidance adds
                    let avoidanceDistance = 0;
                    let prevLat = depStation.lat, prevLon = depStation.lon;
                    avoidWps.forEach(wp => {
                        avoidanceDistance += haversineNM(prevLat, prevLon, wp.lat, wp.lon);
                        prevLat = wp.lat;
                        prevLon = wp.lon;
                    });
                    avoidanceDistance += haversineNM(prevLat, prevLon, destStation.lat, destStation.lon);
                    const directDist = haversineNM(depStation.lat, depStation.lon, destStation.lat, destStation.lon);
                    const thisAddedDist = avoidanceDistance - directDist;

                    // Check if adding this avoidance would exceed our budget
                    if ((totalAddedDistance + thisAddedDist) / distance * 100 <= maxAddedDistancePercent) {
                        avoidanceWaypoints.push(...avoidWps);
                        totalAddedDistance += thisAddedDist;

                        // Add info-level hazard (zone being avoided)
                        if (!hazardsAdded.has(zone.name)) {
                            routeData.hazards.push({
                                type: intersection.type,
                                severity: 'caution',
                                name: zone.name,
                                description: `Route diverts around ${zone.name}`,
                                location: Math.round(intersection.entryT * distance),
                                action: 'Auto-avoidance active'
                            });
                            hazardsAdded.add(zone.name);

                            // Track avoidance maneuvers
                            routeData.avoidanceManeuvers.push({
                                zone: zone.name,
                                type: intersection.type,
                                waypoints: avoidWps.map(wp => wp.name)
                            });
                        }
                        return;
                    }
                }

                // Couldn't auto-avoid - warn pilot
                if (!hazardsAdded.has(zone.name)) {
                    routeData.hazards.push({
                        type: intersection.type,
                        severity: 'critical',
                        name: zone.name,
                        description: `${intersection.type === 'prohibited' ? 'Prohibited' : 'Restricted'} airspace ${zone.name}`,
                        location: Math.round(intersection.entryT * distance),
                        action: 'Use + Waypoints to route around'
                    });
                    hazardsAdded.add(zone.name);
                }
            });

            // If no avoidance waypoints were added but we have restricted zone intersections,
            // try to find a corridor route around the ENTIRE complex
            console.log('Restricted intersections found:', sortedIntersections.length, sortedIntersections.map(i => i.zone.name));
            if (avoidanceWaypoints.length === 0 && sortedIntersections.length > 0) {
                const unavoidableZones = sortedIntersections.filter(i => {
                    const zoneCeiling = i.zone.ceiling || 50000;
                    return zoneCeiling >= AIRCRAFT_MAX_ALT;
                });
                console.log('Unavoidable zones (ceiling >= 12500):', unavoidableZones.length, unavoidableZones.map(i => i.zone.name));

                if (unavoidableZones.length > 0) {
                    // Find bounding box of all unavoidable restricted zones
                    let minLat = Infinity, maxLat = -Infinity;
                    let minLon = Infinity, maxLon = -Infinity;
                    unavoidableZones.forEach(i => {
                        i.zone.polygon.forEach(p => {
                            minLat = Math.min(minLat, p[0]);
                            maxLat = Math.max(maxLat, p[0]);
                            minLon = Math.min(minLon, p[1]);
                            maxLon = Math.max(maxLon, p[1]);
                        });
                    });

                    // Get all restricted zones with high ceilings
                    const allRestrictedZones = [
                        ...(airspaceData.restricted || []).filter(z => (z.ceiling || 99999) >= AIRCRAFT_MAX_ALT),
                        ...(airspaceData.prohibited || [])
                    ];
                    console.log('Total high-ceiling restricted/prohibited zones for corridor check:', allRestrictedZones.length);
                    console.log('Unavoidable zones:', unavoidableZones.map(z => ({ name: z.zone.name, ceiling: z.zone.ceiling })));

                    // Helper function to check if a corridor route is clear
                    function isCorridorClear(waypoints, corridorName = 'unknown') {
                        const route = [
                            { lat: depStation.lat, lon: depStation.lon },
                            ...waypoints,
                            { lat: destStation.lat, lon: destStation.lon }
                        ];
                        for (let i = 0; i < route.length - 1; i++) {
                            const p1 = route[i];
                            const p2 = route[i + 1];
                            // Calculate segment length and use more samples for longer segments
                            const segLen = haversineNM(p1.lat, p1.lon, p2.lat, p2.lon);
                            const numSamples = Math.max(50, Math.ceil(segLen / 2)); // Sample every 2nm minimum
                            for (let j = 0; j <= numSamples; j++) {
                                const t = j / numSamples;
                                const sampleLat = p1.lat + t * (p2.lat - p1.lat);
                                const sampleLon = p1.lon + t * (p2.lon - p1.lon);
                                for (const zone of allRestrictedZones) {
                                    if (pointInPolygon(sampleLat, sampleLon, zone.polygon)) {
                                        console.log(`Corridor ${corridorName} BLOCKED by ${zone.name} at (${sampleLat.toFixed(3)}, ${sampleLon.toFixed(3)}) segment ${i}`);
                                        return false;
                                    }
                                }
                            }
                        }
                        return true;
                    }

                    // Helper function to calculate corridor distance
                    function getCorridorDistance(waypoints) {
                        let dist = 0;
                        let prev = depStation;
                        waypoints.forEach(wp => {
                            dist += haversineNM(prev.lat, prev.lon, wp.lat, wp.lon);
                            prev = wp;
                        });
                        dist += haversineNM(prev.lat, prev.lon, destStation.lat, destStation.lon);
                        return dist;
                    }

                    // Calculate corridor positions - use midpoint longitude for better routing
                    const midLon = (depStation.lon + destStation.lon) / 2;
                    const clampedMidLon = Math.max(minLon - 0.5, Math.min(maxLon + 0.5, midLon));
                    console.log('Bounding box:', { minLat, maxLat, minLon, maxLon });
                    console.log('Mid lon:', midLon, 'clamped:', clampedMidLon);

                    // Try multiple corridor strategies
                    const corridorOptions = [];

                    // Option 1: South corridor (single waypoint)
                    const southLat = minLat - 0.5;
                    const southWp = [{ lat: southLat, lon: clampedMidLon, name: 'COR-S' }];
                    const southClear = isCorridorClear(southWp, 'South');
                    console.log('South corridor at', southLat, clampedMidLon, '- clear:', southClear);
                    if (southClear) {
                        corridorOptions.push({ waypoints: southWp, direction: 'South' });
                    }

                    // Option 2: North corridor (single waypoint)
                    const northLat = maxLat + 0.5;
                    const northWp = [{ lat: northLat, lon: clampedMidLon, name: 'COR-N' }];
                    const northClear = isCorridorClear(northWp, 'North');
                    console.log('North corridor at', northLat, clampedMidLon, '- clear:', northClear);
                    if (northClear) {
                        corridorOptions.push({ waypoints: northWp, direction: 'North' });
                    }

                    // Option 3: South corridor with 2 waypoints (wider arc)
                    const south2Wp = [
                        { lat: southLat - 0.3, lon: minLon - 0.3, name: 'COR-S1' },
                        { lat: southLat - 0.3, lon: maxLon + 0.3, name: 'COR-S2' }
                    ];
                    const south2Clear = isCorridorClear(south2Wp, 'South-2WP');
                    console.log('South 2-waypoint corridor - clear:', south2Clear);
                    if (south2Clear) {
                        corridorOptions.push({ waypoints: south2Wp, direction: 'South' });
                    }

                    // Option 4: North corridor with 2 waypoints (wider arc)
                    const north2Wp = [
                        { lat: northLat + 0.3, lon: minLon - 0.3, name: 'COR-N1' },
                        { lat: northLat + 0.3, lon: maxLon + 0.3, name: 'COR-N2' }
                    ];
                    const north2Clear = isCorridorClear(north2Wp, 'North-2WP');
                    console.log('North 2-waypoint corridor - clear:', north2Clear);
                    if (north2Clear) {
                        corridorOptions.push({ waypoints: north2Wp, direction: 'North' });
                    }

                    // Option 5: West corridor (go around west side)
                    const westLon = minLon - 0.5;
                    const westWp = [{ lat: (minLat + maxLat) / 2, lon: westLon, name: 'COR-W' }];
                    const westClear = isCorridorClear(westWp, 'West');
                    console.log('West corridor at', (minLat + maxLat) / 2, westLon, '- clear:', westClear);
                    if (westClear) {
                        corridorOptions.push({ waypoints: westWp, direction: 'West' });
                    }

                    // Option 6: East corridor (go around east side)
                    const eastLon = maxLon + 0.5;
                    const eastWp = [{ lat: (minLat + maxLat) / 2, lon: eastLon, name: 'COR-E' }];
                    const eastClear = isCorridorClear(eastWp, 'East');
                    console.log('East corridor at', (minLat + maxLat) / 2, eastLon, '- clear:', eastClear);
                    if (eastClear) {
                        corridorOptions.push({ waypoints: eastWp, direction: 'East' });
                    }

                    // Option 7: Southeast corridor (south then east) - for LA to Utah type routes
                    const seWp = [
                        { lat: minLat - 0.8, lon: (minLon + depStation.lon) / 2, name: 'COR-SE1' },
                        { lat: minLat - 0.5, lon: maxLon + 0.8, name: 'COR-SE2' }
                    ];
                    const seClear = isCorridorClear(seWp, 'Southeast');
                    console.log('Southeast corridor - clear:', seClear);
                    if (seClear) {
                        corridorOptions.push({ waypoints: seWp, direction: 'Southeast' });
                    }

                    // Option 8: Northeast corridor (east then north) - alternative
                    const neWp = [
                        { lat: (depStation.lat + minLat) / 2, lon: maxLon + 0.8, name: 'COR-NE1' },
                        { lat: maxLat + 0.5, lon: maxLon + 0.5, name: 'COR-NE2' }
                    ];
                    const neClear = isCorridorClear(neWp, 'Northeast');
                    console.log('Northeast corridor - clear:', neClear);
                    if (neClear) {
                        corridorOptions.push({ waypoints: neWp, direction: 'Northeast' });
                    }

                    // Option 9: Far south corridor (well below all zones)
                    const farSouthLat = Math.min(minLat - 1.5, depStation.lat - 0.5);
                    const farSouthWp = [
                        { lat: farSouthLat, lon: (depStation.lon + minLon) / 2, name: 'COR-FS1' },
                        { lat: farSouthLat, lon: maxLon + 0.5, name: 'COR-FS2' }
                    ];
                    const farSouthClear = isCorridorClear(farSouthWp, 'FarSouth');
                    console.log('Far south corridor at', farSouthLat, '- clear:', farSouthClear);
                    if (farSouthClear) {
                        corridorOptions.push({ waypoints: farSouthWp, direction: 'Far South' });
                    }

                    // Option 10: Full arc corridor (south, east, then north above restricted)
                    // Use larger buffers to ensure complete clearance
                    const buffer = 2.0; // 2 degrees (~120nm) buffer for safety
                    const arcWp = [
                        { lat: minLat - buffer, lon: minLon, name: 'COR-A1' }, // South of complex
                        { lat: minLat - buffer, lon: maxLon + buffer, name: 'COR-A2' }, // Southeast of complex
                        { lat: maxLat + buffer, lon: maxLon + buffer, name: 'COR-A3' }  // Northeast of complex
                    ];
                    const arcClear = isCorridorClear(arcWp, 'Arc');
                    console.log('Full arc corridor - clear:', arcClear);
                    if (arcClear) {
                        corridorOptions.push({ waypoints: arcWp, direction: 'Arc' });
                    }

                    // Option 11: Wide east corridor - goes FAR east then north
                    // Best for LAX to SLC type routes
                    const wideEastLon = maxLon + 3.0; // 3 degrees east of restricted complex (~180nm)
                    const wideEastWp = [
                        { lat: minLat - 1.0, lon: wideEastLon, name: 'COR-WE1' }, // Southeast, well clear
                        { lat: maxLat + 1.0, lon: wideEastLon, name: 'COR-WE2' }  // Northeast, well clear
                    ];
                    const wideEastClear = isCorridorClear(wideEastWp, 'WideEast');
                    console.log('Wide east corridor at lon', wideEastLon, '- clear:', wideEastClear);
                    if (wideEastClear) {
                        corridorOptions.push({ waypoints: wideEastWp, direction: 'Wide East' });
                    }

                    // Option 12: Vegas corridor - specific for LA to Utah, goes around Vegas
                    // Goes south, then far east past ALL restricted (including AZ/UT), then north
                    const vegasWp = [
                        { lat: 33.0, lon: -116.5, name: 'COR-V1' }, // South of all CA restricted
                        { lat: 33.0, lon: -111.5, name: 'COR-V2' }, // Far east, past Phoenix
                        { lat: 38.0, lon: -111.5, name: 'COR-V3' }  // North, direct line to SLC
                    ];
                    const vegasClear = isCorridorClear(vegasWp, 'VegasBypass');
                    console.log('Vegas corridor - clear:', vegasClear);
                    if (vegasClear) {
                        corridorOptions.push({ waypoints: vegasWp, direction: 'Vegas Bypass' });
                    }

                    console.log('Clear corridor options:', corridorOptions.length);
                    console.log('All clear corridors:', corridorOptions.map(c => ({ dir: c.direction, wps: c.waypoints.map(w => w.name) })));

                    // For complex restricted areas (multiple zones), prefer 3-waypoint corridors
                    // as they provide better clearance than 2-waypoint corridors
                    const prefer3Waypoint = unavoidableZones.length >= 2;
                    console.log('prefer3Waypoint:', prefer3Waypoint, 'unavoidableZones count:', unavoidableZones.length);

                    // Find the best corridor - prefer Vegas/Arc for complex areas
                    let bestCorridor = null;
                    let bestDistance = Infinity;

                    // First pass: look for reliable 3-waypoint corridors
                    if (prefer3Waypoint) {
                        const reliable3wp = ['Vegas Bypass', 'Arc', 'Wide East'];
                        corridorOptions.filter(o => reliable3wp.includes(o.direction)).forEach(option => {
                            const dist = getCorridorDistance(option.waypoints);
                            const addedPercent = ((dist - distance) / distance) * 100;
                            console.log('3WP Corridor', option.direction, '- distance:', dist, 'added:', addedPercent.toFixed(1) + '%');
                            if (addedPercent <= 70 && dist < bestDistance) {
                                bestDistance = dist;
                                bestCorridor = option;
                            }
                        });
                    }

                    // Second pass: if no 3-waypoint found, try all corridors
                    if (!bestCorridor) {
                        corridorOptions.forEach(option => {
                            const dist = getCorridorDistance(option.waypoints);
                            const addedPercent = ((dist - distance) / distance) * 100;
                            console.log('Corridor', option.direction, '- distance:', dist, 'added:', addedPercent.toFixed(1) + '%');
                            if (addedPercent <= 60 && dist < bestDistance) {
                                bestDistance = dist;
                                bestCorridor = option;
                            }
                        });
                    }

                    if (bestCorridor) {
                        const addedPercent = ((bestDistance - distance) / distance) * 100;

                        // Add corridor waypoints
                        bestCorridor.waypoints.forEach(wp => {
                            avoidanceWaypoints.push({
                                name: wp.name,
                                type: 'divert',
                                lat: wp.lat,
                                lon: wp.lon,
                                isCustom: false,
                                isStop: false,
                                isAvoidance: true,
                                avoidingZone: 'Restricted Complex'
                            });
                        });

                        // Mark zones as avoided - ALWAYS add avoidance maneuvers for corridor
                        // First, remove any existing "couldn't avoid" hazards for these zones
                        // Then add the "corridor active" status
                        unavoidableZones.forEach(i => {
                            // Remove previous "critical" hazard if it exists (will be replaced with "caution")
                            const existingIdx = routeData.hazards.findIndex(h => h.name === i.zone.name && h.severity === 'critical');
                            if (existingIdx >= 0) {
                                routeData.hazards.splice(existingIdx, 1);
                            }

                            // Add corridor avoidance hazard (caution level since we're routing around it)
                            routeData.hazards.push({
                                type: i.type,
                                severity: 'caution',
                                name: i.zone.name,
                                description: `Route diverts around ${i.zone.name}`,
                                location: Math.round(i.entryT * distance),
                                action: `${bestCorridor.direction} corridor route active`
                            });

                            // ALWAYS add to avoidanceManeuvers (this is what triggers hasDiversions)
                            routeData.avoidanceManeuvers.push({
                                zone: i.zone.name,
                                type: i.type,
                                waypoints: bestCorridor.waypoints.map(wp => wp.name)
                            });
                        });

                        console.log(`Using ${bestCorridor.direction} corridor route (+${addedPercent.toFixed(0)}% distance)`);
                        console.log('SELECTED corridor waypoints:', bestCorridor.waypoints.map(w => ({ name: w.name, lat: w.lat, lon: w.lon })));
                        console.log('Total avoidanceWaypoints after corridor:', avoidanceWaypoints.length);
                    }
                }
            }

            // Find and avoid IFR/LIFR weather conditions along the route
            const weatherHazards = findWeatherHazards(depStation, destStation);
            const weatherAvoidanceWaypoints = [];

            weatherHazards.forEach(wxHazard => {
                const station = wxHazard.station;
                const stationId = station.id;

                // Skip if we've already processed this station
                if (hazardsAdded.has(`WX-${stationId}`)) return;

                // Check if we've exceeded our distance budget
                const currentAddedPercent = (totalAddedDistance / distance) * 100;
                if (currentAddedPercent >= maxAddedDistancePercent) {
                    // Can't add more diversions - warn pilot
                    routeData.hazards.push({
                        type: 'weather',
                        severity: wxHazard.severity,
                        name: `${station.flightRules} at ${stationId}`,
                        description: `${station.flightRules} conditions: Ceiling ${station.ceiling || 'N/A'} ft, Visibility ${station.visibility || 'N/A'} SM`,
                        location: Math.round(wxHazard.entryT * distance),
                        action: 'Route limit reached - monitor conditions'
                    });
                    hazardsAdded.add(`WX-${stationId}`);
                    return;
                }

                // Try to avoid this weather area
                const avoidWps = calculateWeatherAvoidanceWaypoints(depStation, destStation, wxHazard);
                if (avoidWps && avoidWps.length > 0) {
                    // Calculate added distance
                    let avoidanceDistance = 0;
                    let prevLat = depStation.lat, prevLon = depStation.lon;
                    avoidWps.forEach(wp => {
                        avoidanceDistance += haversineNM(prevLat, prevLon, wp.lat, wp.lon);
                        prevLat = wp.lat;
                        prevLon = wp.lon;
                    });
                    avoidanceDistance += haversineNM(prevLat, prevLon, destStation.lat, destStation.lon);
                    const directDist = haversineNM(depStation.lat, depStation.lon, destStation.lat, destStation.lon);
                    const thisAddedDist = avoidanceDistance - directDist;

                    // Check if adding this avoidance is within budget
                    if ((totalAddedDistance + thisAddedDist) / distance * 100 <= maxAddedDistancePercent) {
                        weatherAvoidanceWaypoints.push(...avoidWps);
                        totalAddedDistance += thisAddedDist;

                        // Add info-level hazard (weather being avoided)
                        routeData.hazards.push({
                            type: 'weather',
                            severity: 'caution',
                            name: `${station.flightRules} at ${stationId}`,
                            description: `Route diverts around ${station.flightRules} conditions at ${stationId}`,
                            location: Math.round(wxHazard.entryT * distance),
                            action: 'Auto-avoidance active'
                        });
                        hazardsAdded.add(`WX-${stationId}`);

                        // Track avoidance maneuvers
                        routeData.avoidanceManeuvers.push({
                            zone: `WX-${stationId}`,
                            type: 'weather',
                            flightRules: station.flightRules,
                            waypoints: avoidWps.map(wp => wp.name)
                        });

                        console.log(`Weather avoidance: routing around ${station.flightRules} at ${stationId}`);
                        return;
                    }
                }

                // Couldn't auto-avoid - warn pilot
                routeData.hazards.push({
                    type: 'weather',
                    severity: wxHazard.severity,
                    name: `${station.flightRules} at ${stationId}`,
                    description: `${station.flightRules} conditions: Ceiling ${station.ceiling || 'N/A'} ft, Visibility ${station.visibility || 'N/A'} SM`,
                    location: Math.round(wxHazard.entryT * distance),
                    action: 'Consider alternate route or delay'
                });
                hazardsAdded.add(`WX-${stationId}`);
            });

            // Add weather avoidance waypoints to the main avoidance list
            avoidanceWaypoints.push(...weatherAvoidanceWaypoints);

            // Check for other hazards along the route
            const numCheckPoints = 20;
            for (let i = 1; i < numCheckPoints; i++) {
                const t = i / numCheckPoints;
                const lat = depStation.lat + t * (destStation.lat - depStation.lat);
                const lon = depStation.lon + t * (destStation.lon - depStation.lon);
                const pointDistance = Math.round(t * distance);

                // Determine altitude at this point
                let altitude = routeData.cruiseAltitude;
                if (t < 0.15) altitude = (t / 0.15) * routeData.cruiseAltitude;
                else if (t > 0.85) altitude = ((1 - t) / 0.15) * routeData.cruiseAltitude;

                // Check for turbulence
                flightHazards.turbulenceZones.forEach(zone => {
                    if (pointInPolygon(lat, lon, zone.polygon)) {
                        if (altitude >= zone.base && altitude <= zone.top) {
                            const existing = routeData.hazards.find(h => h.name === zone.name && h.type === 'turbulence');
                            if (!existing) {
                                routeData.hazards.push({
                                    type: 'turbulence',
                                    severity: zone.intensity.toLowerCase().includes('severe') ? 'critical' :
                                              zone.intensity.toLowerCase().includes('moderate') ? 'warning' : 'caution',
                                    name: zone.name,
                                    description: `${zone.intensity} turbulence: ${zone.base.toLocaleString()}-${zone.top.toLocaleString()} ft`,
                                    location: pointDistance,
                                    action: zone.intensity.toLowerCase().includes('severe') ? 'Altitude change recommended' : 'Expect bumps'
                                });
                            }
                        }
                    }
                });

                // Check for icing
                flightHazards.icingZones.forEach(zone => {
                    if (pointInPolygon(lat, lon, zone.polygon)) {
                        if (altitude >= zone.base && altitude <= zone.top) {
                            const existing = routeData.hazards.find(h => h.name === zone.name && h.type === 'icing');
                            if (!existing) {
                                routeData.hazards.push({
                                    type: 'icing',
                                    severity: zone.intensity.toLowerCase().includes('severe') ? 'critical' :
                                              zone.intensity.toLowerCase().includes('moderate') ? 'warning' : 'caution',
                                    name: zone.name,
                                    description: `${zone.intensity} icing: ${zone.base.toLocaleString()}-${zone.top.toLocaleString()} ft`,
                                    location: pointDistance,
                                    action: 'Monitor and use anti-ice'
                                });
                            }
                        }
                    }
                });
            }

            // Check weather at departure and destination
            const depMetar = metarData[depStation.id];
            const destMetar = metarData[destStation.id];

            if (depMetar) {
                if (depMetar.visibility && depMetar.visibility < 3) {
                    routeData.hazards.push({
                        type: 'weather',
                        severity: depMetar.visibility < 1 ? 'critical' : 'warning',
                        name: 'Low Visibility - Departure',
                        description: `${depStation.id}: ${depMetar.visibility} SM visibility`,
                        location: 0,
                        action: 'IFR procedures required'
                    });
                }
                if (depMetar.ceiling && depMetar.ceiling < 1000) {
                    routeData.hazards.push({
                        type: 'weather',
                        severity: depMetar.ceiling < 500 ? 'critical' : 'warning',
                        name: 'Low Ceiling - Departure',
                        description: `${depStation.id}: ${depMetar.ceiling} ft ceiling`,
                        location: 0,
                        action: 'Check alternate minimums'
                    });
                }
            }

            if (destMetar) {
                if (destMetar.visibility && destMetar.visibility < 3) {
                    routeData.hazards.push({
                        type: 'weather',
                        severity: destMetar.visibility < 1 ? 'critical' : 'warning',
                        name: 'Low Visibility - Destination',
                        description: `${destStation.id}: ${destMetar.visibility} SM visibility`,
                        location: distance,
                        action: 'File alternate airport'
                    });
                }
                if (destMetar.ceiling && destMetar.ceiling < 1000) {
                    routeData.hazards.push({
                        type: 'weather',
                        severity: destMetar.ceiling < 500 ? 'critical' : 'warning',
                        name: 'Low Ceiling - Destination',
                        description: `${destStation.id}: ${destMetar.ceiling} ft ceiling`,
                        location: distance,
                        action: 'Prepare for missed approach'
                    });
                }
            }

            // Add mid-route waypoint if long flight AND no stops (stops replace midpoint)
            if (distance > 500 && (!stopsInput || stopsInput.length === 0)) {
                const midLat = (depStation.lat + destStation.lat) / 2;
                const midLon = (depStation.lon + destStation.lon) / 2;
                routeData.waypoints.push({
                    name: 'MIDPT',
                    type: 'enroute',
                    lat: midLat,
                    lon: midLon,
                    distance: Math.round(distance / 2)
                });
            }

            // Build waypoint sequence: Departure -> SID -> Intermediate -> STAR -> Destination
            // SID/STAR waypoints maintain their defined order (not projection-sorted)

            // Step 1: Add SID (departure procedure) waypoints in sequence
            let cumulativeDistance = 0;
            let lastWaypointPos = { lat: depStation.lat, lon: depStation.lon };

            if (departureWaypoints && departureWaypoints.length > 0) {
                console.log('Adding departure procedure waypoints:', departureWaypoints.map(wp => wp.name));
                departureWaypoints.forEach(wp => {
                    const distFromLast = haversineNM(lastWaypointPos.lat, lastWaypointPos.lon, wp.lat, wp.lon);
                    cumulativeDistance += distFromLast;
                    routeData.waypoints.push({
                        name: wp.name,
                        type: 'sid',
                        lat: wp.lat,
                        lon: wp.lon,
                        altitude: wp.altitude,
                        distance: Math.round(cumulativeDistance),
                        description: wp.description,
                        procedureName: wp.procedureName,
                        isCustom: false,
                        isStop: false
                    });
                    lastWaypointPos = { lat: wp.lat, lon: wp.lon };
                });
            }

            // Step 2: Combine custom waypoints, stops, and avoidance points for intermediate routing
            const allIntermediatePoints = [];

            // Add custom waypoints to the combined list
            if (customWaypointsInput && customWaypointsInput.length > 0) {
                customWaypointsInput.forEach(wp => {
                    allIntermediatePoints.push({
                        name: wp.name,
                        type: wp.isSnapped ? 'enroute-airport' : 'enroute',
                        lat: wp.lat,
                        lon: wp.lon,
                        isCustom: true,
                        isStop: false
                    });
                });
            }

            // Add stops to the combined list
            if (stopsInput && stopsInput.length > 0) {
                stopsInput.forEach(stop => {
                    allIntermediatePoints.push({
                        name: stop.id,
                        type: 'stop',
                        lat: stop.lat,
                        lon: stop.lon,
                        isCustom: false,
                        isStop: true
                    });
                });
            }

            // Add avoidance waypoints to the combined list
            if (avoidanceWaypoints && avoidanceWaypoints.length > 0) {
                avoidanceWaypoints.forEach(wp => {
                    allIntermediatePoints.push({
                        name: wp.name,
                        type: wp.type === 'weather-avoidance' ? 'weather-avoidance' : 'divert',
                        lat: wp.lat,
                        lon: wp.lon,
                        isCustom: false,
                        isStop: false,
                        isAvoidance: true,
                        avoidingZone: wp.avoidingZone || wp.avoidingStation,
                        reason: wp.reason
                    });
                });
            }

            console.log('allIntermediatePoints before sort:', allIntermediatePoints.map(p => ({ name: p.name, lat: p.lat, lon: p.lon, type: p.type })));

            // Sort intermediate points by their projection along the route
            // Use route from last SID waypoint (or departure) to first STAR waypoint (or destination)
            const routeStartForSort = lastWaypointPos;
            const routeEndForSort = arrivalWaypoints.length > 0
                ? { lat: arrivalWaypoints[0].lat, lon: arrivalWaypoints[0].lon }
                : { lat: destStation.lat, lon: destStation.lon };

            if (allIntermediatePoints.length > 0) {
                const routeVecLat = routeEndForSort.lat - routeStartForSort.lat;
                const routeVecLon = routeEndForSort.lon - routeStartForSort.lon;
                const routeLenSq = routeVecLat * routeVecLat + routeVecLon * routeVecLon;

                allIntermediatePoints.sort((a, b) => {
                    const projA = routeLenSq > 0 ? ((a.lat - routeStartForSort.lat) * routeVecLat + (a.lon - routeStartForSort.lon) * routeVecLon) / routeLenSq : 0;
                    const projB = routeLenSq > 0 ? ((b.lat - routeStartForSort.lat) * routeVecLat + (b.lon - routeStartForSort.lon) * routeVecLon) / routeLenSq : 0;
                    return projA - projB;
                });

                console.log('allIntermediatePoints AFTER sort:', allIntermediatePoints.map(p => ({ name: p.name, lat: p.lat, lon: p.lon })));

                // Add sorted intermediate waypoints with cumulative distances
                allIntermediatePoints.forEach(point => {
                    const distFromLast = haversineNM(lastWaypointPos.lat, lastWaypointPos.lon, point.lat, point.lon);
                    cumulativeDistance += distFromLast;

                    routeData.waypoints.push({
                        name: point.name,
                        type: point.type,
                        lat: point.lat,
                        lon: point.lon,
                        distance: Math.round(cumulativeDistance),
                        isCustom: point.isCustom,
                        isStop: point.isStop
                    });

                    lastWaypointPos = { lat: point.lat, lon: point.lon };
                });
            }

            // Add fuel stops as waypoints (so route line goes through them)
            if (fuelStops.length > 0) {
                fuelStops.forEach((stop, idx) => {
                    const distFromLast = haversineNM(lastWaypointPos.lat, lastWaypointPos.lon, stop.station.lat, stop.station.lon);
                    cumulativeDistance += distFromLast;
                    routeData.waypoints.push({
                        name: stop.station.id,
                        type: 'fuel',
                        lat: stop.station.lat,
                        lon: stop.station.lon,
                        distance: Math.round(cumulativeDistance),
                        isFuelStop: true,
                        fuelStopNumber: idx + 1,
                        reason: `Fuel Stop ${idx + 1}`
                    });
                    lastWaypointPos = { lat: stop.station.lat, lon: stop.station.lon };
                });
            }

            // Step 3: Add STAR (arrival procedure) waypoints in sequence before destination
            if (arrivalWaypoints && arrivalWaypoints.length > 0) {
                console.log('Adding arrival procedure waypoints:', arrivalWaypoints.map(wp => wp.name));
                arrivalWaypoints.forEach(wp => {
                    const distFromLast = haversineNM(lastWaypointPos.lat, lastWaypointPos.lon, wp.lat, wp.lon);
                    cumulativeDistance += distFromLast;
                    routeData.waypoints.push({
                        name: wp.name,
                        type: 'star',
                        lat: wp.lat,
                        lon: wp.lon,
                        altitude: wp.altitude,
                        distance: Math.round(cumulativeDistance),
                        description: wp.description,
                        procedureName: wp.procedureName,
                        isCustom: false,
                        isStop: false
                    });
                    lastWaypointPos = { lat: wp.lat, lon: wp.lon };
                });
            }

            // Step 4: Add destination as final waypoint
            const distToDestFromLast = haversineNM(lastWaypointPos.lat, lastWaypointPos.lon, destStation.lat, destStation.lon);
            cumulativeDistance += distToDestFromLast;
            const destDistance = cumulativeDistance;

            // Update fuelPlan.actualRouteDistance to reflect the true route distance
            routeData.fuelPlan.actualRouteDistance = Math.round(destDistance);

            routeData.waypoints.push({
                name: destStation.id,
                type: 'destination',
                lat: destStation.lat,
                lon: destStation.lon,
                distance: Math.round(destDistance)
            });

            // Sort waypoints by distance
            routeData.waypoints.sort((a, b) => a.distance - b.distance);

            console.log('FINAL routeData.waypoints:', routeData.waypoints.map(wp => ({ name: wp.name, type: wp.type, lat: wp.lat, lon: wp.lon, distance: wp.distance })));

            // Add fuel stop warning if needed
            if (routeData.fuelPlan.fuelStopRequired) {
                routeData.hazards.push({
                    type: 'fuel',
                    severity: 'warning',
                    name: 'Fuel Stop Required',
                    description: `Total fuel required (${routeData.fuelPlan.total} gal) exceeds safe capacity`,
                    location: Math.round(distance * 0.6),
                    action: 'Plan intermediate fuel stop'
                });
            }

            // Check for UNRESOLVABLE terrain conflicts along the route
            // Only report terrain hazards that can't be avoided even at max altitude
            // The flight path optimizer will raise altitude to clear terrain, so we only
            // warn if terrain exceeds what even max altitude can clear
            const terrainSamplePoints = 50;
            let terrainSeed = (depStation.lat * 1000 + destStation.lon * 100) % 1000;
            function terrainSeededRandom() {
                terrainSeed = (terrainSeed * 9301 + 49297) % 233280;
                return terrainSeed / 233280;
            }

            // AIRCRAFT_MAX_ALT already defined above (12500)
            const minSafeClearance = 2000; // 2000ft minimum safe clearance
            const maxSafeTerrainHeight = AIRCRAFT_MAX_ALT - minSafeClearance; // 10,500 ft - terrain above this can't be cleared

            // Check for terrain that exceeds what even max altitude can clear
            const unresolvableTerrainConflicts = [];

            for (let i = 0; i <= terrainSamplePoints; i++) {
                const t = i / terrainSamplePoints;
                const positionSeed = t;
                const distNM = t * distance;

                // Calculate terrain elevation at this point (same formula as profile canvas)
                const terrainHeight = Math.sin(positionSeed * 10) * 2000 +
                                     Math.sin(positionSeed * 25) * 800 +
                                     Math.sin(positionSeed * 50) * 400 +
                                     terrainSeededRandom() * 500 + 500;

                // Only flag terrain that can't be cleared even at max altitude
                if (terrainHeight > maxSafeTerrainHeight) {
                    const maxClearance = AIRCRAFT_MAX_ALT - terrainHeight;
                    unresolvableTerrainConflicts.push({
                        severity: maxClearance < 0 ? 'critical' : 'warning',
                        distNM: Math.round(distNM),
                        terrainHeight: Math.round(terrainHeight),
                        maxClearance: Math.round(maxClearance)
                    });
                }
            }

            // Add terrain hazards only for unresolvable conflicts
            const criticalConflicts = unresolvableTerrainConflicts.filter(c => c.severity === 'critical');
            const warningConflicts = unresolvableTerrainConflicts.filter(c => c.severity === 'warning');

            if (criticalConflicts.length > 0) {
                // Find worst critical conflict (terrain above max altitude)
                const worstCritical = criticalConflicts.reduce((worst, c) =>
                    c.maxClearance < worst.maxClearance ? c : worst, criticalConflicts[0]);
                routeData.hazards.push({
                    type: 'terrain',
                    severity: 'critical',
                    name: 'Terrain CRITICAL',
                    description: `Terrain at ${worstCritical.terrainHeight.toLocaleString()} ft exceeds aircraft ceiling (${AIRCRAFT_MAX_ALT.toLocaleString()} ft) at ${worstCritical.distNM} NM`,
                    location: worstCritical.distNM,
                    action: 'Route around high terrain - cannot overfly'
                });
            } else if (warningConflicts.length > 0) {
                // Find worst warning conflict (terrain too high for safe clearance)
                const worstWarning = warningConflicts.reduce((worst, c) =>
                    c.maxClearance < worst.maxClearance ? c : worst, warningConflicts[0]);
                routeData.hazards.push({
                    type: 'terrain',
                    severity: 'warning',
                    name: 'Terrain Warning',
                    description: `Only ${worstWarning.maxClearance.toLocaleString()} ft max clearance at ${worstWarning.distNM} NM (terrain: ${worstWarning.terrainHeight.toLocaleString()} ft)`,
                    location: worstWarning.distNM,
                    action: 'Flying at ceiling - consider alternate route'
                });
            }

            // Find airways along the route (if airways data is loaded)
            if (airwaysLoaded && airwaysData.length > 0) {
                routeData.airways = findAirwaysAlongRoute(
                    depStation.lat, depStation.lon,
                    destStation.lat, destStation.lon,
                    routeData.cruiseAltitude
                );
                console.log(`Found ${routeData.airways.length} airways along route`);
            }

            // Select optimal runways based on wind (if runway data is loaded)
            if (runwaysLoaded) {
                // Get wind data from METAR cache if available
                const depMetar = metarData[depStation.id];
                const destMetar = metarData[destStation.id];

                // Parse wind from METAR
                const parseWind = (metar) => {
                    if (!metar || !metar.raw) return { dir: null, speed: 0 };
                    const windMatch = metar.raw.match(/(\d{3}|VRB)(\d{2,3})(G\d{2,3})?KT/);
                    if (windMatch) {
                        const dir = windMatch[1] === 'VRB' ? null : parseInt(windMatch[1]);
                        const speed = parseInt(windMatch[2]);
                        return { dir, speed };
                    }
                    return { dir: null, speed: 0 };
                };

                const depWind = parseWind(depMetar);
                const destWind = parseWind(destMetar);

                // Select optimal runways
                routeData.departureRunway = selectOptimalRunway(depStation.id, depWind.dir, depWind.speed);
                routeData.destinationRunway = selectOptimalRunway(destStation.id, destWind.dir, destWind.speed);

                if (routeData.departureRunway) {
                    console.log(`Departure RWY: ${routeData.departureRunway.runway} (${routeData.departureRunway.headwind}kt HW, ${routeData.departureRunway.crosswind}kt XW)`);
                }
                if (routeData.destinationRunway) {
                    console.log(`Arrival RWY: ${routeData.destinationRunway.runway} (${routeData.destinationRunway.headwind}kt HW, ${routeData.destinationRunway.crosswind}kt XW)`);
                }
            }

            return routeData;
        }

        // Update trip summary panel with route data
        function updateTripSummary(routeData) {
            // Calculate actual route distance including diversions
            let actualDistance = 0;
            const R = 3440.065; // Earth radius in nautical miles
            console.log('updateTripSummary: waypoints count:', routeData.waypoints.length);
            console.log('updateTripSummary: waypoints:', routeData.waypoints.map(wp => wp.name));
            for (let i = 0; i < routeData.waypoints.length - 1; i++) {
                const wp1 = routeData.waypoints[i];
                const wp2 = routeData.waypoints[i + 1];
                const lat1 = wp1.lat * Math.PI / 180;
                const lat2 = wp2.lat * Math.PI / 180;
                const dLat = (wp2.lat - wp1.lat) * Math.PI / 180;
                const dLon = (wp2.lon - wp1.lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1) * Math.cos(lat2) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                actualDistance += R * c;
            }
            console.log('updateTripSummary: calculated actualDistance:', actualDistance);

            // Check if there are diversions
            const hasDiversions = routeData.avoidanceManeuvers && routeData.avoidanceManeuvers.length > 0;
            const diversionCount = routeData.waypoints.filter(wp => wp.type === 'divert').length;
            const directDistance = routeData.distance;
            console.log('updateTripSummary: hasDiversions:', hasDiversions, 'avoidanceManeuvers:', routeData.avoidanceManeuvers?.length);
            console.log('updateTripSummary: directDistance:', directDistance, 'actualDistance:', actualDistance);
            const displayDistance = hasDiversions ? Math.round(actualDistance) : Math.round(directDistance);
            const extraDistance = hasDiversions ? Math.round(actualDistance - directDistance) : 0;
            console.log('updateTripSummary: displayDistance:', displayDistance, 'extraDistance:', extraDistance);

            // Recalculate time based on actual distance if there are diversions
            const cruiseSpeed = 200;
            const cruiseTime = displayDistance / cruiseSpeed;
            const adjustedTime = hasDiversions ? cruiseTime * 1.1 : routeData.estimatedTime; // Add 10% for diversions
            const hours = Math.floor(adjustedTime);
            const mins = Math.round((adjustedTime - hours) * 60);

            // Calculate flight conditions score (0-100%)
            // Philosophy: Score represents how favorable conditions are for VFR flight
            // - VFR everywhere = Optimal (85-100)
            // - MVFR at one point = Still good (70-85)
            // - IFR anywhere = Concerning (50-70)
            // - LIFR or severe hazards = Poor (below 50)
            let conditionsScore = 100;

            // Weather penalties by flight rules (penalty-based, not score-based)
            const weatherPenalties = { 'VFR': 0, 'MVFR': -10, 'IFR': -25, 'LIFR': -40 };

            // Get weather at critical points
            const depFR = routeData.departure?.flight_rules || metarData[routeData.departure?.id]?.flight_rules || 'VFR';
            const destFR = routeData.destination?.flight_rules || metarData[routeData.destination?.id]?.flight_rules || 'VFR';

            // Departure: Important but you can delay departure (60% weight)
            conditionsScore += (weatherPenalties[depFR] || 0) * 0.6;

            // Destination: Critical - you MUST land there (full weight)
            conditionsScore += (weatherPenalties[destFR] || 0);

            // En route stops: Take worst weather from fuel stops and custom stops (40% weight)
            let worstEnRoutePenalty = 0;

            if (routeData.stops && routeData.stops.length > 0) {
                routeData.stops.forEach(stop => {
                    const stopMetar = metarData[stop.id];
                    const stopFR = stopMetar?.flight_rules || 'VFR';
                    worstEnRoutePenalty = Math.min(worstEnRoutePenalty, weatherPenalties[stopFR] || 0);
                });
            }

            if (routeData.fuelPlan?.fuelStops && routeData.fuelPlan.fuelStops.length > 0) {
                routeData.fuelPlan.fuelStops.forEach(stop => {
                    const stopMetar = metarData[stop.station?.id];
                    const stopFR = stopMetar?.flight_rules || 'VFR';
                    worstEnRoutePenalty = Math.min(worstEnRoutePenalty, weatherPenalties[stopFR] || 0);
                });
            }

            conditionsScore += worstEnRoutePenalty * 0.4;

            // Hazard penalties (capped to prevent over-penalization)
            // Only critical and warning hazards affect score; caution/info are informational
            let hazardPenalty = 0;
            if (routeData.hazards && routeData.hazards.length > 0) {
                routeData.hazards.forEach(hazard => {
                    if (hazard.severity === 'critical') hazardPenalty += 10;
                    else if (hazard.severity === 'warning') hazardPenalty += 5;
                    // Caution and info hazards don't affect score - they're informational
                });
            }
            conditionsScore -= Math.min(hazardPenalty, 20); // Cap total hazard penalty at -20

            // Environmental hazards (only meaningful penalties for severe conditions)
            // Check if turbulence/icing affects our route corridor
            const routeIntersectsTurbulence = (zone) => {
                if (!routeData.waypoints || routeData.waypoints.length < 2) return false;
                // Simple check: does zone base altitude overlap with our cruise altitude?
                const cruiseAlt = routeData.cruiseAltitude || 10000;
                return zone.base <= cruiseAlt && (zone.top || 99999) >= cruiseAlt;
            };

            const severeTurb = flightHazards.turbulenceZones.filter(z =>
                z.intensity.includes('Severe') && routeIntersectsTurbulence(z)
            );
            const modTurb = flightHazards.turbulenceZones.filter(z =>
                z.intensity.includes('Moderate') && routeIntersectsTurbulence(z)
            );
            const modIcing = flightHazards.icingZones.filter(z =>
                z.intensity.includes('Moderate') && routeIntersectsTurbulence(z)
            );

            if (severeTurb.length > 0) conditionsScore -= 12;
            else if (modTurb.length > 0) conditionsScore -= 4;
            if (modIcing.length > 0) conditionsScore -= 6;

            // Route complexity: Minimal penalty for diversions
            // Diversions are a SOLUTION (avoiding hazards), not an additional problem
            if (hasDiversions) {
                conditionsScore -= Math.min(diversionCount * 2, 6); // Max -6 for diversions
            }

            // NO penalty for fuel stops - they're operational necessities, not conditions issues

            // Clamp to 0-100
            conditionsScore = Math.max(0, Math.min(100, Math.round(conditionsScore)));

            // Three-tier status system for clearer feedback
            const getConditionsStatus = (score) => {
                if (score >= 75) {
                    return { text: 'Optimal', color: '#22c55e' };
                } else if (score >= 50) {
                    return { text: 'Marginal', color: '#f59e0b' };
                } else {
                    return { text: 'Poor', color: '#ef4444' };
                }
            };
            const conditionsStatus = getConditionsStatus(conditionsScore);

            // Update mini display
            document.getElementById('tripMiniDistance').textContent = `${displayDistance} NM`;
            document.getElementById('tripMiniTime').textContent = `${hours}h ${mins}m`;
            document.getElementById('tripMiniConditions').textContent = conditionsStatus.text;
            document.getElementById('tripMiniConditions').style.color = conditionsStatus.color;

            // Update floating progress bar (0% at route load)
            setTripProgress(`${hours}h ${mins}m`, 0);

            // Update overview
            document.getElementById('tripDepAirport').textContent = routeData.departure.id;
            document.getElementById('tripDestAirport').textContent = routeData.destination.id;
            document.getElementById('tripDistance').textContent = hasDiversions
                ? `${displayDistance} NM (+${extraDistance})`
                : `${displayDistance} NM`;
            document.getElementById('tripTime').textContent = `${hours}:${mins.toString().padStart(2, '0')}`;
            document.getElementById('tripFuel').textContent = `${routeData.fuelPlan.total} gal`;
            document.getElementById('tripConditions').textContent = conditionsStatus.text;
            document.getElementById('tripConditions').style.color = conditionsStatus.color;

            // Update phases
            const phasesDiv = document.getElementById('tripPhases');
            phasesDiv.innerHTML = routeData.phases.map(phase => `
                <div class="trip-phase">
                    <div class="trip-phase-icon ${phase.type}">
                        ${phase.type === 'climb' ? '' : phase.type === 'descent' ? '' : ''}
                    </div>
                    <div class="trip-phase-info">
                        <div class="trip-phase-name">${phase.name}</div>
                        <div class="trip-phase-details">${phase.startAlt.toLocaleString()}  ${phase.endAlt.toLocaleString()} ft  ${phase.time} min</div>
                    </div>
                    <div class="trip-phase-distance">${phase.distance} NM</div>
                </div>
            `).join('');

            // Update hazards - filter out hazards that have been addressed
            const hazardsDiv = document.getElementById('tripHazards');
            const cruiseAlt = routeData.cruiseAltitude || 12500;

            // Filter hazards to only show unresolved ones
            const unresolvedHazards = routeData.hazards.filter(hazard => {
                // Filter out any hazard that's already handled by auto-avoidance
                if (hazard.action === 'Auto-avoidance active') {
                    return false; // Already being avoided - don't show as hazard
                }

                // Filter out restricted/prohibited airspace if we've routed around it
                if (hazard.type === 'restricted' || hazard.type === 'prohibited') {
                    // Check if we have avoidance waypoints for this zone
                    const hasAvoidance = routeData.avoidanceManeuvers &&
                        routeData.avoidanceManeuvers.some(m => m.zone === hazard.name);
                    if (hasAvoidance) return false; // Addressed - don't show
                }

                // Filter out icing hazards if they're above our ceiling
                if (hazard.type === 'icing') {
                    // Parse altitude from description like "12,000-24,000 ft"
                    const altMatch = hazard.description?.match(/(\d{1,2}),?(\d{3})/);
                    if (altMatch) {
                        const baseAlt = parseInt(altMatch[1] + altMatch[2]);
                        if (baseAlt > cruiseAlt) return false; // Above our ceiling - don't show
                    }
                }

                // Filter out turbulence hazards if they're above our ceiling
                if (hazard.type === 'turbulence') {
                    const altMatch = hazard.description?.match(/(\d{1,2}),?(\d{3})/);
                    if (altMatch) {
                        const baseAlt = parseInt(altMatch[1] + altMatch[2]);
                        if (baseAlt > cruiseAlt) return false; // Above our ceiling - don't show
                    }
                }

                // Filter out fuel stop hazard if fuel stops have been calculated
                if (hazard.type === 'fuel' && routeData.fuelPlan?.fuelStops?.length > 0) {
                    return false; // Addressed by calculated fuel stops
                }

                return true; // Show this hazard
            });

            if (unresolvedHazards.length === 0) {
                hazardsDiv.innerHTML = '<div class="no-hazards">No significant hazards detected</div>';
            } else {
                hazardsDiv.innerHTML = unresolvedHazards.map(hazard => `
                    <div class="trip-hazard ${hazard.severity}">
                        <div class="trip-hazard-icon">
                            ${hazard.type === 'restricted' ? '' :
                              hazard.type === 'prohibited' ? '' :
                              hazard.type === 'turbulence' ? '' :
                              hazard.type === 'icing' ? '' :
                              hazard.type === 'weather' ? '' :
                              hazard.type === 'fuel' ? '' :
                              hazard.type === 'terrain' ? '' : ''}
                        </div>
                        <div class="trip-hazard-content">
                            <div class="trip-hazard-title">${hazard.name}</div>
                            <div class="trip-hazard-desc">${hazard.description}</div>
                            <div class="trip-hazard-action"> ${hazard.action}</div>
                        </div>
                    </div>
                `).join('');
            }

            // Update waypoints
            const waypointsDiv = document.getElementById('tripWaypoints');
            waypointsDiv.innerHTML = routeData.waypoints.map(wp => {
                const isFuel = wp.type === 'fuel' || wp.isFuelStop;
                const markerClass = isFuel ? 'fuel' : wp.type;
                const fuelLabel = isFuel ? `<span class="fuel-stop-label">FUEL</span>` : '';
                return `
                    <div class="trip-waypoint ${isFuel ? 'fuel-stop' : ''}">
                        <div class="trip-waypoint-marker ${markerClass}">${isFuel ? 'F' + wp.fuelStopNumber : ''}</div>
                        <div class="trip-waypoint-info">
                            <div class="trip-waypoint-name">${wp.name} ${fuelLabel}</div>
                            <div class="trip-waypoint-coords">${wp.lat.toFixed(2)}, ${wp.lon.toFixed(2)}${wp.reason ? ' - ' + wp.reason : ''}</div>
                        </div>
                        <div class="trip-waypoint-distance">${wp.distance} NM</div>
                    </div>
                `;
            }).join('');

            // Update airways section
            const airwaysSection = document.getElementById('tripAirwaysSection');
            const airwaysDiv = document.getElementById('tripAirways');
            if (routeData.airways && routeData.airways.length > 0) {
                airwaysSection.style.display = 'block';
                airwaysDiv.innerHTML = routeData.airways.map(airway => {
                    const typeClass = airway.type.toLowerCase().replace(' ', '-').replace('-route', '-route');
                    return `
                        <div class="airway-tag ${typeClass}" title="${airway.type}: FL${Math.round(airway.minAlt/100)}-FL${Math.round(airway.maxAlt/100)}">
                            <span>${airway.ident}</span>
                            <span class="distance">${Math.round(airway.totalDistance)} nm</span>
                        </div>
                    `;
                }).join('');
            } else {
                airwaysSection.style.display = 'none';
                airwaysDiv.innerHTML = '';
            }

            // Update runways section
            const runwaysSection = document.getElementById('tripRunwaysSection');
            const runwaysDiv = document.getElementById('tripRunways');
            if (routeData.departureRunway || routeData.destinationRunway) {
                runwaysSection.style.display = 'block';
                let runwaysHtml = '';

                if (routeData.departureRunway) {
                    const dep = routeData.departureRunway;
                    const hwClass = dep.headwind >= 0 ? 'headwind' : 'tailwind';
                    const hwLabel = dep.headwind >= 0 ? 'HW' : 'TW';
                    runwaysHtml += `
                        <div class="runway-row">
                            <span class="runway-label">Departure</span>
                            <div class="runway-info">
                                <span class="runway-id">${dep.runway}</span>
                                <span class="runway-wind">
                                    <span class="${hwClass}">${Math.abs(dep.headwind)}kt ${hwLabel}</span>
                                    <span class="crosswind">${dep.crosswind}kt XW</span>
                                </span>
                            </div>
                        </div>
                    `;
                }

                if (routeData.destinationRunway) {
                    const dest = routeData.destinationRunway;
                    const hwClass = dest.headwind >= 0 ? 'headwind' : 'tailwind';
                    const hwLabel = dest.headwind >= 0 ? 'HW' : 'TW';
                    runwaysHtml += `
                        <div class="runway-row">
                            <span class="runway-label">Arrival</span>
                            <div class="runway-info">
                                <span class="runway-id">${dest.runway}</span>
                                <span class="runway-wind">
                                    <span class="${hwClass}">${Math.abs(dest.headwind)}kt ${hwLabel}</span>
                                    <span class="crosswind">${dest.crosswind}kt XW</span>
                                </span>
                            </div>
                        </div>
                    `;
                }

                runwaysDiv.innerHTML = runwaysHtml;
            } else {
                runwaysSection.style.display = 'none';
                runwaysDiv.innerHTML = '';
            }

            // Update fuel plan
            const fuelDiv = document.getElementById('tripFuelPlan');
            let fuelHtml = '';

            // Show tank capacity and range info
            fuelHtml += `
                <div class="fuel-item">
                    <span class="fuel-item-label">Tank Capacity</span>
                    <span class="fuel-item-value">${routeData.fuelPlan.tankCapacity} gal</span>
                </div>
                <div class="fuel-item">
                    <span class="fuel-item-label">Max Range</span>
                    <span class="fuel-item-value">${routeData.fuelPlan.maxLegRange} nm</span>
                </div>
            `;

            // Show fuel stops if any
            if (routeData.fuelPlan.fuelStops && routeData.fuelPlan.fuelStops.length > 0) {
                fuelHtml += `
                    <div class="fuel-stops-header">
                        <span class="fuel-stops-alert">Fuel Stop${routeData.fuelPlan.fuelStops.length > 1 ? 's' : ''} Required</span>
                    </div>
                `;

                // Show each leg
                if (routeData.fuelPlan.legs) {
                    routeData.fuelPlan.legs.forEach((leg, i) => {
                        const isLastLeg = i === routeData.fuelPlan.legs.length - 1;
                        fuelHtml += `
                            <div class="fuel-leg">
                                <div class="fuel-leg-route">${leg.from}  ${leg.to}</div>
                                <div class="fuel-leg-details">
                                    <span>${leg.distance} nm</span>
                                    <span>${Math.floor(leg.time / 60)}:${(leg.time % 60).toString().padStart(2, '0')}</span>
                                    <span>${leg.fuel} gal</span>
                                </div>
                            </div>
                            ${!isLastLeg ? '<div class="fuel-stop-marker">FUEL STOP</div>' : ''}
                        `;
                    });
                }
            }

            // Show totals
            fuelHtml += `
                <div class="fuel-item fuel-totals">
                    <span class="fuel-item-label">Reserve (45 min)</span>
                    <span class="fuel-item-value">${routeData.fuelPlan.reserve} gal</span>
                </div>
                <div class="fuel-item fuel-totals">
                    <span class="fuel-item-label">Total Required</span>
                    <span class="fuel-item-value ${routeData.fuelPlan.fuelStopRequired ? 'warning' : 'ok'}">${routeData.fuelPlan.total} gal</span>
                </div>
            `;

            fuelDiv.innerHTML = fuelHtml;

            // Auto-enable overlays disabled - user can enable via "Route Overlays" button
            // autoEnableHazardOverlays(routeData.hazards);

            // Show the trip panel (minimized)
            showTripSummary();

            // Update and OPEN ATC Radio Panel
            updateATCPanel(routeData);
            openATCPanel();
        }

        // Open ATC panel (not toggle - explicitly open)
        function openATCPanel() {
            const panel = document.getElementById('atcRadioPanel');
            const btn = document.getElementById('atcPanelBtn');
            if (panel) {
                panel.classList.remove('hidden');
                document.body.classList.add('atc-panel-open');
                if (btn) btn.classList.add('active');
                localStorage.setItem('atcPanelVisible', true);
            }
        }

        // ============================================
        // ATC RADIO PANEL FUNCTIONS
        // ============================================

        let atcFrequencies = [];
        let atcSimulationTimer = null;
        let atcMessageIndex = 0;

        // Generate route-specific ATC frequencies
        function generateRouteFrequencies(depICAO, destICAO, waypoints = []) {
            const frequencies = [];

            // Departure airport frequencies (simulated based on airport)
            const depFreqs = getAirportFrequencies(depICAO, 'departure');
            frequencies.push(...depFreqs);

            // En-route frequencies based on region
            const enrouteFreqs = getEnRouteFrequencies(depICAO, destICAO);
            frequencies.push(...enrouteFreqs);

            // Destination airport frequencies
            const destFreqs = getAirportFrequencies(destICAO, 'arrival');
            frequencies.push(...destFreqs);

            return frequencies;
        }

        // Get airport-specific frequencies (simulated)
        function getAirportFrequencies(icao, phase) {
            // Common frequency patterns by airport type
            const majorAirportPatterns = {
                'KLAX': { ground: '121.75', tower: '120.95', atis: '133.80', approach: '124.50', departure: '125.20', name: 'LAX' },
                'KJFK': { ground: '121.90', tower: '119.10', atis: '128.72', approach: '132.40', departure: '135.90', name: 'JFK' },
                'KORD': { ground: '121.67', tower: '126.90', atis: '135.40', approach: '124.35', departure: '125.40', name: "O'Hare" },
                'KDEN': { ground: '121.85', tower: '132.35', atis: '134.42', approach: '120.05', departure: '128.25', name: 'Denver' },
                'KSLC': { ground: '121.90', tower: '118.30', atis: '124.75', approach: '124.30', departure: '128.10', name: 'Salt Lake' },
                'KPSP': { ground: '121.80', tower: '119.70', atis: '128.05', approach: '127.25', departure: '127.25', name: 'Palm Springs' },
                'KSFO': { ground: '121.80', tower: '120.50', atis: '118.85', approach: '135.65', departure: '120.90', name: 'SFO' },
                'KLAS': { ground: '121.90', tower: '119.90', atis: '132.47', approach: '125.90', departure: '124.75', name: 'Las Vegas' },
                'KPHX': { ground: '119.75', tower: '118.70', atis: '127.17', approach: '119.20', departure: '120.70', name: 'Phoenix' },
            };

            const freqs = [];
            const pattern = majorAirportPatterns[icao] || generateGenericFrequencies(icao);

            if (phase === 'departure') {
                freqs.push({ freq: pattern.ground, name: pattern.name || icao.slice(1), type: 'GND', active: true });
                freqs.push({ freq: pattern.tower, name: pattern.name || icao.slice(1), type: 'TWR', active: true });
                freqs.push({ freq: pattern.departure, name: pattern.name || icao.slice(1), type: 'DEP', active: false });
            } else {
                freqs.push({ freq: pattern.approach, name: pattern.name || icao.slice(1), type: 'APP', active: false });
                freqs.push({ freq: pattern.tower, name: pattern.name || icao.slice(1), type: 'TWR', active: false });
            }

            return freqs;
        }

        // Generate generic frequencies for unknown airports
        function generateGenericFrequencies(icao) {
            // Use ICAO code to seed pseudo-random but consistent frequencies
            const seed = icao.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            return {
                ground: (121.5 + (seed % 5) * 0.1).toFixed(2),
                tower: (118.0 + (seed % 20) * 0.1).toFixed(2),
                atis: (127.0 + (seed % 80) * 0.1).toFixed(2),
                approach: (119.0 + (seed % 60) * 0.1).toFixed(2),
                departure: (124.0 + (seed % 40) * 0.1).toFixed(2),
                name: icao.slice(1)
            };
        }

        // Get en-route (Center) frequencies based on route
        function getEnRouteFrequencies(depICAO, destICAO) {
            const freqs = [];

            // Determine which centers the route might pass through
            // This is simplified - real implementation would use route waypoints
            const routeRegion = determineRouteRegion(depICAO, destICAO);

            const centerFrequencies = {
                'socal': { freq: '134.20', name: 'SoCal', type: 'CTR' },
                'la_center': { freq: '127.35', name: 'LA Center', type: 'CTR' },
                'joshua': { freq: '128.05', name: 'Joshua', type: 'CTR' },
                'oakland': { freq: '127.80', name: 'Oakland', type: 'CTR' },
                'denver': { freq: '132.45', name: 'Denver', type: 'CTR' },
                'salt_lake': { freq: '128.30', name: 'Salt Lake', type: 'CTR' },
                'albuquerque': { freq: '127.95', name: 'Albuquerque', type: 'CTR' },
                'seattle': { freq: '128.50', name: 'Seattle', type: 'CTR' },
                'minneapolis': { freq: '132.25', name: 'Minneapolis', type: 'CTR' },
            };

            // Add centers based on route region
            routeRegion.forEach(region => {
                if (centerFrequencies[region]) {
                    freqs.push({ ...centerFrequencies[region], active: false });
                }
            });

            return freqs;
        }

        // Determine which ATC centers the route passes through
        function determineRouteRegion(depICAO, destICAO) {
            const regions = [];

            // Simple region mapping based on airports
            const airportRegions = {
                'KLAX': ['socal', 'la_center'],
                'KSLC': ['salt_lake'],
                'KLAS': ['la_center', 'joshua'],
                'KDEN': ['denver'],
                'KJFK': ['new_york'],
                'KPSP': ['socal', 'joshua'],
                'KPHX': ['albuquerque'],
                'KSFO': ['oakland'],
            };

            // Add departure region
            if (airportRegions[depICAO]) {
                regions.push(...airportRegions[depICAO]);
            }

            // Add intermediate regions based on common routes
            if ((depICAO === 'KLAX' || depICAO === 'KPSP') && destICAO === 'KSLC') {
                regions.push('joshua');
            }

            // Add destination region
            if (airportRegions[destICAO]) {
                const destRegions = airportRegions[destICAO].filter(r => !regions.includes(r));
                regions.push(...destRegions);
            }

            return [...new Set(regions)]; // Remove duplicates
        }

        // Render ATC frequencies in the panel
        function renderATCFrequencies(frequencies) {
            const container = document.getElementById('atcFrequencies');
            if (!container) return;

            atcFrequencies = frequencies;

            // Ensure all frequencies have listening property
            frequencies.forEach(f => {
                if (f.listening === undefined) f.listening = f.active;
            });

            container.innerHTML = frequencies.map((f, index) => `
                <div class="atc-freq-row ${f.active ? 'transmit' : ''} ${f.listening ? 'listening' : ''}" data-index="${index}">
                    <button class="atc-freq-toggle" onclick="toggleATCTransmit(${index})" title="${f.active ? 'Disable Transmit' : 'Enable Transmit'}">
                        ${f.active ?
                            '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>' :
                            '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 11h-1.7c0 .74-.16 1.43-.43 2.05l1.23 1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06.02-.11.02-.17V5c0-1.66-1.34-3-3-3S9 3.34 9 5v.18l5.98 5.99zM4.27 3L3 4.27l6.01 6.01V11c0 1.66 1.33 3 2.99 3 .22 0 .44-.03.65-.08l1.66 1.66c-.71.33-1.5.52-2.31.52-2.76 0-5.3-2.1-5.3-5.1H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c.91-.13 1.77-.45 2.54-.9L19.73 21 21 19.73 4.27 3z"/></svg>'
                        }
                    </button>
                    <button class="atc-freq-value ${f.listening ? 'listening' : ''}" onclick="toggleATCListen(${index})" title="${f.listening ? 'Stop Listening' : 'Start Listening'}">
                        ${f.freq}
                        <span class="listen-indicator">${f.listening ? '<svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12"><path d="M12 1c-4.97 0-9 4.03-9 9v7c0 1.66 1.34 3 3 3h3v-8H5v-2c0-3.87 3.13-7 7-7s7 3.13 7 7v2h-4v8h3c1.66 0 3-1.34 3-3v-7c0-4.97-4.03-9-9-9z"/></svg>' : ''}</span>
                    </button>
                    <span class="atc-freq-name">${f.name}</span>
                    <span class="atc-freq-type">${f.type}</span>
                </div>
            `).join('');
        }

        // Toggle frequency transmit (mic) state
        function toggleATCTransmit(index) {
            if (index < 0 || index >= atcFrequencies.length) return;

            atcFrequencies[index].active = !atcFrequencies[index].active;
            // If transmit is enabled, also enable listening
            if (atcFrequencies[index].active) {
                atcFrequencies[index].listening = true;
            }
            renderATCFrequencies(atcFrequencies);
        }

        // Toggle frequency listen state (can listen to multiple channels)
        function toggleATCListen(index) {
            if (index < 0 || index >= atcFrequencies.length) return;

            atcFrequencies[index].listening = !atcFrequencies[index].listening;
            // If not listening, also disable transmit
            if (!atcFrequencies[index].listening) {
                atcFrequencies[index].active = false;
            }
            renderATCFrequencies(atcFrequencies);
        }

        // Legacy function name for compatibility
        function toggleATCFrequency(index) {
            toggleATCTransmit(index);
        }

        // Simulated ATC messages for demonstration
        function getSimulatedATCMessages(depICAO, destICAO) {
            const depName = depICAO.slice(1);
            const destName = destICAO.slice(1);

            return [
                { station: depICAO, msg: `November Nine Zero Two One Zero, ${depName} Ground, taxi to runway two five right via Alpha.`, delay: 2000 },
                { station: depICAO, msg: `November 90210, hold short runway two five right.`, delay: 8000 },
                { station: depICAO, msg: `November 90210, ${depName} Tower, runway two five right, cleared for takeoff.`, delay: 15000 },
                { station: 'SOCAL', msg: `November 90210, radar contact, climb and maintain six thousand.`, delay: 25000 },
                { station: 'SOCAL', msg: `November 90210, turn right heading zero four zero, vectors for traffic.`, delay: 35000 },
                { station: 'CTR', msg: `November 90210, contact LA Center on one two seven point three five.`, delay: 45000 },
                { station: 'LA CTR', msg: `November 90210, LA Center, climb and maintain one two thousand five hundred.`, delay: 55000 },
                { station: 'LA CTR', msg: `November 90210, direct ${destName} when able.`, delay: 70000 },
                { station: destICAO, msg: `November 90210, ${destName} Approach, descend and maintain eight thousand.`, delay: 90000 },
                { station: destICAO, msg: `November 90210, cleared ILS runway three four left approach.`, delay: 110000 },
            ];
        }

        // Start ATC transcription simulation
        function startATCSimulation(depICAO, destICAO) {
            // Clear any existing simulation
            stopATCSimulation();

            const messages = getSimulatedATCMessages(depICAO, destICAO);
            const transcriptionText = document.getElementById('atcTranscriptionText');

            if (!transcriptionText) return;

            transcriptionText.innerHTML = '<span class="atc-waiting">Monitoring frequencies...</span>';
            atcMessageIndex = 0;

            // Schedule messages
            messages.forEach((message, index) => {
                setTimeout(() => {
                    displayATCMessage(message.station, message.msg);
                }, message.delay);
            });
        }

        // Stop ATC simulation
        function stopATCSimulation() {
            if (atcSimulationTimer) {
                clearInterval(atcSimulationTimer);
                atcSimulationTimer = null;
            }
        }

        // Display an ATC message with typing effect
        function displayATCMessage(station, message) {
            const transcriptionText = document.getElementById('atcTranscriptionText');
            if (!transcriptionText) return;

            // Create message element
            const msgDiv = document.createElement('div');
            msgDiv.className = 'atc-message';
            msgDiv.innerHTML = `<span class="atc-station">${station}:</span> <span class="atc-msg-text"></span>`;

            // Clear "waiting" message if present
            const waiting = transcriptionText.querySelector('.atc-waiting');
            if (waiting) waiting.remove();

            transcriptionText.appendChild(msgDiv);

            // Type out message
            const msgText = msgDiv.querySelector('.atc-msg-text');
            let charIndex = 0;
            const typeInterval = setInterval(() => {
                if (charIndex < message.length) {
                    msgText.textContent += message[charIndex];
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                }
            }, 30);

            // Scroll to bottom
            transcriptionText.scrollTop = transcriptionText.scrollHeight;
        }

        // Update ATC Panel with route data
        function updateATCPanel(routeData) {
            if (!routeData || !routeData.departure || !routeData.destination) return;

            const depICAO = routeData.departure.id;
            const destICAO = routeData.destination.id;

            // Generate and display frequencies
            const frequencies = generateRouteFrequencies(depICAO, destICAO, routeData.waypoints);
            renderATCFrequencies(frequencies);

            // Update altimeter from departure METAR
            const depMetar = metarData[depICAO];
            if (depMetar && depMetar.altimeter) {
                const altimeterValue = document.getElementById('atcAltimeterValue');
                if (altimeterValue) {
                    altimeterValue.textContent = depMetar.altimeter.toFixed(2);
                }
            }

            // Update fuel meter
            updateATCFuelMeter(routeData);

            // Start ATC simulation (auto-play)
            startATCSimulation(depICAO, destICAO);

            // Show the panel
            const panel = document.getElementById('atcRadioPanel');
            if (panel) {
                panel.classList.add('visible');
            }
        }

        // Update fuel meter visualization
        function updateATCFuelMeter(routeData) {
            const fuelLevel = document.getElementById('atcFuelLevel');
            if (!fuelLevel || !routeData.fuelPlan) return;

            const tankCapacity = routeData.fuelPlan.tankCapacity || 92;
            const totalFuelNeeded = routeData.fuelPlan.total || 0;

            // Calculate fuel percentage (assuming we start with full tank)
            // This shows how much of our tank we'll use
            const fuelUsagePercent = Math.min(100, (totalFuelNeeded / tankCapacity) * 100);
            const remainingPercent = 100 - fuelUsagePercent;

            // Set the level
            fuelLevel.style.width = `${remainingPercent}%`;

            // Update color class based on remaining fuel
            fuelLevel.classList.remove('high', 'medium', 'low');
            if (remainingPercent > 50) {
                fuelLevel.classList.add('high');
            } else if (remainingPercent > 25) {
                fuelLevel.classList.add('medium');
            } else {
                fuelLevel.classList.add('low');
            }
        }

        // Toggle ATC panel visibility
        function toggleATCPanel() {
            const panel = document.getElementById('atcRadioPanel');
            const btn = document.getElementById('atcPanelBtn');
            if (panel) {
                const isHidden = panel.classList.toggle('hidden');
                document.body.classList.toggle('atc-panel-open', !isHidden);
                if (btn) btn.classList.toggle('active', !isHidden);
                // Store state
                localStorage.setItem('atcPanelVisible', !isHidden);
            }
        }

        // Setup scroll fade indicators for ATC transcription
        function setupATCScrollFades() {
            const transcription = document.getElementById('atcTranscription');
            const fadeTop = document.getElementById('atcScrollFadeTop');
            const fadeBottom = document.getElementById('atcScrollFadeBottom');

            if (!transcription || !fadeTop || !fadeBottom) return;

            function updateScrollFades() {
                const { scrollTop, scrollHeight, clientHeight } = transcription;
                const hasOverflow = scrollHeight > clientHeight;
                const atTop = scrollTop <= 5;
                const atBottom = scrollTop + clientHeight >= scrollHeight - 5;

                // Show top fade when scrolled down and there's content above
                fadeTop.classList.toggle('visible', hasOverflow && !atTop);
                // Show bottom fade when there's content below
                fadeBottom.classList.toggle('visible', hasOverflow && !atBottom);
            }

            transcription.addEventListener('scroll', updateScrollFades);
            // Initial check
            updateScrollFades();
            // Also check when content might change
            const observer = new MutationObserver(updateScrollFades);
            observer.observe(transcription, { childList: true, subtree: true, characterData: true });
        }

        // Initialize ATC panel state from localStorage
        function initATCPanel() {
            const panel = document.getElementById('atcRadioPanel');
            const btn = document.getElementById('atcPanelBtn');
            const savedState = localStorage.getItem('atcPanelVisible');

            // Default to visible, or use saved state
            const shouldShow = savedState === null || savedState === 'true';
            if (panel) {
                panel.classList.toggle('hidden', !shouldShow);
                document.body.classList.toggle('atc-panel-open', shouldShow);
                if (btn) btn.classList.toggle('active', shouldShow);
            }

            // Setup scroll fade indicators
            setupATCScrollFades();
        }

        // ============================================
        // END ATC RADIO PANEL FUNCTIONS
        // ============================================

        // Helper function to programmatically enable an overlay
        function enableOverlay(overlayName) {
            if (overlayState[overlayName]) return; // Already enabled

            const btn = document.querySelector(`[data-overlay="${overlayName}"]`);
            if (btn) {
                toggleOverlay(btn);
            }
        }

        // Auto-enable relevant overlays based on detected hazards
        // All relevant hazard/avoidance overlays are enabled simultaneously
        function autoEnableHazardOverlays(hazards) {
            // Always enable core hazard overlays when a route is loaded
            // These are critical for flight safety awareness
            const hazardOverlays = ['turbulence', 'icing', 'terrain', 'airspace', 'visibility'];

            hazardOverlays.forEach(overlay => {
                enableOverlay(overlay);
            });

            // Additionally check for specific hazard types to ensure coverage
            if (hazards && hazards.length > 0) {
                const hazardTypes = new Set(hazards.map(h => h.type));

                // Enable winds if significant weather detected
                if (hazardTypes.has('weather') || hazardTypes.has('winds')) {
                    enableOverlay('winds');
                }

                // Enable ceiling overlay if low ceiling hazards
                if (hazardTypes.has('ceiling') || hazardTypes.has('weather')) {
                    enableOverlay('ceiling');
                }
            }
        }

        // Route overlays list
        const routeOverlaysList = ['terrain', 'turbulence', 'icing', 'airspace', 'visibility'];

        // Toggle route advisories overlays
        function toggleRouteOverlays() {
            const btn = document.getElementById('routeOverlaysBtn');

            if (!currentRoute.dep || !currentRoute.dest) {
                console.warn('No route loaded');
                return;
            }

            routeOverlaysActive = !routeOverlaysActive;

            if (routeOverlaysActive) {
                // Enable route-relevant overlays
                routeOverlaysList.forEach(overlay => {
                    enableOverlay(overlay);
                });

                // Force refresh overlays to apply route corridor filtering
                if (overlayState.terrain) createTerrainOverlay();
                if (overlayState.turbulence) createTurbulenceOverlay();
                if (overlayState.icing) createIcingOverlay();
                if (overlayState.airspace) createAirspaceOverlay();
                if (overlayState.conditions) createConditionsOverlay();

                // Zoom to fit the route with padding
                const depStation = currentRoute.dep;
                const destStation = currentRoute.dest;

                // Create bounds that include all waypoints
                const bounds = L.latLngBounds([
                    [depStation.lat, depStation.lon],
                    [destStation.lat, destStation.lon]
                ]);

                // Include custom waypoints if any
                if (customWaypoints && customWaypoints.length > 0) {
                    customWaypoints.forEach(wp => {
                        bounds.extend([wp.lat, wp.lon]);
                    });
                }

                // Include custom stops if any
                if (customStops && customStops.length > 0) {
                    customStops.forEach(stop => {
                        bounds.extend([stop.lat, stop.lon]);
                    });
                }

                // Fit map to route bounds with padding
                map.fitBounds(bounds, { padding: [50, 50] });

                // Update button state
                btn.classList.add('active');
                btn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                    Hide Route Advisories
                `;
            } else {
                // Disable route-relevant overlays
                routeOverlaysList.forEach(overlay => {
                    disableOverlay(overlay);
                });

                // Update button state
                btn.classList.remove('active');
                btn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                    Show Route Advisories
                `;
            }
        }

        // Helper function to programmatically disable an overlay
        function disableOverlay(overlayName) {
            if (!overlayState[overlayName]) return; // Already disabled

            const btn = document.querySelector(`[data-overlay="${overlayName}"]`);
            if (btn) {
                toggleOverlay(btn);
            }
        }

        // Route profile
        let routeLine = null;
        let routeSegments = [];
        let fuelStopMarkers = L.layerGroup().addTo(map);

        // Map route pulse animation state
        let mapPulseAnimationId = null;
        let mapPulsePosition = 0;
        let mapPulseLines = []; // Stores pulse polylines for each phase
        let mapRouteData = null; // Stores route coords and phase info for animation

        // ============================================
        // CUSTOM WAYPOINT DRAWING FUNCTIONS
        // ============================================

        function toggleWaypointMode() {
            const btn = document.getElementById('waypointModeBtn');
            const snapBtn = document.getElementById('snapModeBtn');
            const mapContainer = document.getElementById('map');

            // Check if route is loaded first
            if (!waypointMode && (!currentRoute.dep || !currentRoute.dest)) {
                alert('Please load a route first (enter FROM/TO airports and click Load Route)');
                return;
            }

            waypointMode = !waypointMode;

            if (waypointMode) {
                btn.classList.add('active');
                btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';
                mapContainer.classList.add('waypoint-mode');
                map.on('click', onMapClickWaypoint);
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>';
                mapContainer.classList.remove('waypoint-mode');
                map.off('click', onMapClickWaypoint);

                // Rebuild route with custom waypoints if any were added
                if (customWaypoints.length > 0) {
                    rebuildRouteWithWaypoints();
                }
            }
        }

        function toggleSnapMode() {
            const btn = document.getElementById('snapModeBtn');
            snapMode = !snapMode;

            if (snapMode) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }

        function onMapClickWaypoint(e) {
            let waypointLat = e.latlng.lat;
            let waypointLon = e.latlng.lng;
            let waypointName = `WPT${++waypointCounter}`;
            let isSnapped = false;

            // If snap mode is on, find nearest GA airport
            if (snapMode) {
                const nearestAirport = findNearestGAAirport(waypointLat, waypointLon);
                if (nearestAirport) {
                    waypointLat = nearestAirport.lat;
                    waypointLon = nearestAirport.lon;
                    waypointName = nearestAirport.id;
                    isSnapped = true;
                }
            }

            // Create waypoint object
            const waypoint = {
                name: waypointName,
                lat: waypointLat,
                lon: waypointLon,
                isSnapped: isSnapped,
                index: customWaypoints.length + 1
            };

            // Add to array
            customWaypoints.push(waypoint);

            // Create marker
            const markerIcon = L.divIcon({
                html: `<div class="custom-waypoint-marker ${isSnapped ? 'snapped' : ''}">${waypoint.index}</div>`,
                className: 'custom-waypoint-icon',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });

            const marker = L.marker([waypointLat, waypointLon], {
                icon: markerIcon,
                draggable: false
            }).addTo(map);

            // Add tooltip
            marker.bindTooltip(`${waypointName}<br>${waypointLat.toFixed(3)}, ${waypointLon.toFixed(3)}`, {
                direction: 'top',
                className: 'waypoint-tooltip'
            });

            // Click to remove waypoint
            marker.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
                removeWaypoint(waypoint, marker);
            });

            waypointMarkers.push({ waypoint, marker });

            // Update preview line
            updateWaypointPreviewLine();
        }

        function findNearestGAAirport(lat, lon) {
            let nearest = null;
            let nearestDist = Infinity;
            const maxDistNM = 50; // 50nm threshold

            // Use haversine formula for accurate distance in nautical miles
            const R = 3440.065; // Earth radius in nautical miles

            metarStations.forEach(station => {
                const lat1 = lat * Math.PI / 180;
                const lat2 = station.lat * Math.PI / 180;
                const dLat = (station.lat - lat) * Math.PI / 180;
                const dLon = (station.lon - lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1) * Math.cos(lat2) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const distNM = R * c;

                if (distNM < nearestDist && distNM < maxDistNM) {
                    nearestDist = distNM;
                    nearest = station;
                }
            });

            return nearest;
        }

        function removeWaypoint(waypoint, marker) {
            // Remove from array
            const idx = customWaypoints.findIndex(w => w.name === waypoint.name && w.index === waypoint.index);
            if (idx > -1) {
                customWaypoints.splice(idx, 1);
            }

            // Remove marker
            map.removeLayer(marker);
            waypointMarkers = waypointMarkers.filter(m => m.waypoint !== waypoint);

            // Re-index remaining waypoints
            customWaypoints.forEach((wp, i) => {
                wp.index = i + 1;
            });

            // Update markers with new indices
            waypointMarkers.forEach((m, i) => {
                const newIcon = L.divIcon({
                    html: `<div class="custom-waypoint-marker ${m.waypoint.isSnapped ? 'snapped' : ''}">${i + 1}</div>`,
                    className: 'custom-waypoint-icon',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                m.marker.setIcon(newIcon);
                m.waypoint.index = i + 1;
            });

            // Update preview line
            updateWaypointPreviewLine();
        }

        function clearCustomWaypoints() {
            // Remove all markers
            waypointMarkers.forEach(m => map.removeLayer(m.marker));
            waypointMarkers = [];
            customWaypoints = [];
            waypointCounter = 0;

            // Remove preview line
            if (waypointPreviewLine) {
                map.removeLayer(waypointPreviewLine);
                waypointPreviewLine = null;
            }
        }

        function updateWaypointPreviewLine() {
            // Remove existing preview
            if (waypointPreviewLine) {
                map.removeLayer(waypointPreviewLine);
            }

            if (!currentRoute.dep || !currentRoute.dest) return;

            // Build coordinate array: dep -> waypoints -> dest
            const coords = [
                [currentRoute.dep.lat, currentRoute.dep.lon],
                ...customWaypoints.map(wp => [wp.lat, wp.lon]),
                [currentRoute.dest.lat, currentRoute.dest.lon]
            ];

            // Draw dashed preview line (dark grey in light mode, white in dark mode)
            waypointPreviewLine = L.polyline(coords, {
                color: isLightMode ? '#374151' : '#ffffff',
                weight: 2,
                opacity: isLightMode ? 0.8 : 0.6,
                dashArray: '8, 8',
                className: 'waypoint-preview-line'
            }).addTo(map);

            // Bring waypoint markers to front
            waypointMarkers.forEach(m => m.marker.bringToFront());

            // Update profile canvas to reflect waypoint changes in real-time
            drawProfile(currentRoute.dep, currentRoute.dest);
        }

        function rebuildRouteWithWaypoints() {
            rebuildFullRoute();
        }

        // Unified route rebuild function that handles both waypoints and stops
        function rebuildFullRoute() {
            if (!currentRoute.dep || !currentRoute.dest) return;

            const depLat = currentRoute.dep.lat;
            const depLon = currentRoute.dep.lon;
            const destLat = currentRoute.dest.lat;
            const destLon = currentRoute.dest.lon;
            const routeVecLat = destLat - depLat;
            const routeVecLon = destLon - depLon;
            const routeLenSq = routeVecLat * routeVecLat + routeVecLon * routeVecLon;

            // Sort waypoints by projection along route
            customWaypoints.sort((a, b) => {
                const projA = routeLenSq > 0 ? ((a.lat - depLat) * routeVecLat + (a.lon - depLon) * routeVecLon) / routeLenSq : 0;
                const projB = routeLenSq > 0 ? ((b.lat - depLat) * routeVecLat + (b.lon - depLon) * routeVecLon) / routeLenSq : 0;
                return projA - projB;
            });

            // Sort stops by projection along route
            customStops.sort((a, b) => {
                const projA = routeLenSq > 0 ? ((a.lat - depLat) * routeVecLat + (a.lon - depLon) * routeVecLon) / routeLenSq : 0;
                const projB = routeLenSq > 0 ? ((b.lat - depLat) * routeVecLat + (b.lon - depLon) * routeVecLon) / routeLenSq : 0;
                return projA - projB;
            });

            // Calculate total distance through all points
            let totalDistance = 0;
            const R = 3440.065; // Earth radius in NM

            const allPoints = [
                currentRoute.dep,
                ...customWaypoints.map(wp => ({ lat: wp.lat, lon: wp.lon, name: wp.name })),
                ...customStops.map(s => ({ lat: s.lat, lon: s.lon, name: s.id })),
                currentRoute.dest
            ];

            // Sort all points by projection along route
            const middlePoints = allPoints.slice(1, -1);
            middlePoints.sort((a, b) => {
                const projA = routeLenSq > 0 ? ((a.lat - depLat) * routeVecLat + (a.lon - depLon) * routeVecLon) / routeLenSq : 0;
                const projB = routeLenSq > 0 ? ((b.lat - depLat) * routeVecLat + (b.lon - depLon) * routeVecLon) / routeLenSq : 0;
                return projA - projB;
            });

            const sortedPoints = [currentRoute.dep, ...middlePoints, currentRoute.dest];

            for (let i = 0; i < sortedPoints.length - 1; i++) {
                const p1 = sortedPoints[i];
                const p2 = sortedPoints[i + 1];
                const lat1 = p1.lat * Math.PI / 180;
                const lat2 = p2.lat * Math.PI / 180;
                const dLat = (p2.lat - p1.lat) * Math.PI / 180;
                const dLon = (p2.lon - p1.lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1) * Math.cos(lat2) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                totalDistance += R * c;
            }

            // Calculate enhanced route with both waypoints and stops
            const routeData = calculateEnhancedRoute(currentRoute.dep, currentRoute.dest, totalDistance, customWaypoints, customStops);
            currentRouteData = routeData; // Store for altitude filtering

            // Redraw profile AFTER route calculation so it has avoidance waypoints
            drawProfile(currentRoute.dep, currentRoute.dest);

            // Update displays
            updateTripSummary(routeData);
            drawEnhancedRoute(routeData, currentRoute.dep, currentRoute.dest, totalDistance, customWaypoints, customStops);

            // Remove preview line since actual route is now drawn
            if (waypointPreviewLine) {
                map.removeLayer(waypointPreviewLine);
                waypointPreviewLine = null;
            }
        }

        // ============================================
        // END WAYPOINT FUNCTIONS
        // ============================================

        // ============================================
        // CUSTOM STOP (LANDING) FUNCTIONS
        // ============================================

        function toggleStopMode() {
            const btn = document.getElementById('stopModeBtn');
            const mapContainer = document.getElementById('map');

            // Check if route is loaded first
            if (!stopMode && (!currentRoute.dep || !currentRoute.dest)) {
                alert('Please load a route first (enter FROM/TO airports and click Load Route)');
                return;
            }

            // Exit waypoint mode if active
            if (waypointMode) {
                toggleWaypointMode();
            }

            stopMode = !stopMode;

            if (stopMode) {
                btn.classList.add('active');
                btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';
                mapContainer.classList.add('stop-mode');
                map.on('click', onMapClickStop);
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><rect x="9" y="9" width="6" height="6" rx="1"/></svg>';
                mapContainer.classList.remove('stop-mode');
                map.off('click', onMapClickStop);

                // Rebuild route with stops if any were added
                if (customStops.length > 0) {
                    rebuildRouteWithStops();
                }
            }
        }

        function onMapClickStop(e) {
            // Stops must snap to an airport (can't land in a field)
            const nearestAirport = findNearestGAAirport(e.latlng.lat, e.latlng.lng);

            if (!nearestAirport) {
                alert('No airport found within 50nm. Stops must be at airports.');
                return;
            }

            // Check if this airport is already a stop
            if (customStops.some(s => s.id === nearestAirport.id)) {
                alert(`${nearestAirport.id} is already a stop on this route.`);
                return;
            }

            // Create stop object
            const stop = {
                id: nearestAirport.id,
                name: nearestAirport.name || nearestAirport.id,
                lat: nearestAirport.lat,
                lon: nearestAirport.lon,
                index: customStops.length + 1,
                isStop: true  // Flag to distinguish from regular waypoints
            };

            // Add to array
            customStops.push(stop);

            // Create marker with landing icon
            const markerIcon = L.divIcon({
                html: `<div class="custom-stop-marker">${stop.index}</div>`,
                className: 'custom-stop-icon',
                iconSize: [28, 28],
                iconAnchor: [14, 14]
            });

            const marker = L.marker([stop.lat, stop.lon], {
                icon: markerIcon,
                draggable: false
            }).addTo(map);

            // Add tooltip
            marker.bindTooltip(`<b>STOP ${stop.index}: ${stop.id}</b><br>${stop.name}<br>Landing & Takeoff`, {
                direction: 'top',
                className: 'stop-tooltip'
            });

            // Click to remove stop
            marker.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
                removeStop(stop, marker);
            });

            stopMarkers.push({ stop, marker });

            // Update route immediately with new stop
            rebuildRouteWithStops();
        }

        function removeStop(stop, marker) {
            // Remove from array
            const idx = customStops.findIndex(s => s.id === stop.id);
            if (idx > -1) {
                customStops.splice(idx, 1);
            }

            // Remove marker
            map.removeLayer(marker);
            stopMarkers = stopMarkers.filter(m => m.stop !== stop);

            // Re-index remaining stops
            customStops.forEach((s, i) => {
                s.index = i + 1;
            });

            // Update markers with new indices
            stopMarkers.forEach((m, i) => {
                const newIcon = L.divIcon({
                    html: `<div class="custom-stop-marker">${i + 1}</div>`,
                    className: 'custom-stop-icon',
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                });
                m.marker.setIcon(newIcon);
                m.stop.index = i + 1;
            });

            // Rebuild route with remaining stops (or reload original if none left)
            if (customStops.length > 0) {
                rebuildRouteWithStops();
            } else {
                // No stops left - reload the direct route
                loadRoute();
            }
        }

        function clearCustomStops() {
            // Remove all stop markers
            stopMarkers.forEach(m => map.removeLayer(m.marker));
            stopMarkers = [];
            customStops = [];
            stopCounter = 0;
        }

        function updateStopPreviewLine() {
            // Remove existing preview
            if (waypointPreviewLine) {
                map.removeLayer(waypointPreviewLine);
            }

            if (!currentRoute.dep || !currentRoute.dest) return;

            // Build coordinate array: dep -> stops (sorted by projection along route) -> dest
            // Project each stop onto the dep->dest line and sort by that projection
            const depLat = currentRoute.dep.lat;
            const depLon = currentRoute.dep.lon;
            const destLat = currentRoute.dest.lat;
            const destLon = currentRoute.dest.lon;
            const routeVecLat = destLat - depLat;
            const routeVecLon = destLon - depLon;
            const routeLenSq = routeVecLat * routeVecLat + routeVecLon * routeVecLon;

            const sortedStops = [...customStops].sort((a, b) => {
                // Project stop onto route vector (dot product / length^2 gives normalized position)
                const projA = routeLenSq > 0 ? ((a.lat - depLat) * routeVecLat + (a.lon - depLon) * routeVecLon) / routeLenSq : 0;
                const projB = routeLenSq > 0 ? ((b.lat - depLat) * routeVecLat + (b.lon - depLon) * routeVecLon) / routeLenSq : 0;
                return projA - projB;
            });

            const coords = [
                [currentRoute.dep.lat, currentRoute.dep.lon],
                ...sortedStops.map(s => [s.lat, s.lon]),
                [currentRoute.dest.lat, currentRoute.dest.lon]
            ];

            // Draw dashed preview line (blue for stops)
            waypointPreviewLine = L.polyline(coords, {
                color: '#3b82f6',
                weight: 2,
                opacity: 0.7,
                dashArray: '8, 8',
                className: 'stop-preview-line'
            }).addTo(map);

            // Bring stop markers to front
            stopMarkers.forEach(m => m.marker.bringToFront());

            // Update profile canvas to reflect stop changes in real-time
            drawProfile(currentRoute.dep, currentRoute.dest);
        }

        function rebuildRouteWithStops() {
            rebuildFullRoute();
        }

        // ============================================
        // END STOP FUNCTIONS
        // ============================================

        async function loadRoute() {
            const departure = document.getElementById('departure').value.toUpperCase();
            const destination = document.getElementById('destination').value.toUpperCase();

            if (!departure || !destination) return;

            // Clear any custom waypoints and stops from previous route
            clearCustomWaypoints();
            clearCustomStops();

            // Reset waypoint mode UI if active
            if (waypointMode) {
                waypointMode = false;
                const btn = document.getElementById('waypointModeBtn');
                btn.classList.remove('active');
                btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>';
                document.getElementById('map').classList.remove('waypoint-mode');
                map.off('click', onMapClickWaypoint);
            }

            // Reset route overlays button state
            routeOverlaysActive = false;
            const routeOverlaysBtn = document.getElementById('routeOverlaysBtn');
            if (routeOverlaysBtn) {
                routeOverlaysBtn.classList.remove('active');
                routeOverlaysBtn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                    Show Route Advisories
                `;
            }

            // Reset stop mode UI if active
            if (stopMode) {
                stopMode = false;
                const btn = document.getElementById('stopModeBtn');
                btn.classList.remove('active');
                btn.textContent = '+ Stop';
                document.getElementById('map').classList.remove('stop-mode');
                map.off('click', onMapClickStop);
            }

            // Wait for airport database if still loading
            if (!stationsDataLoaded) {
                showLoading(50);
                // Wait for the preload to complete
                const waitForAirports = () => {
                    return new Promise((resolve) => {
                        const checkLoaded = () => {
                            if (stationsDataLoaded) {
                                resolve();
                            } else {
                                setTimeout(checkLoaded, 100);
                            }
                        };
                        checkLoaded();
                    });
                };
                waitForAirports().then(() => {
                    hideLoading();
                    loadRoute(); // Retry now that airports are loaded
                });
                return;
            }

            // Find station coordinates
            const depStation = findAirportStation(departure);
            const destStation = findAirportStation(destination);

            if (!depStation || !destStation) {
                const missing = !depStation ? departure : destination;
                alert(`Airport "${missing}" not found. Try ICAO codes (KLAX, KSBA) or FAA codes (LAX, SBA). Database includes 20,000+ US airports.`);
                return;
            }

            // Store current route
            currentRoute.dep = depStation;
            currentRoute.dest = destStation;

            // Update flight automation buttons
            updateAutomationButtons();

            // Refresh terrain overlay if active (now route-aware)
            if (overlayState.terrain) {
                createTerrainOverlay();
            }

            // Calculate distance for trip summary
            const R = 3440.065; // Earth radius in nautical miles
            const dLat = (destStation.lat - depStation.lat) * Math.PI / 180;
            const dLon = (destStation.lon - depStation.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(depStation.lat * Math.PI / 180) * Math.cos(destStation.lat * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const distance = R * c;

            // Auto-load airways data for route optimization (non-blocking)
            if (!airwaysLoaded && !airwaysLoading) {
                airwaysLoading = true;
                fetchAirways().then(() => {
                    airwaysLoading = false;
                    // Re-calculate route with airways data now available
                    if (currentRoute.dep && currentRoute.dest) {
                        const newRouteData = calculateEnhancedRoute(
                            currentRoute.dep, currentRoute.dest, distance,
                            customWaypoints, customStops
                        );
                        currentRouteData = newRouteData;
                        updateTripSummary(newRouteData);
                        drawProfile(currentRoute.dep, currentRoute.dest); // Redraw with updated route
                        console.log('Route updated with airways data');
                    }
                });
            }

            // Calculate enhanced route and update trip summary
            const routeData = calculateEnhancedRoute(depStation, destStation, distance);
            currentRouteData = routeData; // Store for altitude filtering
            updateTripSummary(routeData);

            // Redraw profile now that we have avoidance waypoints in currentRouteData
            drawProfile(depStation, destStation);

            // Draw the enhanced route on map
            drawEnhancedRoute(routeData, depStation, destStation, distance);
        }

        // Draw enhanced route with high-resolution line and optional fuel stops
        function drawEnhancedRoute(routeData, depStation, destStation, distance, customWaypointsInput = [], stopsInput = []) {
            // Clear existing route elements
            if (routeLine) {
                map.removeLayer(routeLine);
            }
            routeSegments.forEach(seg => map.removeLayer(seg));
            routeSegments = [];
            fuelStopMarkers.clearLayers();
            stopMapRoutePulse();

            // Helper to offset coordinates for 3D shadow/highlight effect
            function offsetCoords(coords, latOffset) {
                return coords.map(c => [c[0] + latOffset, c[1]]);
            }

            // Bring custom waypoint markers to front after clearing
            if (waypointMarkers && waypointMarkers.length > 0) {
                setTimeout(() => {
                    waypointMarkers.forEach(m => m.marker.bringToFront());
                }, 100);
            }

            const waypoints = routeData.waypoints;
            console.log('drawEnhancedRoute waypoints:', waypoints.map(wp => ({ name: wp.name, type: wp.type, lat: wp.lat, lon: wp.lon })));
            if (!waypoints || waypoints.length < 2) return;

            // Generate high-resolution route coordinates through waypoints
            const highResCoords = [];
            const segmentInfo = []; // Store info for each segment

            for (let i = 0; i < waypoints.length - 1; i++) {
                const wp1 = waypoints[i];
                const wp2 = waypoints[i + 1];

                // Calculate segment distance
                const segDist = Math.sqrt(
                    Math.pow(wp2.lat - wp1.lat, 2) + Math.pow(wp2.lon - wp1.lon, 2)
                );

                // More points for longer segments (high resolution)
                const numPoints = Math.max(20, Math.floor(segDist * 50));

                for (let j = 0; j <= numPoints; j++) {
                    const t = j / numPoints;
                    const lat = wp1.lat + t * (wp2.lat - wp1.lat);
                    const lon = wp1.lon + t * (wp2.lon - wp1.lon);
                    highResCoords.push([lat, lon]);

                    // Store segment info for hover
                    const progressAlongRoute = (wp1.distance + t * (wp2.distance - wp1.distance)) / distance;
                    segmentInfo.push({
                        lat, lon,
                        distance: Math.round(wp1.distance + t * (wp2.distance - wp1.distance)),
                        fromWaypoint: wp1.name,
                        toWaypoint: wp2.name,
                        progress: progressAlongRoute
                    });
                }
            }

            // Determine flight phase colors for the route
            const climbEnd = 0.15;
            const descentStart = 0.85;

            // Draw route as colored segments by phase
            let currentPhase = 'climb';
            let segmentCoords = [];
            let lastPhase = 'climb';

            highResCoords.forEach((coord, idx) => {
                const progress = idx / highResCoords.length;

                // Determine current phase
                if (progress < climbEnd) {
                    currentPhase = 'climb';
                } else if (progress > descentStart) {
                    currentPhase = 'descent';
                } else {
                    currentPhase = 'cruise';
                }

                segmentCoords.push(coord);

                // When phase changes or at end, draw segment
                if (currentPhase !== lastPhase || idx === highResCoords.length - 1) {
                    const phaseColor = lastPhase === 'climb' ? '#22c55e' :
                                      lastPhase === 'descent' ? '#f59e0b' : '#6b7280';

                    // Main colored segment (no gradients on map)
                    const segment = L.polyline(segmentCoords, {
                        color: phaseColor,
                        weight: 4,
                        opacity: 0.9,
                        lineCap: 'round',
                        lineJoin: 'round'
                    }).addTo(map);
                    routeSegments.push(segment);

                    segmentCoords = [coord]; // Start new segment with current point
                    lastPhase = currentPhase;
                }
            });

            // Fit map to route
            const bounds = L.latLngBounds(highResCoords);
            map.fitBounds(bounds, { padding: [50, 50] });

            // Start map route pulse animation
            startMapRoutePulse(highResCoords, climbEnd, descentStart);

            // Add diversion waypoint markers for restricted airspace avoidance
            const diversionWaypoints = waypoints.filter(wp => wp.type === 'divert');
            diversionWaypoints.forEach((wp, idx) => {
                const diversionIcon = L.divIcon({
                    html: `<div style="
                        background: rgba(239, 68, 68, 0.9);
                        color: white;
                        width: 20px;
                        height: 20px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 9px;
                        font-weight: bold;
                        border: 2px solid #fca5a5;
                        box-shadow: 0 2px 6px rgba(239, 68, 68, 0.5);
                    ">D${idx + 1}</div>`,
                    className: 'diversion-marker',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });

                const marker = L.marker([wp.lat, wp.lon], { icon: diversionIcon }).addTo(map);
                marker.bindTooltip(`
                    <div style="font-family: system-ui; font-size: 11px;">
                        <div style="font-weight: 600; color: #ef4444; margin-bottom: 4px;">
                            Diversion Waypoint
                        </div>
                        <div><b>${wp.name}</b></div>
                        <div style="font-size: 10px; color: #9ca3af; margin-top: 2px;">${wp.reason || 'Airspace avoidance'}</div>
                    </div>
                `, { direction: 'top', offset: [0, -10] });
                fuelStopMarkers.addLayer(marker); // Reuse fuel stop layer for cleanup
            });

            // Add SID (departure procedure) waypoint markers
            const sidWaypoints = waypoints.filter(wp => wp.type === 'sid');
            sidWaypoints.forEach((wp, idx) => {
                const sidIcon = L.divIcon({
                    html: `<div style="
                        background: rgba(34, 197, 94, 0.9);
                        color: white;
                        width: 22px;
                        height: 22px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 8px;
                        font-weight: bold;
                        border: 2px solid rgba(134, 239, 172, 0.8);
                        box-shadow: 0 2px 6px rgba(34, 197, 94, 0.5);
                    ">${idx + 1}</div>`,
                    className: 'sid-marker',
                    iconSize: [22, 22],
                    iconAnchor: [11, 11]
                });

                const marker = L.marker([wp.lat, wp.lon], { icon: sidIcon }).addTo(map);
                marker.bindTooltip(`
                    <div style="font-family: system-ui; font-size: 11px;">
                        <div style="font-weight: 600; color: #22c55e; margin-bottom: 4px;">
                            Departure Procedure
                        </div>
                        <div><b>${wp.name}</b></div>
                        <div style="font-size: 10px; color: #9ca3af; margin-top: 2px;">
                            ${wp.description || wp.procedureName || 'SID waypoint'}
                        </div>
                        ${wp.altitude ? `<div style="font-size: 10px; color: #86efac; margin-top: 2px;">ALT: ${wp.altitude.toLocaleString()} ft</div>` : ''}
                    </div>
                `, { direction: 'top', offset: [0, -10] });
                fuelStopMarkers.addLayer(marker);
            });

            // Add STAR (arrival procedure) waypoint markers
            const starWaypoints = waypoints.filter(wp => wp.type === 'star');
            starWaypoints.forEach((wp, idx) => {
                const starIcon = L.divIcon({
                    html: `<div style="
                        background: rgba(245, 158, 11, 0.9);
                        color: white;
                        width: 22px;
                        height: 22px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 8px;
                        font-weight: bold;
                        border: 2px solid rgba(253, 224, 71, 0.8);
                        box-shadow: 0 2px 6px rgba(245, 158, 11, 0.5);
                    ">${idx + 1}</div>`,
                    className: 'star-marker',
                    iconSize: [22, 22],
                    iconAnchor: [11, 11]
                });

                const marker = L.marker([wp.lat, wp.lon], { icon: starIcon }).addTo(map);
                marker.bindTooltip(`
                    <div style="font-family: system-ui; font-size: 11px;">
                        <div style="font-weight: 600; color: #f59e0b; margin-bottom: 4px;">
                            Arrival Procedure
                        </div>
                        <div><b>${wp.name}</b></div>
                        <div style="font-size: 10px; color: #9ca3af; margin-top: 2px;">
                            ${wp.description || wp.procedureName || 'STAR waypoint'}
                        </div>
                        ${wp.altitude ? `<div style="font-size: 10px; color: #fde047; margin-top: 2px;">ALT: ${wp.altitude.toLocaleString()} ft</div>` : ''}
                    </div>
                `, { direction: 'top', offset: [0, -10] });
                fuelStopMarkers.addLayer(marker);
            });

            // Add fuel stop markers (using calculated stops from fuelPlan)
            if (routeData.fuelPlan.fuelStops && routeData.fuelPlan.fuelStops.length > 0) {
                routeData.fuelPlan.fuelStops.forEach((stop, idx) => {
                    const fuelIcon = L.divIcon({
                        html: `<div style="
                            background: #f59e0b;
                            color: white;
                            width: 26px;
                            height: 26px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 12px;
                            font-weight: bold;
                            border: 3px solid white;
                            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.6);
                            cursor: pointer;
                        ">F${idx + 1}</div>`,
                        className: 'fuel-stop-marker-icon',
                        iconSize: [26, 26],
                        iconAnchor: [13, 13]
                    });

                    const fuelMarker = L.marker([stop.station.lat, stop.station.lon], { icon: fuelIcon });

                    // Find leg info for this stop
                    const legBefore = routeData.fuelPlan.legs ? routeData.fuelPlan.legs[idx] : null;

                    fuelMarker.bindTooltip(`
                        <div style="font-family: system-ui; font-size: 12px; min-width: 160px;">
                            <div style="font-weight: 700; color: #f59e0b; font-size: 14px; margin-bottom: 4px;">
                                Fuel Stop ${idx + 1}
                            </div>
                            <div style="font-weight: 600; font-size: 13px; margin-bottom: 6px;">${stop.station.id}</div>
                            <div style="font-size: 11px; color: rgba(255,255,255,0.8); margin-bottom: 4px;">
                                ${stop.station.name || ''}
                            </div>
                            <div style="font-size: 11px; color: rgba(255,255,255,0.6);">
                                <div style="margin-bottom: 2px;">
                                    ${stop.distanceFromDep} nm from departure
                                </div>
                                ${stop.deviation > 0 ? `<div style="color: #fcd34d;">+${stop.deviation} nm deviation</div>` : ''}
                                ${stop.longestRunway > 0 ? `<div>Runway: ${stop.longestRunway.toLocaleString()} ft</div>` : ''}
                            </div>
                        </div>
                    `, { sticky: true, direction: 'top', offset: [0, -15] });

                    fuelStopMarkers.addLayer(fuelMarker);
                });
            }

            // Setup journey marker hover for the route
            setupRouteHover(routeData, highResCoords, segmentInfo);
        }

        // Helper: Find nearest point index in coords array
        function findNearestPointIndex(latlng, coords) {
            let nearestIdx = 0;
            let nearestDist = Infinity;
            coords.forEach((coord, idx) => {
                const dist = Math.sqrt(
                    Math.pow(coord[0] - latlng.lat, 2) +
                    Math.pow(coord[1] - latlng.lng, 2)
                );
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestIdx = idx;
                }
            });
            return nearestIdx;
        }

        // Helper: Get altitude at route progress
        function getAltitudeAtProgress(progress, cruiseAlt) {
            if (progress < 0.15) {
                return (progress / 0.15) * cruiseAlt;
            } else if (progress > 0.85) {
                return ((1 - progress) / 0.15) * cruiseAlt;
            }
            return cruiseAlt;
        }

        // Journey marker for map (follows cursor along route)
        let mapJourneyMarker = null;
        let mapJourneyTooltip = null;
        let currentHighResCoords = null;
        let currentSegmentInfo = null;

        function initMapJourneyMarker(phaseColor, pulseColor) {
            // Create the journey marker dot with phase-appropriate colors
            const markerIcon = L.divIcon({
                html: `<div class="map-journey-dot">
                    <div class="map-journey-dot-inner" style="border-color: ${phaseColor}"></div>
                    <div class="map-journey-dot-pulse" style="background: ${pulseColor}"></div>
                </div>`,
                className: 'map-journey-marker',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            mapJourneyMarker = L.marker([0, 0], {
                icon: markerIcon,
                interactive: false,
                zIndexOffset: 1000
            });
        }

        // Update journey marker on route hover
        function updateMapJourneyMarker(latlng, routeData, highResCoords, segmentInfo) {
            // Find nearest point on route
            const nearestIdx = findNearestPointIndex(latlng, highResCoords);
            const nearestCoord = highResCoords[nearestIdx];
            const info = segmentInfo[nearestIdx];

            if (!info) return;

            // Check if cursor is close enough to route (within ~0.5 degrees)
            const distToRoute = Math.sqrt(
                Math.pow(nearestCoord[0] - latlng.lat, 2) +
                Math.pow(nearestCoord[1] - latlng.lng, 2)
            );

            if (distToRoute > 0.5) {
                hideMapJourneyMarker();
                return;
            }

            // Calculate flight info
            const altitude = getAltitudeAtProgress(info.progress, routeData.cruiseAltitude);
            const phase = info.progress < 0.15 ? 'Climb' :
                         info.progress > 0.85 ? 'Descent' : 'Cruise';
            const phaseColor = phase === 'Climb' ? '#22c55e' :
                              phase === 'Descent' ? '#f59e0b' : '#6b7280';
            const pulseColor = phase === 'Climb' ? 'rgba(34, 197, 94, 0.4)' :
                              phase === 'Descent' ? 'rgba(245, 158, 11, 0.4)' : 'rgba(107, 114, 128, 0.4)';

            // Create or update marker with phase-appropriate color
            if (!mapJourneyMarker) {
                initMapJourneyMarker(phaseColor, pulseColor);
            } else {
                // Update marker icon with new color
                const markerIcon = L.divIcon({
                    html: `<div class="map-journey-dot">
                        <div class="map-journey-dot-inner" style="border-color: ${phaseColor}"></div>
                        <div class="map-journey-dot-pulse" style="background: ${pulseColor}"></div>
                    </div>`,
                    className: 'map-journey-marker',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                mapJourneyMarker.setIcon(markerIcon);
            }

            // Position marker at nearest route point
            mapJourneyMarker.setLatLng(nearestCoord);
            if (!map.hasLayer(mapJourneyMarker)) {
                mapJourneyMarker.addTo(map);
            }

            // Update or create tooltip
            const tooltipContent = `
                <div class="map-journey-tooltip">
                    <div class="mjt-header" style="color: ${phaseColor}">${phase}</div>
                    <div class="mjt-stats">
                        <div class="mjt-stat">
                            <span class="mjt-label">Alt</span>
                            <span class="mjt-value">FL${Math.round(altitude / 100)}</span>
                        </div>
                        <div class="mjt-stat">
                            <span class="mjt-label">Dist</span>
                            <span class="mjt-value">${info.distance} NM</span>
                        </div>
                    </div>
                </div>
            `;

            if (mapJourneyMarker.getTooltip()) {
                mapJourneyMarker.setTooltipContent(tooltipContent);
            } else {
                mapJourneyMarker.bindTooltip(tooltipContent, {
                    permanent: true,
                    direction: 'top',
                    offset: [0, -15],
                    className: 'map-journey-tooltip-container'
                });
            }
        }

        function hideMapJourneyMarker() {
            if (mapJourneyMarker && map.hasLayer(mapJourneyMarker)) {
                map.removeLayer(mapJourneyMarker);
            }
        }

        // Enhanced route drawing with journey marker support
        function setupRouteHover(routeData, highResCoords, segmentInfo) {
            currentRouteData = routeData;
            currentHighResCoords = highResCoords;
            currentSegmentInfo = segmentInfo;

            // Add mousemove handler to map for journey marker
            map.off('mousemove', onMapMouseMove);
            map.on('mousemove', onMapMouseMove);

            map.off('mouseout', onMapMouseOut);
            map.on('mouseout', onMapMouseOut);
        }

        function onMapMouseMove(e) {
            if (currentRouteData && currentHighResCoords && currentSegmentInfo) {
                updateMapJourneyMarker(e.latlng, currentRouteData, currentHighResCoords, currentSegmentInfo);
            }
        }

        function onMapMouseOut() {
            hideMapJourneyMarker();
        }

        // ==================== MAP ROUTE PULSE ANIMATION ====================
        let mapPulseGlowLine = null;
        let mapPulseCoreLine = null;
        let lastPulsePhase = null;

        // Interpolate a point along the route at a given progress (0-1)
        function interpolateRoutePoint(coords, progress) {
            const totalPoints = coords.length - 1;
            const exactIdx = progress * totalPoints;
            const idx = Math.floor(exactIdx);
            const frac = exactIdx - idx;

            if (idx >= totalPoints) return coords[totalPoints];
            if (idx < 0) return coords[0];

            const p1 = coords[idx];
            const p2 = coords[idx + 1];
            return [
                p1[0] + frac * (p2[0] - p1[0]),
                p1[1] + frac * (p2[1] - p1[1])
            ];
        }

        function animateMapRoutePulse() {
            if (!mapRouteData || !mapRouteData.coords || mapRouteData.coords.length < 2) {
                mapPulseAnimationId = requestAnimationFrame(animateMapRoutePulse);
                return;
            }

            // Smooth animation (~8 seconds per cycle)
            mapPulsePosition = (mapPulsePosition + 0.0015) % 1;

            const { coords, climbEnd, descentStart } = mapRouteData;
            const tailLength = 0.12;

            // Determine which phase we're in
            let currentPhase;
            if (mapPulsePosition < climbEnd) {
                currentPhase = 'climb';
            } else if (mapPulsePosition > descentStart) {
                currentPhase = 'descent';
            } else {
                currentPhase = 'cruise';
            }

            // Calculate pulse segment with interpolated endpoints
            const pulseHead = mapPulsePosition;
            const pulseTail = Math.max(0, pulseHead - tailLength);

            // Build smooth pulse path with interpolated points
            const numPulsePoints = 20;
            const pulseCoords = [];
            for (let i = 0; i <= numPulsePoints; i++) {
                const t = pulseTail + (pulseHead - pulseTail) * (i / numPulsePoints);
                pulseCoords.push(interpolateRoutePoint(coords, t));
            }

            if (pulseCoords.length < 2) {
                mapPulseAnimationId = requestAnimationFrame(animateMapRoutePulse);
                return;
            }

            // Get phase color
            const phaseColor = currentPhase === 'climb' ? '#22c55e' :
                              currentPhase === 'descent' ? '#f59e0b' : '#6b7280';

            // Update existing lines or create new ones
            if (mapPulseGlowLine && map.hasLayer(mapPulseGlowLine)) {
                mapPulseGlowLine.setLatLngs(pulseCoords);
                if (currentPhase !== lastPulsePhase) {
                    mapPulseGlowLine.setStyle({ color: phaseColor });
                }
            } else {
                mapPulseGlowLine = L.polyline(pulseCoords, {
                    color: phaseColor,
                    weight: 8,
                    opacity: 0.35,
                    lineCap: 'round',
                    lineJoin: 'round',
                    className: 'route-pulse'
                }).addTo(map);
            }

            if (mapPulseCoreLine && map.hasLayer(mapPulseCoreLine)) {
                mapPulseCoreLine.setLatLngs(pulseCoords);
            } else {
                mapPulseCoreLine = L.polyline(pulseCoords, {
                    color: '#ffffff',
                    weight: 3,
                    opacity: 0.8,
                    lineCap: 'round',
                    lineJoin: 'round',
                    className: 'route-pulse'
                }).addTo(map);
            }

            lastPulsePhase = currentPhase;
            mapPulseAnimationId = requestAnimationFrame(animateMapRoutePulse);
        }

        function startMapRoutePulse(highResCoords, climbEnd, descentStart) {
            // Stop any existing animation
            stopMapRoutePulse();

            // Store route data
            mapRouteData = {
                coords: highResCoords,
                climbEnd: climbEnd,
                descentStart: descentStart
            };

            // Start animation
            mapPulsePosition = 0;
            mapPulseAnimationId = requestAnimationFrame(animateMapRoutePulse);
        }

        function stopMapRoutePulse() {
            if (mapPulseAnimationId) {
                cancelAnimationFrame(mapPulseAnimationId);
                mapPulseAnimationId = null;
            }
            // Clear pulse lines
            if (mapPulseGlowLine && map.hasLayer(mapPulseGlowLine)) {
                map.removeLayer(mapPulseGlowLine);
            }
            if (mapPulseCoreLine && map.hasLayer(mapPulseCoreLine)) {
                map.removeLayer(mapPulseCoreLine);
            }
            mapPulseGlowLine = null;
            mapPulseCoreLine = null;
            mapPulseLines.forEach(line => {
                if (map.hasLayer(line)) map.removeLayer(line);
            });
            mapPulseLines = [];
            mapRouteData = null;
        }

        // ==================== FLIGHT PATH OPTIMIZER ====================
        // Hazard data for flight path optimization (accessible globally)
        const flightHazards = {
            icingZones: [
                { name: 'Northern Plains', polygon: [[46.5, -98.0], [47.2, -95.5], [46.8, -92.0], [44.5, -90.5], [42.5, -91.0], [41.8, -94.0], [42.2, -97.5], [44.0, -99.0], [46.5, -98.0]], intensity: 'Moderate', base: 8000, top: 22000 },
                { name: 'Northeast', polygon: [[44.5, -76.0], [45.0, -73.5], [43.8, -71.0], [41.5, -72.0], [40.0, -74.5], [40.5, -77.0], [42.0, -78.5], [44.5, -76.0]], intensity: 'Light', base: 10000, top: 18000 },
                { name: 'Pacific Northwest', polygon: [[49.0, -122.5], [48.5, -119.0], [46.5, -117.5], [44.5, -118.5], [44.0, -121.0], [45.5, -123.5], [47.5, -124.0], [49.0, -122.5]], intensity: 'Light-Moderate', base: 6000, top: 20000 },
                { name: 'Great Lakes', polygon: [[45.5, -86.0], [46.0, -83.5], [45.0, -81.0], [43.0, -80.5], [41.5, -82.5], [40.5, -86.0], [41.0, -89.0], [42.5, -90.0], [44.5, -88.0], [45.5, -86.0]], intensity: 'Moderate', base: 4000, top: 16000 },
                { name: 'Rocky Mountains', polygon: [[43.0, -108.5], [43.5, -105.0], [42.0, -102.5], [39.0, -102.5], [36.0, -104.5], [35.5, -108.0], [37.0, -110.0], [40.0, -110.0], [43.0, -108.5]], intensity: 'Light', base: 12000, top: 24000 },
            ],
            turbulenceZones: [
                { name: 'Rocky Mountain Wave', polygon: [[41.0, -107.5], [41.5, -104.5], [40.0, -102.5], [37.5, -103.0], [36.0, -105.0], [36.5, -108.0], [38.5, -108.5], [41.0, -107.5]], intensity: 'Moderate-Severe', base: 15000, top: 45000 },
                { name: 'Sierra Nevada', polygon: [[38.5, -120.5], [39.0, -118.0], [37.5, -116.0], [35.0, -116.5], [34.0, -118.0], [35.0, -120.0], [37.0, -121.0], [38.5, -120.5]], intensity: 'Moderate', base: 18000, top: 40000 },
                { name: 'Appalachian Ridges', polygon: [[38.0, -82.0], [37.5, -79.5], [35.5, -80.0], [33.5, -82.5], [32.5, -85.0], [34.0, -86.5], [36.5, -85.5], [38.0, -82.0]], intensity: 'Light-Moderate', base: 8000, top: 25000 },
                { name: 'Great Plains Jet', polygon: [[41.0, -101.0], [41.5, -96.0], [39.5, -93.5], [36.5, -94.5], [35.0, -97.5], [36.0, -101.5], [38.5, -102.5], [41.0, -101.0]], intensity: 'Light-Moderate', base: 30000, top: 42000 },
                { name: 'Gulf Coast Convective', polygon: [[32.0, -93.0], [32.5, -89.0], [31.0, -86.5], [29.0, -87.0], [28.0, -90.0], [29.0, -93.5], [31.0, -94.0], [32.0, -93.0]], intensity: 'Moderate', base: 10000, top: 35000 },
            ],
            restrictedAreas: [
                { name: 'R-2508 Complex', polygon: [[36.5, -118.5], [36.5, -116.5], [35.0, -116.5], [35.0, -117.5], [34.5, -117.5], [34.5, -118.5]], floor: 0, ceiling: 99999 },
                { name: 'R-4807 (Nellis Range)', polygon: [[38.0, -116.5], [38.0, -115.0], [36.5, -115.0], [36.5, -116.5]], floor: 0, ceiling: 99999 },
                { name: 'R-4809 (Nellis South)', polygon: [[36.5, -116.0], [36.5, -115.0], [35.5, -115.0], [35.5, -116.0]], floor: 0, ceiling: 50000 },
                { name: 'P-56A (White House)', polygon: [[38.905, -77.045], [38.905, -77.028], [38.890, -77.028], [38.890, -77.045]], floor: 0, ceiling: 18000 },
                { name: 'P-56B (Naval Observatory)', polygon: [[38.930, -77.075], [38.930, -77.058], [38.915, -77.058], [38.915, -77.075]], floor: 0, ceiling: 18000 },
            ]
        };

        // Helper function to calculate haversine distance in nautical miles
        function haversineDistanceNM(lat1, lon1, lat2, lon2) {
            const R = 3440.065; // Earth radius in nautical miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Calculate optimal flight path considering all hazards
        function calculateOptimalFlightPath(depStation, destStation, distance, terrainProfile, routeWaypoints = [], routeStops = []) {
            const numSamples = 50; // Number of waypoints along route
            const altitudeOptions = []; // Available altitudes to evaluate
            const AIRCRAFT_CEILING = 12500; // Max altitude for this aircraft
            for (let alt = 3000; alt <= AIRCRAFT_CEILING; alt += 500) {
                altitudeOptions.push(alt);
            }

            // Preferred cruise altitude range (most fuel efficient for GA piston)
            const optimalCruiseMin = 8000;
            const optimalCruiseMax = 12500;

            // Build full route path: dep -> (waypoints + stops sorted by position) -> dest
            // Combine waypoints and stops, sort by route position, then build path
            const allIntermediatePoints = [];

            if (routeWaypoints && routeWaypoints.length > 0) {
                routeWaypoints.forEach(wp => {
                    allIntermediatePoints.push({ lat: wp.lat, lon: wp.lon, name: wp.name, isStop: false });
                });
            }

            if (routeStops && routeStops.length > 0) {
                routeStops.forEach(stop => {
                    allIntermediatePoints.push({ lat: stop.lat, lon: stop.lon, name: stop.id, isStop: true });
                });
            }

            // Sort all intermediate points by projection along route direction
            if (allIntermediatePoints.length > 0) {
                const routeVecLat = destStation.lat - depStation.lat;
                const routeVecLon = destStation.lon - depStation.lon;
                const routeLenSq = routeVecLat * routeVecLat + routeVecLon * routeVecLon;

                allIntermediatePoints.sort((a, b) => {
                    const projA = routeLenSq > 0 ? ((a.lat - depStation.lat) * routeVecLat + (a.lon - depStation.lon) * routeVecLon) / routeLenSq : 0;
                    const projB = routeLenSq > 0 ? ((b.lat - depStation.lat) * routeVecLat + (b.lon - depStation.lon) * routeVecLon) / routeLenSq : 0;
                    return projA - projB;
                });
            }

            const routePath = [
                { lat: depStation.lat, lon: depStation.lon, name: depStation.id }
            ];
            allIntermediatePoints.forEach(point => {
                routePath.push({ lat: point.lat, lon: point.lon, name: point.name, isStop: point.isStop });
            });
            routePath.push({ lat: destStation.lat, lon: destStation.lon, name: destStation.id });

            // Calculate cumulative distances along route path
            const segmentDistances = [];
            let totalRouteDistance = 0;
            for (let i = 1; i < routePath.length; i++) {
                const p1 = routePath[i - 1];
                const p2 = routePath[i];
                const segDist = haversineDistanceNM(p1.lat, p1.lon, p2.lat, p2.lon);
                segmentDistances.push({ start: totalRouteDistance, end: totalRouteDistance + segDist, p1, p2 });
                totalRouteDistance += segDist;
            }

            // Use calculated distance if there are intermediate points, otherwise use route distance
            const hasIntermediatePoints = allIntermediatePoints.length > 0;
            const actualDistance = hasIntermediatePoints ? totalRouteDistance : distance;

            // Calculate stop positions as normalized t values from the route path
            // Since stops are now part of routePath, find their positions from segment endpoints
            const stopPositions = [];
            for (let i = 0; i < segmentDistances.length; i++) {
                const seg = segmentDistances[i];
                if (seg.p2.isStop) {
                    stopPositions.push({
                        t: Math.min(seg.end / actualDistance, 0.99),
                        lat: seg.p2.lat,
                        lon: seg.p2.lon,
                        id: seg.p2.name
                    });
                }
            }

            // Sample points along the route
            const waypoints = [];
            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples;
                const distNM = t * actualDistance;

                // Find which segment this distance falls into and interpolate position
                let lat, lon;
                if (routeWaypoints.length > 0) {
                    // Find the segment for this distance
                    let segment = segmentDistances[0];
                    for (const seg of segmentDistances) {
                        if (distNM >= seg.start && distNM <= seg.end) {
                            segment = seg;
                            break;
                        }
                    }
                    // Interpolate within segment
                    const segProgress = segment.end > segment.start ?
                        (distNM - segment.start) / (segment.end - segment.start) : 0;
                    lat = segment.p1.lat + segProgress * (segment.p2.lat - segment.p1.lat);
                    lon = segment.p1.lon + segProgress * (segment.p2.lon - segment.p1.lon);
                } else {
                    // Direct route
                    lat = depStation.lat + t * (destStation.lat - depStation.lat);
                    lon = depStation.lon + t * (destStation.lon - depStation.lon);
                }

                // Get terrain elevation at this point (from profile)
                const terrainIdx = Math.floor(t * (terrainProfile.length - 1));
                const terrainAlt = terrainProfile[terrainIdx] || 0;
                const minSafeAlt = Math.max(terrainAlt + 2000, 5000); // 2000ft AGL minimum

                // Evaluate each altitude option
                let bestAlt = optimalCruiseMin;
                let bestCost = Infinity;

                for (const alt of altitudeOptions) {
                    if (alt < minSafeAlt) continue; // Skip altitudes below terrain

                    let cost = 0;

                    // Base cost - prefer optimal cruise range
                    if (alt >= optimalCruiseMin && alt <= optimalCruiseMax) {
                        cost += 0; // Optimal range
                    } else if (alt < optimalCruiseMin) {
                        cost += (optimalCruiseMin - alt) / 1000 * 5; // Penalty for flying too low
                    } else {
                        cost += (alt - optimalCruiseMax) / 1000 * 3; // Smaller penalty for too high
                    }

                    // Check turbulence zones
                    for (const zone of flightHazards.turbulenceZones) {
                        if (pointInPolygon(lat, lon, zone.polygon) && alt >= zone.base && alt <= zone.top) {
                            if (zone.intensity.includes('Severe')) {
                                cost += 100; // Severe turbulence - heavy penalty
                            } else if (zone.intensity.includes('Moderate')) {
                                cost += 50; // Moderate turbulence
                            } else {
                                cost += 20; // Light turbulence
                            }
                        }
                    }

                    // Check icing zones
                    for (const zone of flightHazards.icingZones) {
                        if (pointInPolygon(lat, lon, zone.polygon) && alt >= zone.base && alt <= zone.top) {
                            if (zone.intensity.includes('Moderate')) {
                                cost += 40;
                            } else {
                                cost += 15;
                            }
                        }
                    }

                    // Check restricted/prohibited airspace
                    for (const zone of flightHazards.restrictedAreas) {
                        if (pointInPolygon(lat, lon, zone.polygon) && alt >= zone.floor && alt <= zone.ceiling) {
                            cost += 500; // Very high penalty - avoid at all costs
                        }
                    }

                    // Altitude change penalty (smoother is better)
                    if (waypoints.length > 0) {
                        const prevAlt = waypoints[waypoints.length - 1].altitude;
                        const altChange = Math.abs(alt - prevAlt);
                        cost += altChange / 1000 * 2; // Penalty for altitude changes
                    }

                    if (cost < bestCost) {
                        bestCost = cost;
                        bestAlt = alt;
                    }
                }

                // Check if this point is near a stop - force descent/landing pattern
                let isAtStop = false;
                let stopId = null;
                for (const stopPos of stopPositions) {
                    const tDiff = Math.abs(t - stopPos.t);
                    if (tDiff < 0.02) { // At stop location
                        isAtStop = true;
                        stopId = stopPos.id;
                        bestAlt = 0; // On the ground
                        break;
                    } else if (tDiff < 0.08 && t < stopPos.t) {
                        // Descending to stop
                        const descentProgress = 1 - (tDiff / 0.08);
                        bestAlt = Math.round(bestAlt * (1 - descentProgress));
                    } else if (tDiff < 0.08 && t > stopPos.t) {
                        // Climbing from stop
                        const climbProgress = 1 - (tDiff / 0.08);
                        bestAlt = Math.round(bestAlt * (1 - climbProgress));
                    }
                }

                waypoints.push({
                    t,
                    lat,
                    lon,
                    distNM,
                    altitude: bestAlt,
                    terrainAlt,
                    cost: bestCost,
                    isStop: isAtStop,
                    stopId: stopId
                });
            }

            // Smooth the altitude profile to avoid jagged changes
            const smoothedWaypoints = smoothAltitudeProfile(waypoints);

            // Add climb and descent phases
            return addClimbDescentPhases(smoothedWaypoints, distance);
        }

        // Smooth altitude profile using weighted moving average
        function smoothAltitudeProfile(waypoints) {
            const smoothed = [...waypoints];
            const windowSize = 5;

            for (let i = windowSize; i < waypoints.length - windowSize; i++) {
                // Don't smooth stop points or points near stops
                if (waypoints[i].isStop || waypoints[i].altitude === 0) {
                    continue;
                }

                // Check if any nearby point is a stop
                let nearStop = false;
                for (let j = -windowSize; j <= windowSize; j++) {
                    if (waypoints[i + j].isStop || waypoints[i + j].altitude === 0) {
                        nearStop = true;
                        break;
                    }
                }
                if (nearStop) continue;

                let sum = 0;
                let weight = 0;
                for (let j = -windowSize; j <= windowSize; j++) {
                    const w = windowSize - Math.abs(j) + 1;
                    sum += waypoints[i + j].altitude * w;
                    weight += w;
                }
                smoothed[i] = { ...waypoints[i], altitude: Math.round(sum / weight / 1000) * 1000 };
            }

            return smoothed;
        }

        // Add realistic climb and descent phases
        function addClimbDescentPhases(waypoints, distance) {
            if (waypoints.length === 0) return waypoints;

            // Minimum terrain clearance (2000 ft AGL for safety in mountainous areas)
            const MIN_TERRAIN_CLEARANCE = 2000;

            // Climb rate: ~2000 ft/min at ~250 kts = ~8 NM per 1000ft
            // Descent rate: ~1500 ft/min at ~300 kts = ~12 NM per 1000ft
            const climbRateNMPerFt = 8 / 1000;
            const descentRateNMPerFt = 12 / 1000;

            // Find target cruise altitude (most common altitude in middle section)
            const middleStart = Math.floor(waypoints.length * 0.2);
            const middleEnd = Math.floor(waypoints.length * 0.8);
            let cruiseAlt = waypoints.slice(middleStart, middleEnd)
                .reduce((sum, wp) => sum + wp.altitude, 0) / (middleEnd - middleStart);

            // For short flights, reduce cruise altitude proportionally
            // Short flights (< 50 NM) should stay lower
            if (distance < 50) {
                cruiseAlt = Math.min(cruiseAlt, Math.max(5000, distance * 200)); // Scale altitude with distance
            }

            // Calculate climb and descent distances
            let climbDist = cruiseAlt * climbRateNMPerFt;
            let descentDist = cruiseAlt * descentRateNMPerFt;

            // For short flights, ensure climb and descent don't exceed total distance
            // Leave at least 10% of distance for cruise phase
            const maxClimbDescendDist = distance * 0.45; // Max 45% each for climb/descent
            if (climbDist + descentDist > distance * 0.9) {
                const scaleFactor = (distance * 0.9) / (climbDist + descentDist);
                climbDist *= scaleFactor;
                descentDist *= scaleFactor;
                cruiseAlt *= scaleFactor; // Also scale altitude for short flights
            }

            // Ensure minimum values for visibility
            climbDist = Math.max(climbDist, distance * 0.1);
            descentDist = Math.max(descentDist, distance * 0.1);
            cruiseAlt = Math.max(cruiseAlt, 3000); // Minimum 3000ft cruise

            // Apply climb phase (but preserve stop altitudes)
            for (const wp of waypoints) {
                // Don't modify stop points - they're already set to correct altitude (0 for landing)
                if (wp.isStop || wp.altitude === 0) {
                    wp.phase = 'stop';
                    continue;
                }

                // Get minimum safe altitude (terrain + clearance)
                const terrainAlt = wp.terrainAlt || 0;
                const minSafeAlt = terrainAlt + MIN_TERRAIN_CLEARANCE;

                if (wp.distNM < climbDist) {
                    // Climbing phase - linear climb from 0 to cruise
                    const climbProgress = wp.distNM / climbDist;
                    let targetAlt = Math.round(climbProgress * cruiseAlt / 1000) * 1000;
                    // Ensure terrain clearance during climb
                    wp.altitude = Math.max(500, targetAlt, minSafeAlt);
                    wp.phase = 'climb';
                } else if (wp.distNM > distance - descentDist) {
                    // Descent phase - linear descent from cruise to destination
                    const descentProgress = (distance - wp.distNM) / descentDist;
                    let targetAlt = Math.round(descentProgress * cruiseAlt / 1000) * 1000;
                    // CRITICAL: Ensure terrain clearance during descent - don't fly into mountains!
                    wp.altitude = Math.max(500, targetAlt, minSafeAlt);
                    wp.phase = 'descent';
                } else {
                    // Cruise phase - also respect terrain clearance
                    wp.altitude = Math.max(Math.round(cruiseAlt / 1000) * 1000, minSafeAlt);
                    wp.phase = 'cruise';
                }
            }

            return waypoints;
        }

        function drawProfile(depStation, destStation, routeWaypoints = null, routeStops = null) {
            // Use global customWaypoints and customStops if not provided
            const waypoints = routeWaypoints !== null ? routeWaypoints : customWaypoints;
            const stops = routeStops !== null ? routeStops : customStops;

            // Always show zoom controls so toggle button is visible
            document.getElementById('headerZoomControls').style.display = 'flex';

            // Show the expand button when a route is loaded
            const expandBtn = document.getElementById('profileExpandBtn');
            if (expandBtn) {
                expandBtn.style.display = 'flex';
            }

            const profileSection = document.getElementById('profileSection');
            const profileContent = document.getElementById('profileContent');
            const profileBtn = document.getElementById('profileToggleBtn');

            // If profile is minimized, don't draw - just ensure UI state is correct
            if (profileView.minimized) {
                profileSection.classList.add('minimized');
                profileContent.style.display = 'none';
                if (profileBtn) {
                    profileBtn.classList.add('minimized');
                    profileBtn.title = 'Maximize Profile';
                }
                if (expandBtn) {
                    expandBtn.classList.remove('expanded');
                    expandBtn.title = 'Expand Profile';
                    expandBtn.querySelector('.expand-label').textContent = 'Profile';
                }
                return;
            }

            // Profile is expanded - show content area and draw
            profileSection.classList.remove('minimized');
            profileContent.style.display = 'flex';
            document.getElementById('profilePlaceholder').style.display = 'none';
            if (profileBtn) {
                profileBtn.classList.remove('minimized');
                profileBtn.title = 'Minimize Profile';
            }
            if (expandBtn) {
                expandBtn.classList.add('expanded');
                expandBtn.querySelector('.expand-label').textContent = 'Hide';
            }

            const canvas = document.getElementById('profileCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.parentElement.offsetWidth;
            canvas.height = canvas.parentElement.offsetHeight;

            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            const paddingRight = 60; // Extra right padding to prevent clipping destination
            const paddingBottom = 80; // Extra space for distance labels and 0ft baseline

            // Helper for Y coordinate calculation - altitude 0 should be at height - paddingBottom
            const profileHeight = height - padding - paddingBottom; // Height of the drawable profile area
            const profileBottom = height - paddingBottom; // Y coordinate for altitude 0

            // Theme-aware colors
            const themeColors = isLightMode ? {
                bg: '#e8e8e8',
                text: '#1a1a1a',
                textSecondary: 'rgba(0, 0, 0, 0.6)',
                textTertiary: 'rgba(0, 0, 0, 0.4)',
                gridLine: 'rgba(0, 0, 0, 0.1)',
                axisTick: 'rgba(0, 0, 0, 0.3)'
            } : {
                bg: '#1a1a1a',
                text: '#ffffff',
                textSecondary: 'rgba(255, 255, 255, 0.7)',
                textTertiary: 'rgba(255, 255, 255, 0.5)',
                gridLine: 'rgba(255, 255, 255, 0.1)',
                axisTick: 'rgba(255, 255, 255, 0.3)'
            };

            // Clear canvas
            ctx.fillStyle = themeColors.bg;
            ctx.fillRect(0, 0, width, height);

            // Get METAR data for both stations
            const depMetar = metarData[depStation.id] || {};
            const destMetar = metarData[destStation.id] || {};

            // Build route path for distance calculation
            const routePath = [{ lat: depStation.lat, lon: depStation.lon }];
            if (waypoints && waypoints.length > 0) {
                waypoints.forEach(wp => routePath.push({ lat: wp.lat, lon: wp.lon }));
            }
            routePath.push({ lat: destStation.lat, lon: destStation.lon });

            // Calculate total distance through all waypoints
            let distance = 0;
            const segmentCumDist = [0];
            for (let i = 1; i < routePath.length; i++) {
                const segDist = haversineDistanceNM(
                    routePath[i-1].lat, routePath[i-1].lon,
                    routePath[i].lat, routePath[i].lon
                );
                distance += segDist;
                segmentCumDist.push(distance);
            }

            // Store route segments for position interpolation
            const routeSegments = [];
            for (let i = 1; i < routePath.length; i++) {
                routeSegments.push({
                    start: segmentCumDist[i-1],
                    end: segmentCumDist[i],
                    p1: routePath[i-1],
                    p2: routePath[i]
                });
            }

            // Helper to get lat/lon at a distance along the route
            const getPositionAtDistance = (distNM) => {
                for (const seg of routeSegments) {
                    if (distNM >= seg.start && distNM <= seg.end) {
                        const segProgress = seg.end > seg.start ?
                            (distNM - seg.start) / (seg.end - seg.start) : 0;
                        return {
                            lat: seg.p1.lat + segProgress * (seg.p2.lat - seg.p1.lat),
                            lon: seg.p1.lon + segProgress * (seg.p2.lon - seg.p1.lon)
                        };
                    }
                }
                // Default to last point
                return { lat: destStation.lat, lon: destStation.lon };
            };

            // Note: distance is already calculated above through waypoints

            // Dynamic unit calculation based on zoom level AND available space
            const zoom = profileView.zoom;

            // Calculate available pixel space for labels
            const availableHeight = (height - 2 * padding) * zoom;
            const availableWidth = (width - padding - paddingRight) * zoom;

            // Minimum pixel spacing between labels to prevent overlap
            const minAltLabelSpacing = 25; // pixels between altitude labels
            const minDistLabelSpacing = 45; // pixels between distance labels

            // Calculate max number of labels that fit
            const maxAltLabels = Math.floor(availableHeight / minAltLabelSpacing);
            const maxDistLabels = Math.floor(availableWidth / minDistLabelSpacing);

            // Available step sizes (must divide evenly into sensible intervals)
            const altStepOptions = [1000, 2000, 5000, 10000, 20000];
            const distStepOptions = [5, 10, 25, 50, 100];

            let distStep = distStepOptions[distStepOptions.length - 1];
            for (const step of distStepOptions) {
                if (distance / step <= maxDistLabels) {
                    distStep = step;
                    break;
                }
            }

            // Seed for consistent random terrain
            let seed = (depStation.lat * 1000 + destStation.lon * 100) % 1000;
            function seededRandom() {
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            }

            // Generate terrain profile data (always needed for flight path optimization)
            const terrainProfile = [];
            const terrainSamplePoints = 50;
            // Reset seed for consistent terrain calculation
            let terrainSeed = (depStation.lat * 1000 + destStation.lon * 100) % 1000;
            function terrainSeededRandom() {
                terrainSeed = (terrainSeed * 9301 + 49297) % 233280;
                return terrainSeed / 233280;
            }
            for (let i = 0; i <= terrainSamplePoints; i++) {
                const positionSeed = i / terrainSamplePoints;
                const terrainHeight = Math.sin(positionSeed * 10) * 2000 +
                                     Math.sin(positionSeed * 25) * 800 +
                                     Math.sin(positionSeed * 50) * 400 +
                                     terrainSeededRandom() * 500 + 500;
                terrainProfile.push(terrainHeight);
            }

            // Calculate optimal flight path based on hazards (including stops for landing pattern)
            const optimizedPath = calculateOptimalFlightPath(depStation, destStation, distance, terrainProfile, waypoints, stops);

            // Calculate dynamic altitude scale based on route
            const routeMaxAlt = Math.max(...optimizedPath.map(wp => wp.altitude));
            const terrainMaxAlt = Math.max(...terrainProfile);
            // Round up to nearest 5000 and add 20% headroom
            const maxAltitude = Math.max(
                Math.ceil((routeMaxAlt * 1.2) / 5000) * 5000,
                Math.ceil((terrainMaxAlt * 1.5) / 5000) * 5000,
                10000 // Minimum scale
            );

            // Calculate altStep based on dynamic maxAltitude
            let altStep = altStepOptions[altStepOptions.length - 1];
            for (const step of altStepOptions) {
                if (maxAltitude / step <= maxAltLabels) {
                    altStep = step;
                    break;
                }
            }

            // Apply zoom and pan transform with clipping for content area
            ctx.save();

            // Clip to the profile content area (inside padding)
            ctx.beginPath();
            ctx.rect(padding, padding, width - padding - paddingRight, height - padding - paddingBottom);
            ctx.clip();

            // Apply zoom centered on canvas center, then apply pan
            ctx.translate(width / 2 + profileView.panX, height / 2 + profileView.panY);
            ctx.scale(profileView.zoom, profileView.zoom);
            ctx.translate(-width / 2, -height / 2);

            // Draw grid lines (these zoom with content)
            ctx.strokeStyle = themeColors.gridLine;
            ctx.lineWidth = 1 / zoom; // Keep line width consistent when zoomed

            // Horizontal grid lines (altitude) - dynamic based on zoom
            for (let alt = 0; alt <= maxAltitude; alt += altStep) {
                const y = profileBottom - (alt / maxAltitude) * profileHeight;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - paddingRight, y);
                ctx.stroke();
            }

            // Vertical grid lines (distance) - dynamic based on zoom
            const numDistLines = Math.ceil(distance / distStep);
            for (let i = 0; i <= numDistLines; i++) {
                const distNM = i * distStep;
                if (distNM > distance) break;
                const x = padding + (distNM / distance) * (width - padding - paddingRight);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }

            // Draw terrain profile (simulated) - granularity scales with zoom
            if (profileOverlays.terrain) {
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);

                // More terrain points when zoomed in for smoother detail
                const terrainPoints = Math.floor(50 * Math.max(1, zoom));
                for (let i = 0; i <= terrainPoints; i++) {
                    const x = padding + (i / terrainPoints) * (width - padding - paddingRight);
                    // Use consistent seeding based on position for stable terrain
                    const positionSeed = i / terrainPoints;
                    const terrainHeight = Math.sin(positionSeed * 10) * 2000 +
                                         Math.sin(positionSeed * 25) * 800 +
                                         Math.sin(positionSeed * 50) * 400 +
                                         seededRandom() * 500 + 500;
                    const y = profileBottom - (terrainHeight / maxAltitude) * profileHeight;
                    ctx.lineTo(x, y);
                }

                ctx.lineTo(width - paddingRight, height - padding);
                ctx.closePath();
                ctx.fillStyle = 'rgba(139, 92, 42, 0.4)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(139, 92, 42, 0.8)';
                ctx.lineWidth = 1 / zoom;
                ctx.stroke();
            }

            // Draw ceiling/weather blocks
            const depCeiling = depMetar.ceiling || 12500;
            const destCeiling = destMetar.ceiling || 12500;

            // Weather gradient
            const gradient = ctx.createLinearGradient(padding, 0, width - paddingRight, 0);
            const depColor = flightRulesColors[depMetar.flight_rules || 'VFR'];
            const destColor = flightRulesColors[destMetar.flight_rules || 'VFR'];
            gradient.addColorStop(0, depColor + '40');
            gradient.addColorStop(1, destColor + '40');

            // Draw ceiling overlay
            if (profileOverlays.ceiling) {
                // Draw ceiling line
                ctx.beginPath();
                ctx.moveTo(padding, profileBottom - (depCeiling / maxAltitude) * profileHeight);
                ctx.lineTo(width - paddingRight, profileBottom - (destCeiling / maxAltitude) * profileHeight);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2 / zoom;
                ctx.stroke();

                // Fill area below ceiling
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);
                ctx.lineTo(padding, profileBottom - (depCeiling / maxAltitude) * profileHeight);
                ctx.lineTo(width - paddingRight, profileBottom - (destCeiling / maxAltitude) * profileHeight);
                ctx.lineTo(width - paddingRight, height - padding);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // Draw visibility overlay - block visualization at different elevations
            if (profileOverlays.visibility) {
                const depVis = depMetar.visibility || 10;
                const destVis = destMetar.visibility || 10;

                // Define elevation bands (floor, ceiling in feet)
                const elevationBands = [
                    { floor: 0, ceiling: 2000, label: 'SFC-2K' },
                    { floor: 2000, ceiling: 5000, label: '2K-5K' },
                    { floor: 5000, ceiling: 10000, label: '5K-10K' },
                    { floor: 10000, ceiling: 18000, label: '10K-18K' },
                    { floor: 18000, ceiling: 40000, label: 'FL180+' }
                ];

                // Calculate visibility at altitude based on surface visibility
                // Visibility generally improves with altitude above obscuration layer
                const getVisAtAltitude = (surfaceVis, altitude) => {
                    if (surfaceVis >= 6) {
                        // Good surface vis = good at all altitudes
                        return surfaceVis;
                    } else if (surfaceVis >= 3) {
                        // Moderate surface vis - improves above 3000ft
                        if (altitude >= 5000) return 10;
                        if (altitude >= 3000) return 6;
                        return surfaceVis;
                    } else if (surfaceVis >= 1) {
                        // Poor surface vis - fog/haze layer up to ~5000ft
                        if (altitude >= 10000) return 10;
                        if (altitude >= 5000) return 6;
                        if (altitude >= 2000) return 3;
                        return surfaceVis;
                    } else {
                        // Very poor surface vis - deep obscuration
                        if (altitude >= 18000) return 10;
                        if (altitude >= 10000) return 6;
                        if (altitude >= 5000) return 3;
                        if (altitude >= 2000) return 1;
                        return surfaceVis;
                    }
                };

                // Color based on visibility value
                const getVisColor = (vis) => {
                    if (vis >= 6) return { r: 34, g: 197, b: 94, a: 0.25 };   // Green - good
                    if (vis >= 3) return { r: 59, g: 130, b: 246, a: 0.35 };  // Blue - moderate
                    if (vis >= 1) return { r: 245, g: 158, b: 11, a: 0.45 };  // Amber - reduced
                    return { r: 239, g: 68, b: 68, a: 0.55 };                  // Red - poor
                };

                // Number of horizontal slices along the route
                const numSlices = 40;

                // Draw blocks for each slice and elevation band
                for (let i = 0; i < numSlices; i++) {
                    const progress = i / numSlices;
                    const nextProgress = (i + 1) / numSlices;
                    const x = padding + progress * (width - padding - paddingRight);
                    const nextX = padding + nextProgress * (width - padding - paddingRight);
                    const sliceWidth = nextX - x;

                    // Interpolate surface visibility along route
                    const surfaceVis = depVis + progress * (destVis - depVis);

                    // Draw each elevation band
                    elevationBands.forEach(band => {
                        const midAlt = (band.floor + band.ceiling) / 2;
                        const visAtBand = getVisAtAltitude(surfaceVis, midAlt);
                        const color = getVisColor(visAtBand);

                        const yTop = profileBottom - (band.ceiling / maxAltitude) * profileHeight;
                        const yBottom = profileBottom - (band.floor / maxAltitude) * profileHeight;
                        const blockHeight = yBottom - yTop;

                        // Fill block
                        ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
                        ctx.fillRect(x, yTop, sliceWidth + 0.5, blockHeight);
                    });
                }

                // Draw elevation band boundaries (horizontal lines)
                ctx.strokeStyle = 'rgba(168, 85, 247, 0.4)';
                ctx.lineWidth = 1 / zoom;
                ctx.setLineDash([3 / zoom, 3 / zoom]);
                elevationBands.forEach(band => {
                    if (band.ceiling < maxAltitude) {
                        const y = profileBottom - (band.ceiling / maxAltitude) * profileHeight;
                        ctx.beginPath();
                        ctx.moveTo(padding, y);
                        ctx.lineTo(width - paddingRight, y);
                        ctx.stroke();
                    }
                });
                ctx.setLineDash([]);

                // Draw elevation band labels on the left side
                ctx.font = `${8 / zoom}px sans-serif`;
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(168, 85, 247, 0.9)';
                elevationBands.forEach(band => {
                    const yMid = profileBottom - ((band.floor + band.ceiling) / 2 / maxAltitude) * profileHeight;
                    ctx.fillText(band.label, padding + 3 / zoom, yMid + 3 / zoom);
                });

                // Add visibility legend at bottom
                const legendY = height - padding + 15 / zoom;
                const legendItems = [
                    { label: '>6 SM', color: 'rgba(34, 197, 94, 0.7)' },
                    { label: '3-6 SM', color: 'rgba(59, 130, 246, 0.7)' },
                    { label: '1-3 SM', color: 'rgba(245, 158, 11, 0.7)' },
                    { label: '<1 SM', color: 'rgba(239, 68, 68, 0.7)' }
                ];

                ctx.font = `${9 / zoom}px sans-serif`;
                ctx.textAlign = 'left';
                let legendX = padding;
                legendItems.forEach(item => {
                    // Color box
                    ctx.fillStyle = item.color;
                    ctx.fillRect(legendX, legendY - 8 / zoom, 12 / zoom, 8 / zoom);
                    ctx.strokeStyle = 'rgba(168, 85, 247, 0.5)';
                    ctx.lineWidth = 0.5 / zoom;
                    ctx.strokeRect(legendX, legendY - 8 / zoom, 12 / zoom, 8 / zoom);

                    // Label
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillText(item.label, legendX + 15 / zoom, legendY);
                    legendX += 60 / zoom;
                });

                // Add "VISIBILITY" title
                ctx.textAlign = 'right';
                ctx.fillStyle = 'rgba(168, 85, 247, 0.9)';
                ctx.font = `bold ${9 / zoom}px sans-serif`;
                ctx.fillText('VISIBILITY', width - paddingRight, legendY);
            }

            // Draw temperature overlay - HAZARDS ONLY: freezing, extreme cold, and extreme heat
            if (profileOverlays.temperature) {
                // Safely get temperatures with fallback to standard 15C
                const depTemp = (depMetar && depMetar.temperature != null) ? depMetar.temperature : 15;
                const destTemp = (destMetar && destMetar.temperature != null) ? destMetar.temperature : 15;

                // Standard lapse rate: approximately -2C per 1000ft (or -6.5C per 1000m)
                const lapseRate = -2; // C per 1000ft

                // Get temperature color - ONLY for hazardous temps (returns null for safe temps)
                const getHazardTempColor = (temp) => {
                    if (temp <= -40) return { r: 88, g: 28, b: 135, a: 0.5 };   // Deep purple - EXTREME COLD hazard
                    if (temp <= -20) return { r: 124, g: 58, b: 237, a: 0.4 };  // Purple - SEVERE COLD hazard
                    if (temp <= 0) return { r: 6, g: 182, b: 212, a: 0.3 };     // Cyan - FREEZING/ICING hazard
                    if (temp >= 40) return { r: 153, g: 27, b: 27, a: 0.4 };    // Dark red - EXTREME HEAT hazard
                    if (temp >= 35) return { r: 239, g: 68, b: 68, a: 0.35 };   // Red - HIGH DENSITY ALTITUDE hazard
                    return null; // Safe temperature range - don't display
                };

                // Define altitude bands for temperature visualization
                const tempBands = [
                    { floor: 0, ceiling: 5000 },
                    { floor: 5000, ceiling: 10000 },
                    { floor: 10000, ceiling: 12500 }
                ];

                // Number of horizontal slices along the route
                const numSlices = 40;

                // Draw temperature blocks for each slice and altitude band - ONLY HAZARDOUS TEMPS
                for (let i = 0; i < numSlices; i++) {
                    const progress = i / numSlices;
                    const nextProgress = (i + 1) / numSlices;
                    const x = padding + progress * (width - padding - paddingRight);
                    const nextX = padding + nextProgress * (width - padding - paddingRight);
                    const sliceWidth = nextX - x;

                    // Interpolate surface temperature along route
                    const surfaceTemp = depTemp + progress * (destTemp - depTemp);

                    // Draw each altitude band - ONLY if temperature is hazardous
                    tempBands.forEach(band => {
                        const midAlt = (band.floor + band.ceiling) / 2;
                        // Calculate temperature at this altitude using lapse rate
                        const tempAtAlt = surfaceTemp + (midAlt / 1000) * lapseRate;
                        const color = getHazardTempColor(tempAtAlt);

                        // Skip safe temperature ranges
                        if (!color) return;

                        const yTop = profileBottom - (band.ceiling / maxAltitude) * profileHeight;
                        const yBottom = profileBottom - (band.floor / maxAltitude) * profileHeight;
                        const blockHeight = yBottom - yTop;

                        // Fill block
                        ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
                        ctx.fillRect(x, yTop, sliceWidth + 0.5, blockHeight);
                    });
                }

                // Draw freezing level line (0C isotherm)
                const depFreezingAlt = depTemp > 0 ? (depTemp / Math.abs(lapseRate)) * 1000 : 0;
                const destFreezingAlt = destTemp > 0 ? (destTemp / Math.abs(lapseRate)) * 1000 : 0;

                if (depFreezingAlt > 0 || destFreezingAlt > 0) {
                    ctx.beginPath();
                    ctx.setLineDash([4 / zoom, 4 / zoom]);
                    ctx.strokeStyle = '#06b6d4';
                    ctx.lineWidth = 2 / zoom;

                    for (let i = 0; i <= 30; i++) {
                        const progress = i / 30;
                        const x = padding + progress * (width - padding - paddingRight);
                        const freezingAlt = depFreezingAlt + progress * (destFreezingAlt - depFreezingAlt);
                        const y = profileBottom - (Math.min(freezingAlt, maxAltitude) / maxAltitude) * profileHeight;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Label freezing level
                    ctx.font = `bold ${9 / zoom}px sans-serif`;
                    ctx.fillStyle = '#06b6d4';
                    ctx.textAlign = 'left';
                    const freezeMidY = profileBottom - ((depFreezingAlt + destFreezingAlt) / 2 / maxAltitude) * profileHeight;
                    ctx.fillText('32F', padding + 3 / zoom, freezeMidY - 3 / zoom);
                }

                // Draw altitude band boundaries
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.3)';
                ctx.lineWidth = 0.5 / zoom;
                ctx.setLineDash([2 / zoom, 4 / zoom]);
                tempBands.forEach(band => {
                    if (band.ceiling < maxAltitude) {
                        const y = profileBottom - (band.ceiling / maxAltitude) * profileHeight;
                        ctx.beginPath();
                        ctx.moveTo(padding, y);
                        ctx.lineTo(width - paddingRight, y);
                        ctx.stroke();
                    }
                });
                ctx.setLineDash([]);

                // Add compact temperature indicator at top center of profile
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';

                // Position at top center
                const tempBoxY = padding + 8;
                const centerX = width / 2;

                // Calculate total width needed for both boxes
                const tempBoxWidth = 110;
                const freezingBoxWidth = 95;
                const gap = 8;
                const hasFreezingLevel = depFreezingAlt > 0 || destFreezingAlt > 0;
                const totalWidth = hasFreezingLevel ? tempBoxWidth + gap + freezingBoxWidth : tempBoxWidth;
                const startX = centerX - totalWidth / 2;

                // Temperature range box
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(startX, tempBoxY, tempBoxWidth, 18);
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(startX, tempBoxY, tempBoxWidth, 18);

                const depTempF = Math.round(depTemp * 9/5 + 32);
                const destTempF = Math.round(destTemp * 9/5 + 32);
                ctx.fillStyle = '#ef4444';
                ctx.textAlign = 'center';
                ctx.fillText(`OAT: ${depTempF}F  ${destTempF}F`, startX + tempBoxWidth / 2, tempBoxY + 13);

                // Add freezing level indicator if applicable
                if (hasFreezingLevel) {
                    const avgFreezingAlt = Math.round((depFreezingAlt + destFreezingAlt) / 2);
                    const freezingX = startX + tempBoxWidth + gap;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(freezingX, tempBoxY, freezingBoxWidth, 18);
                    ctx.strokeStyle = 'rgba(6, 182, 212, 0.6)';
                    ctx.strokeRect(freezingX, tempBoxY, freezingBoxWidth, 18);
                    ctx.fillStyle = '#06b6d4';
                    ctx.fillText(`32F: ${avgFreezingAlt.toLocaleString()}ft`, freezingX + freezingBoxWidth / 2, tempBoxY + 13);
                }
            }

            // Draw airspace overlay
            if (profileOverlays.airspace) {
                // Build actual route path including ALL waypoints (custom + avoidance) for accurate airspace checking
                // Use currentRouteData if available as it contains auto-generated avoidance waypoints
                const actualRoutePath = [{ lat: depStation.lat, lon: depStation.lon }];

                // Get all waypoints from route data (includes divert/avoidance waypoints)
                const allRouteWaypoints = currentRouteData && currentRouteData.waypoints
                    ? currentRouteData.waypoints.filter(wp => wp.type !== 'departure' && wp.type !== 'destination')
                    : (waypoints || []);

                if (allRouteWaypoints.length > 0) {
                    // Sort waypoints by distance along route
                    const sortedWps = [...allRouteWaypoints].sort((a, b) => (a.distance || 0) - (b.distance || 0));
                    sortedWps.forEach(wp => actualRoutePath.push({ lat: wp.lat, lon: wp.lon }));
                }
                actualRoutePath.push({ lat: destStation.lat, lon: destStation.lon });

                // Helper: Check if route segment intersects polygon
                function routeIntersectsPolygon(polygon) {
                    // Check each segment of the actual route
                    for (let i = 0; i < actualRoutePath.length - 1; i++) {
                        const p1 = actualRoutePath[i];
                        const p2 = actualRoutePath[i + 1];
                        // Sample points along segment
                        for (let t = 0; t <= 1; t += 0.1) {
                            const lat = p1.lat + t * (p2.lat - p1.lat);
                            const lon = p1.lon + t * (p2.lon - p1.lon);
                            if (pointInPolygon(lat, lon, polygon)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }

                // Helper: Check if route passes near a center point
                function routePassesNear(centerLat, centerLon, threshold) {
                    for (let i = 0; i < actualRoutePath.length - 1; i++) {
                        const p1 = actualRoutePath[i];
                        const p2 = actualRoutePath[i + 1];
                        for (let t = 0; t <= 1; t += 0.1) {
                            const lat = p1.lat + t * (p2.lat - p1.lat);
                            const lon = p1.lon + t * (p2.lon - p1.lon);
                            const dist = Math.sqrt(Math.pow(lat - centerLat, 2) + Math.pow(lon - centerLon, 2));
                            if (dist < threshold) return true;
                        }
                    }
                    return false;
                }

                // Check which airspaces the ACTUAL route passes through
                const relevantAirspaces = [];

                // Check Class B (using center from first tier)
                airspaceData.classB.forEach(airspace => {
                    const center = airspace.center;
                    const distToDep = Math.sqrt(Math.pow(center[0] - depStation.lat, 2) + Math.pow(center[1] - depStation.lon, 2));
                    const distToDest = Math.sqrt(Math.pow(center[0] - destStation.lat, 2) + Math.pow(center[1] - destStation.lon, 2));

                    if (distToDep < 1 || distToDest < 1 || routePassesNear(center[0], center[1], 1)) {
                        const maxCeiling = Math.max(...airspace.tiers.map(t => t.ceiling));
                        relevantAirspaces.push({ name: airspace.name, center, floor: 0, ceiling: maxCeiling, type: 'B', color: '#3b82f6' });
                    }
                });

                // Check Class C
                airspaceData.classC.forEach(airspace => {
                    const center = airspace.center;
                    const distToDep = Math.sqrt(Math.pow(center[0] - depStation.lat, 2) + Math.pow(center[1] - depStation.lon, 2));
                    const distToDest = Math.sqrt(Math.pow(center[0] - destStation.lat, 2) + Math.pow(center[1] - destStation.lon, 2));

                    if (distToDep < 0.5 || distToDest < 0.5) {
                        const maxCeiling = Math.max(...airspace.tiers.map(t => t.ceiling));
                        relevantAirspaces.push({ name: airspace.name, center, floor: 0, ceiling: maxCeiling, type: 'C', color: '#ec4899' });
                    }
                });

                // Check MOAs - only if actual route intersects polygon
                airspaceData.moa.forEach(zone => {
                    if (routeIntersectsPolygon(zone.polygon)) {
                        relevantAirspaces.push({ ...zone, type: 'MOA', color: '#d97706' });
                    }
                });

                // Check Restricted - only if actual route intersects polygon
                airspaceData.restricted.forEach(zone => {
                    if (routeIntersectsPolygon(zone.polygon)) {
                        relevantAirspaces.push({ ...zone, type: 'R', color: '#ef4444' });
                    }
                });

                // Draw departure and destination Class B shelves
                const depAirspace = airspaceData.classB.find(a =>
                    Math.sqrt(Math.pow(a.center[0] - depStation.lat, 2) + Math.pow(a.center[1] - depStation.lon, 2)) < 0.5
                );
                const destAirspace = airspaceData.classB.find(a =>
                    Math.sqrt(Math.pow(a.center[0] - destStation.lat, 2) + Math.pow(a.center[1] - destStation.lon, 2)) < 0.5
                );

                // Draw departure Class B tiers - high resolution wedding cake structure
                if (depAirspace && depAirspace.tiers && depAirspace.tiers.length > 0) {
                    try {
                    // Calculate distance-based width for each tier (in NM from airport)
                    // Outer tiers extend further horizontally
                    const tierRadii = [10, 20, 30]; // NM radius for each tier
                    const distancePerPixel = Math.max(0.01, distance / (width - padding - paddingRight));

                    // Sort tiers by floor (outer tiers have higher floors)
                    const sortedTiers = [...depAirspace.tiers].sort((a, b) => a.floor - b.floor);

                    // Draw from outer to inner for proper layering
                    for (let i = sortedTiers.length - 1; i >= 0; i--) {
                        const tier = sortedTiers[i];
                        const tierRadius = tierRadii[Math.min(i, tierRadii.length - 1)] || 30;
                        const xWidth = Math.max(20, tierRadius / distancePerPixel) * zoom;

                        const yTop = profileBottom - (tier.ceiling / maxAltitude) * profileHeight;
                        const yBottom = profileBottom - (tier.floor / maxAltitude) * profileHeight;

                        // Gradient fill for depth effect
                        const gradient = ctx.createLinearGradient(padding, 0, padding + xWidth, 0);
                        const alpha = 0.15 + (sortedTiers.length - 1 - i) * 0.1;
                        gradient.addColorStop(0, `rgba(59, 130, 246, ${alpha + 0.15})`);
                        gradient.addColorStop(1, `rgba(59, 130, 246, ${alpha})`);

                        ctx.fillStyle = gradient;
                        ctx.fillRect(padding, yTop, xWidth, yBottom - yTop);

                        // Border - thicker for inner tiers, zoom responsive
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = (i === 0 ? 2.5 : 1.5) / zoom;
                        ctx.setLineDash(i === 0 ? [] : [4 / zoom, 2 / zoom]);
                        ctx.strokeRect(padding, yTop, xWidth, yBottom - yTop);

                        // Altitude labels on each shelf - cap apparent size at ~10px
                        const fontSize = 10 / zoom;
                        ctx.font = `${fontSize}px sans-serif`;
                        ctx.fillStyle = 'rgba(59, 130, 246, 0.9)';
                        ctx.textAlign = 'left';

                        // Floor label
                        const floorLabel = tier.floor === 0 ? 'SFC' : `${(tier.floor / 1000).toFixed(1)}K`;
                        ctx.fillText(floorLabel, padding + xWidth + 3 / zoom, yBottom - 2 / zoom);

                        // Ceiling label (only for innermost tier)
                        if (i === 0) {
                            ctx.fillText(`${(tier.ceiling / 1000).toFixed(1)}K`, padding + xWidth + 3 / zoom, yTop + fontSize);
                        }

                        // Horizontal shelf line for visual clarity
                        if (i < sortedTiers.length - 1 && tier.floor > 0) {
                            ctx.beginPath();
                            ctx.moveTo(padding, yBottom);
                            ctx.lineTo(padding + xWidth + 5 / zoom, yBottom);
                            ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
                            ctx.lineWidth = 1 / zoom;
                            ctx.setLineDash([]);
                            ctx.stroke();
                        }
                    }
                    ctx.setLineDash([]);

                    // Main label with enhanced styling - cap apparent size at ~14px
                    const labelFontSize = 14 / zoom;
                    ctx.font = `bold ${labelFontSize}px sans-serif`;
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'left';
                    const labelY = profileBottom - (sortedTiers[0].ceiling / maxAltitude) * profileHeight - 8 / zoom;
                    ctx.fillText('Class B', padding + 2 / zoom, labelY);

                    // Airport identifier - cap apparent size at ~11px
                    ctx.font = `${11 / zoom}px sans-serif`;
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                    ctx.fillText(depAirspace.name.split(' ')[0], padding + 2 / zoom, labelY + labelFontSize);
                    } catch (e) { console.error('Dep airspace draw error:', e); }
                }

                // Draw destination Class B tiers - high resolution wedding cake structure
                if (destAirspace && destAirspace.tiers && destAirspace.tiers.length > 0) {
                    try {
                    const tierRadii = [10, 20, 30];
                    const distancePerPixel = Math.max(0.01, distance / (width - padding - paddingRight));

                    const sortedTiers = [...destAirspace.tiers].sort((a, b) => a.floor - b.floor);

                    for (let i = sortedTiers.length - 1; i >= 0; i--) {
                        const tier = sortedTiers[i];
                        const tierRadius = tierRadii[Math.min(i, tierRadii.length - 1)] || 30;
                        const xWidth = Math.max(20, tierRadius / distancePerPixel) * zoom;

                        const yTop = profileBottom - (tier.ceiling / maxAltitude) * profileHeight;
                        const yBottom = profileBottom - (tier.floor / maxAltitude) * profileHeight;

                        // Gradient fill for depth effect
                        const gradient = ctx.createLinearGradient(width - paddingRight - xWidth, 0, width - paddingRight, 0);
                        const alpha = 0.15 + (sortedTiers.length - 1 - i) * 0.1;
                        gradient.addColorStop(0, `rgba(59, 130, 246, ${alpha})`);
                        gradient.addColorStop(1, `rgba(59, 130, 246, ${alpha + 0.15})`);

                        ctx.fillStyle = gradient;
                        ctx.fillRect(width - paddingRight - xWidth, yTop, xWidth, yBottom - yTop);

                        // Border
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = (i === 0 ? 2.5 : 1.5) / zoom;
                        ctx.setLineDash(i === 0 ? [] : [4 / zoom, 2 / zoom]);
                        ctx.strokeRect(width - paddingRight - xWidth, yTop, xWidth, yBottom - yTop);

                        // Altitude labels - cap apparent size at ~10px
                        const fontSize = 10 / zoom;
                        ctx.font = `${fontSize}px sans-serif`;
                        ctx.fillStyle = 'rgba(59, 130, 246, 0.9)';
                        ctx.textAlign = 'right';

                        const floorLabel = tier.floor === 0 ? 'SFC' : `${(tier.floor / 1000).toFixed(1)}K`;
                        ctx.fillText(floorLabel, width - paddingRight - xWidth - 3 / zoom, yBottom - 2 / zoom);

                        if (i === 0) {
                            ctx.fillText(`${(tier.ceiling / 1000).toFixed(1)}K`, width - paddingRight - xWidth - 3 / zoom, yTop + fontSize);
                        }

                        // Horizontal shelf line
                        if (i < sortedTiers.length - 1 && tier.floor > 0) {
                            ctx.beginPath();
                            ctx.moveTo(width - paddingRight - xWidth - 5 / zoom, yBottom);
                            ctx.lineTo(width - paddingRight, yBottom);
                            ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
                            ctx.lineWidth = 1 / zoom;
                            ctx.setLineDash([]);
                            ctx.stroke();
                        }
                    }
                    ctx.setLineDash([]);

                    // Main label - cap apparent size at ~14px
                    const labelFontSize = 14 / zoom;
                    ctx.font = `bold ${labelFontSize}px sans-serif`;
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'right';
                    const labelY = profileBottom - (sortedTiers[0].ceiling / maxAltitude) * profileHeight - 8 / zoom;
                    ctx.fillText('Class B', width - paddingRight - 2 / zoom, labelY);

                    ctx.font = `${11 / zoom}px sans-serif`;
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                    ctx.fillText(destAirspace.name.split(' ')[0], width - paddingRight - 2 / zoom, labelY + labelFontSize);
                    } catch (e) { console.error('Dest airspace draw error:', e); }
                }

                // Also check for Class C airports at departure/destination
                const depClassC = airspaceData.classC.find(a =>
                    Math.sqrt(Math.pow(a.center[0] - depStation.lat, 2) + Math.pow(a.center[1] - depStation.lon, 2)) < 0.3
                );
                const destClassC = airspaceData.classC.find(a =>
                    Math.sqrt(Math.pow(a.center[0] - destStation.lat, 2) + Math.pow(a.center[1] - destStation.lon, 2)) < 0.3
                );

                // Draw Class C if present and no Class B
                if (depClassC && !depAirspace && depClassC.tiers && depClassC.tiers.length > 0) {
                    try {
                    const distancePerPixel = Math.max(0.01, distance / (width - padding - paddingRight));
                    const sortedTiers = [...depClassC.tiers].sort((a, b) => a.floor - b.floor);

                    for (let i = sortedTiers.length - 1; i >= 0; i--) {
                        const tier = sortedTiers[i];
                        const tierRadius = [5, 10][Math.min(i, 1)] || 10;
                        const xWidth = Math.max(15, tierRadius / distancePerPixel) * zoom;

                        const yTop = profileBottom - (tier.ceiling / maxAltitude) * profileHeight;
                        const yBottom = profileBottom - (tier.floor / maxAltitude) * profileHeight;

                        const gradient = ctx.createLinearGradient(padding, 0, padding + xWidth, 0);
                        const alpha = 0.12 + (sortedTiers.length - 1 - i) * 0.08;
                        gradient.addColorStop(0, `rgba(236, 72, 153, ${alpha + 0.1})`);
                        gradient.addColorStop(1, `rgba(236, 72, 153, ${alpha})`);

                        ctx.fillStyle = gradient;
                        ctx.fillRect(padding, yTop, xWidth, yBottom - yTop);

                        ctx.strokeStyle = '#ec4899';
                        ctx.lineWidth = (i === 0 ? 2 : 1.5) / zoom;
                        ctx.setLineDash(i === 0 ? [] : [3 / zoom, 2 / zoom]);
                        ctx.strokeRect(padding, yTop, xWidth, yBottom - yTop);
                    }
                    ctx.setLineDash([]);

                    const labelFontSize = Math.max(9, 12 / zoom);
                    ctx.font = `bold ${labelFontSize}px sans-serif`;
                    ctx.fillStyle = '#ec4899';
                    ctx.textAlign = 'left';
                    ctx.fillText('Class C', padding + 2 / zoom, profileBottom - (sortedTiers[0].ceiling / maxAltitude) * profileHeight - 5 / zoom);
                    } catch (e) { console.error('Dep Class C draw error:', e); }
                }

                if (destClassC && !destAirspace && destClassC.tiers && destClassC.tiers.length > 0) {
                    try {
                    const distancePerPixel = Math.max(0.01, distance / (width - padding - paddingRight));
                    const sortedTiers = [...destClassC.tiers].sort((a, b) => a.floor - b.floor);

                    for (let i = sortedTiers.length - 1; i >= 0; i--) {
                        const tier = sortedTiers[i];
                        const tierRadius = [5, 10][Math.min(i, 1)] || 10;
                        const xWidth = Math.max(15, tierRadius / distancePerPixel) * zoom;

                        const yTop = profileBottom - (tier.ceiling / maxAltitude) * profileHeight;
                        const yBottom = profileBottom - (tier.floor / maxAltitude) * profileHeight;

                        const gradient = ctx.createLinearGradient(width - paddingRight - xWidth, 0, width - paddingRight, 0);
                        const alpha = 0.12 + (sortedTiers.length - 1 - i) * 0.08;
                        gradient.addColorStop(0, `rgba(236, 72, 153, ${alpha})`);
                        gradient.addColorStop(1, `rgba(236, 72, 153, ${alpha + 0.1})`);

                        ctx.fillStyle = gradient;
                        ctx.fillRect(width - paddingRight - xWidth, yTop, xWidth, yBottom - yTop);

                        ctx.strokeStyle = '#ec4899';
                        ctx.lineWidth = (i === 0 ? 2 : 1.5) / zoom;
                        ctx.setLineDash(i === 0 ? [] : [3 / zoom, 2 / zoom]);
                        ctx.strokeRect(width - paddingRight - xWidth, yTop, xWidth, yBottom - yTop);
                    }
                    ctx.setLineDash([]);

                    const labelFontSize = Math.max(9, 12 / zoom);
                    ctx.font = `bold ${labelFontSize}px sans-serif`;
                    ctx.fillStyle = '#ec4899';
                    ctx.textAlign = 'right';
                    ctx.fillText('Class C', width - paddingRight - 2 / zoom, profileBottom - (sortedTiers[0].ceiling / maxAltitude) * profileHeight - 5 / zoom);
                    } catch (e) { console.error('Dest Class C draw error:', e); }
                }

                // Point-in-polygon helper for route intersection
                const pointInPoly = (lat, lon, polygon) => {
                    let inside = false;
                    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                        const xi = polygon[i][0], yi = polygon[i][1];
                        const xj = polygon[j][0], yj = polygon[j][1];
                        if (((yi > lon) !== (yj > lon)) && (lat < (xj - xi) * (lon - yi) / (yj - yi) + xi)) {
                            inside = !inside;
                        }
                    }
                    return inside;
                };

                // Find where route crosses each airspace
                const routeAirspaces = [];

                // actualRoutePath is already built above - reuse it

                // Calculate total route distance for progress mapping
                let totalRouteDist = 0;
                const segmentDists = [];
                for (let i = 0; i < actualRoutePath.length - 1; i++) {
                    const d = haversineNM(actualRoutePath[i].lat, actualRoutePath[i].lon,
                                          actualRoutePath[i+1].lat, actualRoutePath[i+1].lon);
                    segmentDists.push(d);
                    totalRouteDist += d;
                }

                // Helper to check a zone against the ACTUAL route path
                function checkZoneOnActualRoute(zone) {
                    let entryProgress = null, exitProgress = null;
                    let cumDist = 0;

                    for (let seg = 0; seg < actualRoutePath.length - 1; seg++) {
                        const p1 = actualRoutePath[seg];
                        const p2 = actualRoutePath[seg + 1];
                        const segDist = segmentDists[seg];
                        const numSamples = Math.max(10, Math.ceil(segDist / 5)); // Sample every ~5nm

                        for (let s = 0; s <= numSamples; s++) {
                            const t = s / numSamples;
                            const lat = p1.lat + t * (p2.lat - p1.lat);
                            const lon = p1.lon + t * (p2.lon - p1.lon);
                            const progress = (cumDist + t * segDist) / totalRouteDist;

                            const inside = pointInPoly(lat, lon, zone.polygon);
                            if (inside && entryProgress === null) entryProgress = progress;
                            if (!inside && entryProgress !== null && exitProgress === null) exitProgress = progress;
                        }
                        cumDist += segDist;
                    }

                    if (entryProgress !== null) {
                        return { entry: entryProgress, exit: exitProgress || 1 };
                    }
                    return null;
                }

                // Check Restricted areas along ACTUAL route
                airspaceData.restricted.forEach(zone => {
                    const intersection = checkZoneOnActualRoute(zone);
                    if (intersection) {
                        routeAirspaces.push({
                            ...zone, type: 'R', color: '#ef4444',
                            entry: intersection.entry, exit: intersection.exit,
                            floor: zone.floor || 0
                        });
                    }
                });

                // Check Prohibited areas along ACTUAL route
                airspaceData.prohibited.forEach(zone => {
                    const intersection = checkZoneOnActualRoute(zone);
                    if (intersection) {
                        routeAirspaces.push({
                            ...zone, type: 'P', color: '#dc2626',
                            entry: intersection.entry, exit: intersection.exit,
                            floor: zone.floor || 0
                        });
                    }
                });

                // Check MOAs along ACTUAL route
                airspaceData.moa.forEach(zone => {
                    const intersection = checkZoneOnActualRoute(zone);
                    if (intersection) {
                        routeAirspaces.push({
                            ...zone, type: 'MOA', color: '#d97706',
                            entry: intersection.entry, exit: intersection.exit
                        });
                    }
                });

                // Avoided airspaces are not drawn on profile - they're already avoided
                // so no need to show them (route doesn't pass through them)

                // Draw IFR/LIFR weather zones along the route
                const weatherInfluenceRadius = 50; // NM
                const avoidedWeatherZones = currentRouteData?.avoidanceManeuvers?.filter(m => m.type === 'weather').map(m => m.zone) || [];

                // Find weather hazards along direct route for profile display
                const poorWeatherStations = [];
                metarStations.forEach(station => {
                    const data = metarData[station.id];
                    if (data && (data.flight_rules === 'IFR' || data.flight_rules === 'LIFR')) {
                        // Check if near the direct route
                        let nearRoute = false;
                        for (let p = 0; p <= 1; p += 0.05) {
                            const routeLat = depStation.lat + p * (destStation.lat - depStation.lat);
                            const routeLon = depStation.lon + p * (destStation.lon - depStation.lon);
                            const dist = haversineNM(station.lat, station.lon, routeLat, routeLon);
                            if (dist < weatherInfluenceRadius) {
                                nearRoute = true;
                                // Calculate entry/exit progress
                                const existingWx = poorWeatherStations.find(w => w.id === station.id);
                                if (!existingWx) {
                                    poorWeatherStations.push({
                                        id: station.id,
                                        lat: station.lat,
                                        lon: station.lon,
                                        flightRules: data.flight_rules,
                                        entry: p,
                                        exit: p,
                                        avoided: avoidedWeatherZones.includes(`WX-${station.id}`)
                                    });
                                } else {
                                    existingWx.exit = p;
                                }
                            }
                        }
                    }
                });

                // Draw weather hazard zones on profile
                poorWeatherStations.forEach(wx => {
                    const xStart = padding + Math.max(0, wx.entry - 0.05) * (width - padding - paddingRight);
                    const xEnd = padding + Math.min(1, wx.exit + 0.05) * (width - padding - paddingRight);
                    const yTop = padding;
                    const yBottom = profileBottom;

                    const wxColor = wx.flightRules === 'LIFR' ? '#a855f7' : '#ef4444'; // Purple for LIFR, red for IFR

                    if (wx.avoided) {
                        // Ghosted/avoided styling
                        ctx.fillStyle = wxColor + '10';
                        ctx.fillRect(xStart, yTop, xEnd - xStart, yBottom - yTop);

                        // Diagonal stripes
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(xStart, yTop, xEnd - xStart, yBottom - yTop);
                        ctx.clip();
                        ctx.strokeStyle = wxColor + '20';
                        ctx.lineWidth = 1 / zoom;
                        const stripeSpacing = 15 / zoom;
                        for (let x = xStart - (yBottom - yTop); x < xEnd + stripeSpacing; x += stripeSpacing) {
                            ctx.beginPath();
                            ctx.moveTo(x, yBottom);
                            ctx.lineTo(x + (yBottom - yTop), yTop);
                            ctx.stroke();
                        }
                        ctx.restore();

                        // Label
                        ctx.fillStyle = '#22c55e';
                        ctx.font = `bold ${9 / zoom}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText(`${wx.flightRules} `, (xStart + xEnd) / 2, yTop + 20 / zoom);
                    } else {
                        // Active weather hazard styling
                        ctx.fillStyle = wxColor + '20';
                        ctx.fillRect(xStart, yTop, xEnd - xStart, yBottom - yTop);

                        // Border
                        ctx.strokeStyle = wxColor;
                        ctx.lineWidth = 2 / zoom;
                        ctx.setLineDash([6 / zoom, 3 / zoom]);
                        ctx.strokeRect(xStart, yTop, xEnd - xStart, yBottom - yTop);
                        ctx.setLineDash([]);

                        // Label
                        ctx.fillStyle = wxColor;
                        ctx.font = `bold ${10 / zoom}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText(` ${wx.flightRules}`, (xStart + xEnd) / 2, yTop + 20 / zoom);
                        ctx.font = `${8 / zoom}px sans-serif`;
                        ctx.fillText(wx.id, (xStart + xEnd) / 2, yTop + 32 / zoom);
                    }
                });

                // Draw diversion waypoint markers on profile (airspace avoidance - orange)
                const divertWaypoints = currentRouteData?.waypoints?.filter(wp => wp.type === 'divert') || [];
                divertWaypoints.forEach(wp => {
                    // Calculate position along route (as fraction of total distance)
                    const wpDist = wp.distance || 0;
                    const totalDist = currentRouteData?.distance || distance;
                    const progress = Math.min(wpDist / totalDist, 1);

                    const x = padding + progress * (width - padding - paddingRight);

                    // Draw vertical diversion marker line
                    ctx.strokeStyle = '#f97316'; // Orange for diversion
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([4 / zoom, 2 / zoom]);
                    ctx.beginPath();
                    ctx.moveTo(x, profileBottom);
                    ctx.lineTo(x, padding);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw diamond marker at a fixed vertical position
                    const markerY = padding + 30 / zoom;
                    const size = 6 / zoom;
                    ctx.fillStyle = '#f97316';
                    ctx.beginPath();
                    ctx.moveTo(x, markerY - size);
                    ctx.lineTo(x + size, markerY);
                    ctx.lineTo(x, markerY + size);
                    ctx.lineTo(x - size, markerY);
                    ctx.closePath();
                    ctx.fill();

                    // Label
                    ctx.fillStyle = '#f97316';
                    ctx.font = `bold ${8 / zoom}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(wp.name || 'DVT', x, markerY - size - 4 / zoom);
                });

                // Draw weather avoidance waypoint markers (cyan to differentiate)
                const weatherAvoidWaypoints = currentRouteData?.waypoints?.filter(wp => wp.type === 'weather-avoidance') || [];
                weatherAvoidWaypoints.forEach(wp => {
                    const wpDist = wp.distance || 0;
                    const totalDist = currentRouteData?.distance || distance;
                    const progress = Math.min(wpDist / totalDist, 1);

                    const x = padding + progress * (width - padding - paddingRight);

                    // Draw vertical weather avoidance marker line (cyan)
                    ctx.strokeStyle = '#06b6d4';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([4 / zoom, 2 / zoom]);
                    ctx.beginPath();
                    ctx.moveTo(x, profileBottom);
                    ctx.lineTo(x, padding);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw cloud-like marker
                    const markerY = padding + 50 / zoom;
                    const size = 6 / zoom;
                    ctx.fillStyle = '#06b6d4';
                    ctx.beginPath();
                    ctx.arc(x, markerY, size, 0, Math.PI * 2);
                    ctx.fill();

                    // Weather symbol inside
                    ctx.fillStyle = '#1a1a1a';
                    ctx.font = `bold ${8 / zoom}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('', x, markerY + 3 / zoom);

                    // Label
                    ctx.fillStyle = '#06b6d4';
                    ctx.font = `bold ${8 / zoom}px sans-serif`;
                    ctx.fillText(wp.name || 'WX', x, markerY - size - 4 / zoom);
                });

                // Draw each ACTIVE (not avoided) airspace at its actual position along route
                routeAirspaces.forEach(zone => {
                    const xStart = padding + zone.entry * (width - padding - paddingRight);
                    const xEnd = padding + zone.exit * (width - padding - paddingRight);
                    const yTop = profileBottom - (Math.min(zone.ceiling, 50000) / maxAltitude) * profileHeight;
                    const yBottom = profileBottom - ((zone.floor || 0) / maxAltitude) * profileHeight;

                    // Fill
                    ctx.fillStyle = zone.color + '30';
                    ctx.fillRect(xStart, yTop, xEnd - xStart, yBottom - yTop);

                    // Border with dashed line
                    ctx.strokeStyle = zone.color;
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 3 / zoom]);
                    ctx.strokeRect(xStart, yTop, xEnd - xStart, yBottom - yTop);
                    ctx.setLineDash([]);

                    // Label with name - cap apparent size at ~9px
                    ctx.fillStyle = zone.color;
                    const fontSize = 9 / zoom;
                    ctx.font = `bold ${fontSize}px sans-serif`;
                    ctx.textAlign = 'center';
                    const labelText = zone.type === 'R' ? zone.name : (zone.type === 'P' ? ` ${zone.name}` : zone.name);
                    ctx.fillText(labelText, (xStart + xEnd) / 2, yTop - 4 / zoom);

                    // Floor/Ceiling label - cap apparent size at ~8px
                    ctx.font = `${8 / zoom}px sans-serif`;
                    const floorStr = (zone.floor || 0) === 0 ? 'SFC' : `${(zone.floor / 1000).toFixed(0)}k`;
                    const ceilStr = zone.ceiling >= 99999 ? 'UNL' : `${(zone.ceiling / 1000).toFixed(0)}k`;
                    ctx.fillText(`${floorStr}-${ceilStr}`, (xStart + xEnd) / 2, yTop + 10 / zoom);
                });
            }

            // Draw clouds overlay
            if (profileOverlays.clouds) {
                // Simulate scattered cloud layers - more detail when zoomed
                const cloudLayers = [
                    { base: 8000, top: 12000, coverage: 0.4 },
                    { base: 18000, top: 22000, coverage: 0.6 },
                    { base: 28000, top: 32000, coverage: 0.3 }
                ];

                // Add intermediate layers when zoomed
                if (zoom >= 2) {
                    cloudLayers.push(
                        { base: 5000, top: 7000, coverage: 0.3 },
                        { base: 14000, top: 16000, coverage: 0.35 },
                        { base: 24000, top: 26000, coverage: 0.25 }
                    );
                }

                cloudLayers.forEach(layer => {
                    const baseY = profileBottom - (layer.base / maxAltitude) * profileHeight;
                    const topY = profileBottom - (layer.top / maxAltitude) * profileHeight;

                    // Draw more cloud shapes when zoomed
                    ctx.fillStyle = 'rgba(148, 163, 184, 0.25)';
                    const numClouds = Math.floor(15 * Math.max(1, zoom));
                    for (let i = 0; i < numClouds; i++) {
                        const x = padding + seededRandom() * (width - padding - paddingRight);
                        const cloudWidth = (30 + seededRandom() * 60) / zoom;
                        const cloudHeight = (baseY - topY) * 0.7;

                        if (seededRandom() < layer.coverage) {
                            ctx.beginPath();
                            ctx.ellipse(x, (baseY + topY) / 2, cloudWidth, cloudHeight / 2, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
            }

            // Draw icing overlay - based on actual icing zones the route passes through
            if (profileOverlays.icing) {
                // Sample points along the route to check for icing zone intersections
                const numSamples = 50;
                const routeIcingZones = [];

                for (let i = 0; i <= numSamples; i++) {
                    const t = i / numSamples;
                    const lat = depStation.lat + t * (destStation.lat - depStation.lat);
                    const lon = depStation.lon + t * (destStation.lon - depStation.lon);
                    const distNM = t * distance;

                    // Check each icing zone
                    flightHazards.icingZones.forEach(zone => {
                        if (pointInPolygon(lat, lon, zone.polygon)) {
                            // Check if we already have this zone or need to extend it
                            const existing = routeIcingZones.find(z => z.name === zone.name);
                            if (existing) {
                                existing.endDist = distNM;
                            } else {
                                routeIcingZones.push({
                                    name: zone.name,
                                    startDist: distNM,
                                    endDist: distNM,
                                    base: zone.base,
                                    top: zone.top,
                                    intensity: zone.intensity
                                });
                            }
                        }
                    });
                }

                // Draw each icing zone the route passes through
                routeIcingZones.forEach(zone => {
                    const startX = padding + (zone.startDist / distance) * (width - padding - paddingRight);
                    const endX = padding + (zone.endDist / distance) * (width - padding - paddingRight);
                    const zoneWidth = Math.max(endX - startX, 20); // Minimum width for visibility

                    const baseY = profileBottom - (zone.base / maxAltitude) * profileHeight;
                    const topY = profileBottom - (zone.top / maxAltitude) * profileHeight;

                    // Intensity-based opacity
                    const baseOpacity = zone.intensity.toLowerCase().includes('moderate') ? 0.35 : 0.25;

                    // Light blue gradient for icing zone
                    const icingGradient = ctx.createLinearGradient(0, topY, 0, baseY);
                    icingGradient.addColorStop(0, `rgba(6, 182, 212, ${baseOpacity})`);
                    icingGradient.addColorStop(0.5, `rgba(6, 182, 212, ${baseOpacity * 0.5})`);
                    icingGradient.addColorStop(1, `rgba(6, 182, 212, ${baseOpacity * 0.2})`);

                    ctx.fillStyle = icingGradient;
                    ctx.fillRect(startX, topY, zoneWidth, baseY - topY);

                    // Border for zone
                    ctx.strokeStyle = 'rgba(6, 182, 212, 0.5)';
                    ctx.lineWidth = 1 / zoom;
                    ctx.setLineDash([4 / zoom, 2 / zoom]);
                    ctx.strokeRect(startX, topY, zoneWidth, baseY - topY);
                    ctx.setLineDash([]);

                    // Draw ice crystal symbols within the zone
                    ctx.strokeStyle = 'rgba(6, 182, 212, 0.7)';
                    ctx.lineWidth = 1 / zoom;
                    const numSymbols = Math.max(2, Math.floor(zoneWidth / 40));
                    for (let i = 0; i < numSymbols; i++) {
                        const x = startX + 15 + i * ((zoneWidth - 30) / Math.max(1, numSymbols - 1));
                        const y = (topY + baseY) / 2 + (seededRandom() - 0.5) * 15;

                        // Draw snowflake
                        const flakeSize = 5 / zoom;
                        ctx.beginPath();
                        for (let j = 0; j < 6; j++) {
                            const angle = (j * Math.PI) / 3;
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + Math.cos(angle) * flakeSize, y + Math.sin(angle) * flakeSize);
                        }
                        ctx.stroke();
                    }

                    // Zone label
                    if (zoneWidth > 60) {
                        ctx.font = `${Math.max(8, 10 / zoom)}px sans-serif`;
                        ctx.fillStyle = 'rgba(6, 182, 212, 0.9)';
                        ctx.textAlign = 'center';
                        ctx.fillText(zone.intensity + ' Icing', startX + zoneWidth / 2, topY - 5 / zoom);
                        ctx.font = `${Math.max(7, 9 / zoom)}px sans-serif`;
                        ctx.fillStyle = 'rgba(6, 182, 212, 0.7)';
                        ctx.fillText(`${(zone.base/1000).toFixed(0)}K-${(zone.top/1000).toFixed(0)}K ft`, startX + zoneWidth / 2, topY + 12 / zoom);
                    }
                });

            }

            // Draw turbulence overlay - based on actual turbulence zones the route passes through
            if (profileOverlays.turbulence) {
                // Sample points along the route to check for turbulence zone intersections
                const numSamples = 50;
                const routeTurbZones = [];

                for (let i = 0; i <= numSamples; i++) {
                    const t = i / numSamples;
                    const lat = depStation.lat + t * (destStation.lat - depStation.lat);
                    const lon = depStation.lon + t * (destStation.lon - depStation.lon);
                    const distNM = t * distance;

                    // Check each turbulence zone
                    flightHazards.turbulenceZones.forEach(zone => {
                        if (pointInPolygon(lat, lon, zone.polygon)) {
                            const existing = routeTurbZones.find(z => z.name === zone.name);
                            if (existing) {
                                existing.endDist = distNM;
                            } else {
                                routeTurbZones.push({
                                    name: zone.name,
                                    startDist: distNM,
                                    endDist: distNM,
                                    base: zone.base,
                                    top: zone.top,
                                    intensity: zone.intensity
                                });
                            }
                        }
                    });
                }

                // Draw each turbulence zone the route passes through
                routeTurbZones.forEach(zone => {
                    const startX = padding + (zone.startDist / distance) * (width - padding - paddingRight);
                    const endX = padding + (zone.endDist / distance) * (width - padding - paddingRight);
                    const zoneWidth = Math.max(endX - startX, 20);

                    const baseY = profileBottom - (zone.base / maxAltitude) * profileHeight;
                    const topY = profileBottom - (zone.top / maxAltitude) * profileHeight;

                    // Intensity-based opacity
                    const isSevere = zone.intensity.toLowerCase().includes('severe');
                    const isModerate = zone.intensity.toLowerCase().includes('moderate');
                    const baseOpacity = isSevere ? 0.4 : (isModerate ? 0.3 : 0.2);

                    // Orange gradient for turbulence zone
                    const turbGradient = ctx.createLinearGradient(0, topY, 0, baseY);
                    turbGradient.addColorStop(0, `rgba(249, 115, 22, ${baseOpacity})`);
                    turbGradient.addColorStop(0.5, `rgba(249, 115, 22, ${baseOpacity * 0.6})`);
                    turbGradient.addColorStop(1, `rgba(249, 115, 22, ${baseOpacity * 0.3})`);

                    ctx.fillStyle = turbGradient;
                    ctx.fillRect(startX, topY, zoneWidth, baseY - topY);

                    // Border for zone
                    ctx.strokeStyle = `rgba(249, 115, 22, ${isSevere ? 0.8 : 0.5})`;
                    ctx.lineWidth = (isSevere ? 2 : 1) / zoom;
                    ctx.setLineDash([4 / zoom, 2 / zoom]);
                    ctx.strokeRect(startX, topY, zoneWidth, baseY - topY);
                    ctx.setLineDash([]);

                    // Draw wavy turbulence lines within the zone
                    ctx.strokeStyle = `rgba(249, 115, 22, 0.6)`;
                    ctx.lineWidth = (isModerate || isSevere ? 2 : 1.5) / zoom;

                    const midAlt = (zone.base + zone.top) / 2;
                    const midY = profileBottom - (midAlt / maxAltitude) * profileHeight;

                    ctx.beginPath();
                    const step = Math.max(1, 3 / zoom);
                    for (let x = startX; x <= startX + zoneWidth; x += step) {
                        const wave = Math.sin(x / 6) * 5 + Math.sin(x / 12) * 3;
                        const y = midY + wave;
                        if (x === startX) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();

                    // Zone label
                    if (zoneWidth > 50) {
                        ctx.font = `${Math.max(8, 10 / zoom)}px sans-serif`;
                        ctx.fillStyle = 'rgba(249, 115, 22, 0.9)';
                        ctx.textAlign = 'center';
                        ctx.fillText(zone.intensity + ' Turb', startX + zoneWidth / 2, topY - 5 / zoom);
                        ctx.font = `${Math.max(7, 9 / zoom)}px sans-serif`;
                        ctx.fillStyle = 'rgba(249, 115, 22, 0.7)';
                        ctx.fillText(`${(zone.base/1000).toFixed(0)}K-${(zone.top/1000).toFixed(0)}K ft`, startX + zoneWidth / 2, topY + 12 / zoom);
                    }
                });

            }

            // Draw winds overlay - HAZARDS ONLY: strong winds >= 30 knots
            // Store wind band positions for labels drawn after restore
            const windBandPositions = [];
            if (profileOverlays.winds) {
                // Wind data at different altitude bands (base to top of band)
                const windBands = [
                    { base: 0, top: 6000, speed: 15, dir: 270, label: 'Surface-6K' },
                    { base: 6000, top: 12000, speed: 35, dir: 280, label: '6K-12K' },
                    { base: 10000, top: 12500, speed: 45, dir: 280, label: '10K-12.5K' }
                ];

                // Strong wind threshold (knots) - only show bands >= this
                const strongWindThreshold = 30;

                // Draw each wind band - ONLY CONCERNING WINDS
                windBands.forEach((band, bandIdx) => {
                    // Skip light winds that aren't concerning
                    if (band.speed < strongWindThreshold) return;

                    const baseY = profileBottom - (band.base / maxAltitude) * profileHeight;
                    const topY = profileBottom - (band.top / maxAltitude) * profileHeight;
                    const bandHeight = baseY - topY;
                    const midY = (topY + baseY) / 2;

                    // Store position for labels (will be drawn after restore)
                    windBandPositions.push({
                        speed: band.speed,
                        dir: band.dir,
                        baseY: band.base,
                        topY: band.top
                    });

                    // Color based on wind severity
                    // 30-50 kt = moderate (green), 50-80 kt = strong (yellow/amber), 80+ kt = severe (red)
                    let colorR, colorG, colorB;
                    if (band.speed >= 80) {
                        colorR = 239; colorG = 68; colorB = 68; // Red - severe winds
                    } else if (band.speed >= 50) {
                        colorR = 245; colorG = 158; colorB = 11; // Amber - strong winds
                    } else {
                        colorR = 34; colorG = 197; colorB = 94; // Green - moderate winds
                    }

                    // Color intensity based on wind speed
                    const speedNorm = Math.min(band.speed / 150, 1); // Normalize to 0-1
                    const baseOpacity = 0.12 + speedNorm * 0.18;

                    // Gradient for wind band
                    const windGradient = ctx.createLinearGradient(0, topY, 0, baseY);
                    windGradient.addColorStop(0, `rgba(${colorR}, ${colorG}, ${colorB}, ${baseOpacity * 1.2})`);
                    windGradient.addColorStop(0.5, `rgba(${colorR}, ${colorG}, ${colorB}, ${baseOpacity})`);
                    windGradient.addColorStop(1, `rgba(${colorR}, ${colorG}, ${colorB}, ${baseOpacity * 0.8})`);

                    ctx.fillStyle = windGradient;
                    ctx.fillRect(padding, topY, width - padding - paddingRight, bandHeight);

                    // Border for wind zone
                    ctx.strokeStyle = `rgba(${colorR}, ${colorG}, ${colorB}, 0.3)`;
                    ctx.lineWidth = 0.5 / zoom;
                    ctx.beginPath();
                    ctx.moveTo(padding, topY);
                    ctx.lineTo(width - paddingRight, topY);
                    ctx.stroke();

                    // Draw wind direction arrows distributed across the band
                    const numArrows = Math.max(3, Math.floor((width - padding - paddingRight) / 100));
                    const arrowSpacing = (width - padding - paddingRight) / (numArrows + 1);

                    // Convert meteorological wind direction to arrow angle
                    // Wind FROM direction, so arrow points in direction wind is going
                    const windRad = (band.dir + 180) * Math.PI / 180;

                    ctx.strokeStyle = `rgba(${colorR}, ${colorG}, ${colorB}, ${0.5 + speedNorm * 0.4})`;
                    ctx.fillStyle = `rgba(${colorR}, ${colorG}, ${colorB}, ${0.5 + speedNorm * 0.4})`;
                    ctx.lineWidth = (1.5 + speedNorm) / zoom;

                    for (let i = 1; i <= numArrows; i++) {
                        const x = padding + i * arrowSpacing;
                        const y = midY + (seededRandom() - 0.5) * (bandHeight * 0.3);

                        // Arrow length proportional to wind speed
                        const arrowLen = (12 + band.speed * 0.08) / zoom;
                        const headSize = (3 + speedNorm * 2) / zoom;

                        // Calculate arrow end point (pointing in wind direction)
                        const endX = x + Math.sin(windRad) * arrowLen;
                        const endY = y - Math.cos(windRad) * arrowLen;

                        // Draw arrow shaft
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Draw arrow head
                        const headAngle = Math.atan2(endY - y, endX - x);
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(
                            endX - headSize * Math.cos(headAngle - Math.PI / 6),
                            endY - headSize * Math.sin(headAngle - Math.PI / 6)
                        );
                        ctx.lineTo(
                            endX - headSize * Math.cos(headAngle + Math.PI / 6),
                            endY - headSize * Math.sin(headAngle + Math.PI / 6)
                        );
                        ctx.closePath();
                        ctx.fill();
                    }
                });

                // Show message if no concerning winds
                if (windBandPositions.length === 0) {
                    ctx.font = `${Math.max(9, 11 / zoom)}px sans-serif`;
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.5)';
                    ctx.textAlign = 'center';
                    ctx.fillText('Light winds along route', width / 2, profileBottom - (20000 / maxAltitude) * profileHeight);
                }
            }

            // Draw optimized flight path with dynamic altitude changes
            if (optimizedPath && optimizedPath.length > 0) {
                ctx.setLineDash([]);

                // Get first and last waypoint positions
                const firstWp = optimizedPath[0];
                const lastWp = optimizedPath[optimizedPath.length - 1];
                const firstX = padding + firstWp.t * (width - padding - paddingRight);
                const firstY = profileBottom - (firstWp.altitude / maxAltitude) * profileHeight;
                const lastX = padding + lastWp.t * (width - padding - paddingRight);
                const lastY = profileBottom - (lastWp.altitude / maxAltitude) * profileHeight;

                // Draw flight path shadow (ultra-smooth extended gradient underglow)
                const shadowPasses = [
                    { offset: 40, opacity: 0.008, width: 22 },
                    { offset: 35, opacity: 0.012, width: 20 },
                    { offset: 30, opacity: 0.018, width: 18 },
                    { offset: 26, opacity: 0.025, width: 16 },
                    { offset: 22, opacity: 0.035, width: 14 },
                    { offset: 18, opacity: 0.045, width: 12 },
                    { offset: 15, opacity: 0.06, width: 10 },
                    { offset: 12, opacity: 0.08, width: 9 },
                    { offset: 9, opacity: 0.1, width: 8 },
                    { offset: 7, opacity: 0.13, width: 7 },
                    { offset: 5, opacity: 0.17, width: 6 },
                    { offset: 3.5, opacity: 0.22, width: 5 },
                    { offset: 2, opacity: 0.28, width: 4 },
                ];
                ctx.lineCap = 'round';
                shadowPasses.forEach(pass => {
                    ctx.beginPath();
                    ctx.moveTo(firstX, firstY + pass.offset / zoom);
                    for (let i = 1; i < optimizedPath.length; i++) {
                        const wp = optimizedPath[i];
                        const x = padding + wp.t * (width - padding - paddingRight);
                        const y = profileBottom - (wp.altitude / maxAltitude) * profileHeight;
                        ctx.lineTo(x, y + pass.offset / zoom);
                    }
                    ctx.strokeStyle = `rgba(0, 0, 0, ${pass.opacity})`;
                    ctx.lineWidth = pass.width / zoom;
                    ctx.stroke();
                });

                // Draw flight path highlight (ultra-smooth extended gradient top glow - subtle)
                const highlightPasses = [
                    { offset: -35, opacity: 0.003, width: 20 },
                    { offset: -30, opacity: 0.005, width: 18 },
                    { offset: -26, opacity: 0.008, width: 16 },
                    { offset: -22, opacity: 0.01, width: 14 },
                    { offset: -18, opacity: 0.014, width: 12 },
                    { offset: -15, opacity: 0.018, width: 10 },
                    { offset: -12, opacity: 0.022, width: 9 },
                    { offset: -9, opacity: 0.028, width: 8 },
                    { offset: -7, opacity: 0.032, width: 7 },
                    { offset: -5, opacity: 0.04, width: 6 },
                    { offset: -3.5, opacity: 0.048, width: 5 },
                    { offset: -2, opacity: 0.055, width: 4 },
                ];
                highlightPasses.forEach(pass => {
                    ctx.beginPath();
                    ctx.moveTo(firstX, firstY + pass.offset / zoom);
                    for (let i = 1; i < optimizedPath.length; i++) {
                        const wp = optimizedPath[i];
                        const x = padding + wp.t * (width - padding - paddingRight);
                        const y = profileBottom - (wp.altitude / maxAltitude) * profileHeight;
                        ctx.lineTo(x, y + pass.offset / zoom);
                    }
                    ctx.strokeStyle = `rgba(255, 255, 255, ${pass.opacity})`;
                    ctx.lineWidth = pass.width / zoom;
                    ctx.stroke();
                });

                // Draw main flight path with phase-based coloring
                let currentPhase = null;
                ctx.beginPath();
                ctx.moveTo(firstX, firstY);

                for (let i = 0; i < optimizedPath.length; i++) {
                    const wp = optimizedPath[i];
                    const x = padding + wp.t * (width - padding - paddingRight);
                    const y = profileBottom - (wp.altitude / maxAltitude) * profileHeight;

                    // Change color based on flight phase
                    if (wp.phase !== currentPhase && currentPhase !== null) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    }

                    ctx.lineTo(x, y);
                    currentPhase = wp.phase;

                    // Set color based on phase (darker base colors so pulse is visible)
                    if (wp.phase === 'climb') {
                        ctx.strokeStyle = '#166534'; // Dark green for climb base
                    } else if (wp.phase === 'descent') {
                        ctx.strokeStyle = '#92400e'; // Dark amber for descent base
                    } else {
                        ctx.strokeStyle = '#6b7280'; // Gray for cruise
                    }
                }
                ctx.lineWidth = 2.5 / zoom;
                ctx.stroke();

                // Draw waypoint markers at significant altitude changes
                ctx.fillStyle = themeColors.text;
                let prevAlt = 0;
                for (const wp of optimizedPath) {
                    const altChange = Math.abs(wp.altitude - prevAlt);
                    if (altChange >= 3000 && wp.phase === 'cruise') {
                        const x = padding + wp.t * (width - padding - paddingRight);
                        const y = profileBottom - (wp.altitude / maxAltitude) * profileHeight;
                        ctx.beginPath();
                        ctx.arc(x, y, 3 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    prevAlt = wp.altitude;
                }

                // Draw altitude labels at key points (TOC, cruise changes, TOD)
                // Helper to draw text with drop shadow
                function drawTextWithShadow(text, x, y, font) {
                    ctx.font = font;
                    ctx.textAlign = 'center';
                    // Draw shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillText(text, x + 1.5 / zoom, y + 1.5 / zoom);
                    // Draw main text
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(text, x, y);
                }

                // Find Top of Climb (TOC)
                const tocIdx = optimizedPath.findIndex(wp => wp.phase === 'cruise');
                if (tocIdx > 0) {
                    const toc = optimizedPath[tocIdx];
                    const x = padding + toc.t * (width - padding - paddingRight);
                    const y = profileBottom - (toc.altitude / maxAltitude) * profileHeight;
                    drawTextWithShadow(`TOC FL${Math.round(toc.altitude / 100)}`, x, y - 8 / zoom, `${9 / zoom}px sans-serif`);
                }

                // Find Top of Descent (TOD)
                const todIdx = optimizedPath.findIndex(wp => wp.phase === 'descent');
                if (todIdx > 0) {
                    const tod = optimizedPath[todIdx - 1];
                    const x = padding + tod.t * (width - padding - paddingRight);
                    const y = profileBottom - (tod.altitude / maxAltitude) * profileHeight;
                    drawTextWithShadow(`TOD FL${Math.round(tod.altitude / 100)}`, x, y - 8 / zoom, `${9 / zoom}px sans-serif`);
                }

                // Draw cruise altitude in middle
                const midCruise = optimizedPath[Math.floor(optimizedPath.length / 2)];
                if (midCruise && midCruise.phase === 'cruise') {
                    const x = padding + midCruise.t * (width - padding - paddingRight);
                    const y = profileBottom - (midCruise.altitude / maxAltitude) * profileHeight;
                    drawTextWithShadow(`FL${Math.round(midCruise.altitude / 100)}`, x, y - 10 / zoom, `bold ${10 / zoom}px sans-serif`);
                }

                // Draw custom waypoint markers on the profile
                // Use pre-calculated segmentCumDist for accurate positioning
                if (waypoints && waypoints.length > 0) {
                    waypoints.forEach((wp, idx) => {
                        // Use segmentCumDist which is calculated at top of drawProfile
                        // idx+1 because segmentCumDist[0] = 0 (departure), segmentCumDist[1] = dist to first waypoint, etc.
                        const wpDist = segmentCumDist[idx + 1];
                        const t = wpDist / distance;
                        const wpX = padding + t * (width - padding - paddingRight);

                        // Find altitude at this point from optimized path
                        const pathIdx = Math.min(Math.floor(t * optimizedPath.length), optimizedPath.length - 1);
                        const wpAlt = optimizedPath[pathIdx] ? optimizedPath[pathIdx].altitude : 10000;
                        const wpY = profileBottom - (wpAlt / maxAltitude) * profileHeight;

                        // Draw waypoint marker (diamond shape)
                        const size = 8 / zoom;
                        ctx.fillStyle = wp.isSnapped ? '#f59e0b' : '#06b6d4';
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1.5 / zoom;

                        ctx.beginPath();
                        ctx.moveTo(wpX, wpY - size);
                        ctx.lineTo(wpX + size, wpY);
                        ctx.lineTo(wpX, wpY + size);
                        ctx.lineTo(wpX - size, wpY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        // Draw waypoint label
                        ctx.fillStyle = themeColors.text;
                        ctx.font = `bold ${Math.max(8, 10 / zoom)}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText(wp.name, wpX, wpY - size - 5 / zoom);
                    });
                }

                // Draw stops with landing visualization (V-shaped profile dip)
                // Calculate stop positions along the actual route path (including waypoints)
                if (stops && stops.length > 0) {
                    stops.forEach((stop) => {
                        // Find where this stop falls along the route path
                        // Check each segment to find where the stop is closest
                        let bestT = 0;
                        let minDistToRoute = Infinity;

                        for (const seg of routeSegments) {
                            // Project stop onto this segment
                            const segLen = seg.end - seg.start;
                            if (segLen <= 0) continue;

                            // Vector from segment start to end
                            const dx = seg.p2.lon - seg.p1.lon;
                            const dy = seg.p2.lat - seg.p1.lat;

                            // Vector from segment start to stop
                            const fx = stop.lon - seg.p1.lon;
                            const fy = stop.lat - seg.p1.lat;

                            // Project stop onto segment line (0-1 normalized)
                            const segLenSq = dx * dx + dy * dy;
                            let proj = segLenSq > 0 ? (fx * dx + fy * dy) / segLenSq : 0;
                            proj = Math.max(0, Math.min(1, proj)); // Clamp to segment

                            // Find closest point on segment
                            const closestLon = seg.p1.lon + proj * dx;
                            const closestLat = seg.p1.lat + proj * dy;

                            // Distance from stop to closest point
                            const distToSeg = haversineDistanceNM(stop.lat, stop.lon, closestLat, closestLon);

                            if (distToSeg < minDistToRoute) {
                                minDistToRoute = distToSeg;
                                // Calculate t along entire route
                                bestT = (seg.start + proj * segLen) / distance;
                            }
                        }

                        const t = Math.min(bestT, 0.99);
                        const stopX = padding + t * (width - padding - paddingRight);
                        const groundY = height - padding; // Ground level (0 ft)

                        // Draw landing/takeoff profile lines (V-shape)
                        const descentWidth = 30 / zoom; // Width of descent slope
                        const climbWidth = 30 / zoom; // Width of climb slope

                        // Find altitude at this point from optimized path
                        const pathIdx = Math.min(Math.floor(t * optimizedPath.length), optimizedPath.length - 1);
                        const cruiseAlt = optimizedPath[pathIdx] ? optimizedPath[pathIdx].altitude : 10000;
                        const cruiseY = profileBottom - (cruiseAlt / maxAltitude) * profileHeight;

                        // Draw descent line
                        ctx.beginPath();
                        ctx.moveTo(stopX - descentWidth, cruiseY);
                        ctx.lineTo(stopX, groundY);
                        ctx.strokeStyle = '#f59e0b'; // Amber for descent
                        ctx.lineWidth = 2.5 / zoom;
                        ctx.stroke();

                        // Draw climb line
                        ctx.beginPath();
                        ctx.moveTo(stopX, groundY);
                        ctx.lineTo(stopX + climbWidth, cruiseY);
                        ctx.strokeStyle = '#22c55e'; // Green for climb
                        ctx.lineWidth = 2.5 / zoom;
                        ctx.stroke();

                        // Draw stop marker (runway icon) at ground level
                        const size = 10 / zoom;
                        ctx.fillStyle = '#3b82f6';
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2 / zoom;

                        // Draw runway rectangle
                        ctx.fillRect(stopX - size, groundY - 4 / zoom, size * 2, 4 / zoom);
                        ctx.strokeRect(stopX - size, groundY - 4 / zoom, size * 2, 4 / zoom);

                        // Draw landing aircraft icon
                        ctx.font = `${12 / zoom}px sans-serif`;
                        ctx.fillStyle = '#3b82f6';
                        ctx.textAlign = 'center';
                        ctx.fillText('', stopX, groundY - 10 / zoom);

                        // Draw stop label
                        ctx.fillStyle = '#3b82f6';
                        ctx.font = `bold ${Math.max(9, 11 / zoom)}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText(`STOP: ${stop.id}`, stopX, groundY - 20 / zoom);
                    });
                }
            }

            // Restore zoom/pan transform before drawing fixed axis labels
            ctx.restore();

            // Draw fixed axis frame (not affected by zoom)
            ctx.fillStyle = themeColors.bg;
            // Cover left axis area
            ctx.fillRect(0, 0, padding, height);
            // Cover bottom axis area
            ctx.fillRect(0, height - paddingBottom, width, paddingBottom);
            // Cover top area
            ctx.fillRect(0, 0, width, padding);
            // Cover right area
            ctx.fillRect(width - paddingRight, 0, paddingRight, height);

            // Draw axis border
            ctx.strokeStyle = themeColors.axisTick;
            ctx.lineWidth = 1;
            ctx.strokeRect(padding, padding, width - padding - paddingRight, height - padding - paddingBottom);

            // Calculate visible range based on zoom and pan
            const centerX = width / 2;
            const centerY = height / 2;

            // Reverse transform to find visible canvas coordinates
            // Screen to canvas: canvasCoord = (screenCoord - center - pan) / zoom + center
            const visibleCanvasLeft = (padding - centerX - profileView.panX) / zoom + centerX;
            const visibleCanvasRight = (width - paddingRight - centerX - profileView.panX) / zoom + centerX;
            const visibleCanvasTop = (padding - centerY - profileView.panY) / zoom + centerY;
            const visibleCanvasBottom = (height - paddingBottom - centerY - profileView.panY) / zoom + centerY;

            // Convert canvas Y to altitude (Y increases downward, altitude increases upward)
            const canvasToAlt = (canvasY) => {
                const normalized = (profileBottom - canvasY) / profileHeight;
                return normalized * maxAltitude;
            };

            // Convert canvas X to distance
            const canvasToDist = (canvasX) => {
                const normalized = (canvasX - padding) / (width - padding - paddingRight);
                return normalized * distance;
            };

            // Visible altitude and distance ranges
            const visibleAltMin = Math.max(0, canvasToAlt(visibleCanvasBottom));
            const visibleAltMax = Math.min(maxAltitude, canvasToAlt(visibleCanvasTop));
            const visibleDistMin = Math.max(0, canvasToDist(visibleCanvasLeft));
            const visibleDistMax = Math.min(distance, canvasToDist(visibleCanvasRight));

            // Y-axis labels (altitude) - only visible range with collision detection
            ctx.fillStyle = themeColors.textTertiary;
            ctx.strokeStyle = themeColors.axisTick;
            ctx.lineWidth = 1;
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';

            // Start from first label at or below visible min
            const firstAlt = Math.floor(visibleAltMin / altStep) * altStep;
            let lastAltLabelY = Infinity; // Track last drawn label position
            for (let alt = firstAlt; alt <= visibleAltMax + altStep; alt += altStep) {
                if (alt < 0 || alt > maxAltitude) continue;

                // Calculate screen position for this altitude
                const canvasY = height - paddingBottom - (alt / maxAltitude) * profileHeight;
                const screenY = (canvasY - centerY) * zoom + centerY + profileView.panY;

                // Only draw if on screen (in the axis area) AND not overlapping previous label
                if (screenY >= padding - 5 && screenY <= height - paddingBottom + 5) {
                    // Check for overlap with previous label (need at least 18px spacing)
                    if (lastAltLabelY - screenY >= 18) {
                        const label = alt >= 1000 ? `${alt/1000}k` : `${alt}`;
                        ctx.fillText(label, padding - 5, screenY + 3);
                        lastAltLabelY = screenY;
                    }
                    // Always draw tick mark
                    ctx.beginPath();
                    ctx.moveTo(padding - 3, screenY);
                    ctx.lineTo(padding, screenY);
                    ctx.stroke();
                }
            }

            // X-axis labels (distance) - only visible range with collision detection
            ctx.textAlign = 'center';

            // Start from first label at or below visible min
            const firstDist = Math.floor(visibleDistMin / distStep) * distStep;
            let lastDistLabelX = -Infinity; // Track last drawn label position
            for (let distNM = firstDist; distNM <= visibleDistMax + distStep; distNM += distStep) {
                if (distNM < 0 || distNM > distance) continue;

                // Calculate screen position for this distance
                const canvasX = padding + (distNM / distance) * (width - padding - paddingRight);
                const screenX = (canvasX - centerX) * zoom + centerX + profileView.panX;

                // Only draw if on screen (in the axis area) AND not overlapping previous label
                if (screenX >= padding - 5 && screenX <= width - paddingRight + 5) {
                    // Check for overlap with previous label (need at least 35px spacing)
                    if (screenX - lastDistLabelX >= 35) {
                        ctx.fillText(`${Math.round(distNM)}`, screenX, height - paddingBottom + 15);
                        lastDistLabelX = screenX;
                    }
                    // Always draw tick mark
                    ctx.beginPath();
                    ctx.moveTo(screenX, height - paddingBottom);
                    ctx.lineTo(screenX, height - paddingBottom + 3);
                    ctx.stroke();
                }
            }

            // Station labels - larger and higher
            ctx.fillStyle = themeColors.text;
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(depStation.id, padding + 30, height - 18);
            ctx.fillText(destStation.id, width - paddingRight - 30, height - 18);

            // Distance label - larger and higher
            ctx.fillStyle = themeColors.textSecondary;
            ctx.font = 'bold 13px sans-serif';
            ctx.fillText(`${Math.round(distance)} NM`, width / 2, height - 18);

            // Y-axis title
            ctx.save();
            ctx.translate(12, (height - paddingBottom + padding) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = themeColors.textTertiary;
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Altitude (ft)', 0, 0);
            ctx.restore();

            // X-axis title
            ctx.fillStyle = themeColors.textTertiary;
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Distance (NM)', width / 2, height - paddingBottom + 35);

            // Draw wind labels at fixed positions (outside zoomed context)
            if (profileOverlays.winds && windBandPositions.length > 0) {
                // Draw "WINDS ALOFT" title
                ctx.font = 'bold 11px sans-serif';
                ctx.fillStyle = 'rgba(34, 197, 94, 0.9)';
                ctx.textAlign = 'center';
                ctx.fillText('WINDS ALOFT', width / 2, padding + 15);

                // Draw wind speed labels on left and direction on right
                windBandPositions.forEach(band => {
                    // Calculate screen Y position for this band's midpoint
                    const midAlt = (band.baseY + band.topY) / 2;
                    const canvasY = height - paddingBottom - (midAlt / maxAltitude) * profileHeight;
                    const screenY = (canvasY - centerY) * zoom + centerY + profileView.panY;

                    // Only draw if visible within the profile area
                    if (screenY >= padding && screenY <= height - paddingBottom) {
                        const speedNorm = Math.min(band.speed / 150, 1);

                        // Speed label on left (inside padding area)
                        ctx.font = 'bold 9px sans-serif';
                        ctx.fillStyle = `rgba(34, 197, 94, ${0.7 + speedNorm * 0.3})`;
                        ctx.textAlign = 'left';
                        ctx.fillText(`${band.speed}kt`, padding + 5, screenY + 3);

                        // Direction label on right (inside padding area)
                        ctx.font = '9px sans-serif';
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${band.dir}`, width - paddingRight - 5, screenY + 3);
                    }
                });
            }

            // Zoom indicator in corner
            if (zoom > 1) {
                ctx.fillStyle = 'rgba(107, 114, 128, 0.8)';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(`${zoom.toFixed(1)}x`, width - paddingRight - 5, padding + 12);
            }

            // Draw X-Plane aircraft position if active
            if (xplaneState.enabled && xplaneState.receiving && xplaneState.profilePosition) {
                const { progress, alt, nearRoute } = xplaneState.profilePosition;

                // Calculate X position (progress along route)
                const profileWidth = width - padding - paddingRight;
                const xPos = padding + (progress * profileWidth);

                // Calculate Y position (altitude) - clamp to visible range
                // If aircraft is above max altitude, show at top; if below 0, show at bottom
                const clampedAlt = Math.max(0, Math.min(alt, maxAltitude * 1.1));
                const yPos = height - paddingBottom - (clampedAlt / maxAltitude) * profileHeight;

                // Apply zoom transform to position
                const screenX = (xPos - centerX) * zoom + centerX + profileView.panX;
                const screenY = (yPos - centerY) * zoom + centerY + profileView.panY;

                // Clamp to visible area (always show the aircraft, clamped to bounds)
                const clampedScreenX = Math.max(padding + 10, Math.min(width - paddingRight - 10, screenX));
                const clampedScreenY = Math.max(padding + 15, Math.min(height - paddingBottom - 10, screenY));

                // Draw aircraft marker
                {
                    ctx.save();
                    ctx.translate(clampedScreenX, clampedScreenY);

                    // Glow effect
                    ctx.shadowColor = '#3b82f6';
                    ctx.shadowBlur = 12;

                    // Aircraft triangle (pointing up/right like direction of flight)
                    ctx.fillStyle = nearRoute ? '#3b82f6' : '#f59e0b';
                    ctx.beginPath();
                    ctx.moveTo(0, -10);   // Top point
                    ctx.lineTo(-7, 8);    // Bottom left
                    ctx.lineTo(7, 8);     // Bottom right
                    ctx.closePath();
                    ctx.fill();

                    // Inner highlight
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(0, -6);
                    ctx.lineTo(-4, 4);
                    ctx.lineTo(4, 4);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();

                    // Altitude label above aircraft
                    ctx.save();
                    ctx.fillStyle = nearRoute ? '#3b82f6' : '#f59e0b';
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0,0,0,0.8)';
                    ctx.shadowBlur = 4;
                    ctx.fillText(`${Math.round(alt).toLocaleString()} ft`, clampedScreenX, clampedScreenY - 16);
                    ctx.restore();
                }
            }

            // Store profile data for hover (use original coordinates, not transformed)
            profileHoverData = {
                width, height, padding, paddingRight, paddingBottom, distance,
                depStation, destStation,
                depMetar, destMetar,
                terrainSeed: (depStation.lat * 1000 + destStation.lon * 100) % 1000,
                zoom: profileView.zoom,
                panX: profileView.panX,
                panY: profileView.panY,
                optimizedPath: optimizedPath, // Store flight path for hover
                terrainProfile: terrainProfile,
                maxAltitude: maxAltitude // Dynamic altitude scale
            };

            // Save the base profile image for animation and start pulse animation
            profileBaseImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            startProfilePulseAnimation();
        }

        // Profile hover data storage
        let profileHoverData = null;

        // Profile pulse animation state
        let profilePulseAnimationId = null;
        let profilePulsePosition = 0; // 0 to 1 for climb, 0 to 1 for descent
        let profileBaseImageData = null; // Store base profile for animation restore

        function animateProfilePulse() {
            if (!profileHoverData || !profileHoverData.optimizedPath) {
                profilePulseAnimationId = requestAnimationFrame(animateProfilePulse);
                return;
            }

            const canvas = document.getElementById('profileCanvas');
            const ctx = canvas.getContext('2d');
            const { width, height, optimizedPath } = profileHoverData;
            // Use the same padding values as drawProfile
            const padding = profileHoverData.padding || 40;
            const paddingRight = profileHoverData.paddingRight || 60;
            const paddingBottom = profileHoverData.paddingBottom || 80;
            const zoom = profileHoverData.zoom || 1;
            const maxAltitude = profileHoverData.maxAltitude || 15000;
            const profileHeight = height - padding - paddingBottom;
            const profileBottom = height - paddingBottom;

            // Restore base profile image before drawing pulse
            if (profileBaseImageData) {
                ctx.putImageData(profileBaseImageData, 0, 0);
            }

            // Apply the same zoom/pan transforms as the profile
            const panX = profileHoverData.panX || 0;
            const panY = profileHoverData.panY || 0;
            ctx.save();

            // Clip to profile canvas bounds (prevent pulse from exceeding container)
            ctx.beginPath();
            ctx.rect(padding, padding, width - padding - paddingRight, height - padding - paddingBottom);
            ctx.clip();

            ctx.translate(width / 2 + panX, height / 2 + panY);
            ctx.scale(zoom, zoom);
            ctx.translate(-width / 2, -height / 2);

            // Animate pulse position (cycles every ~5 seconds at 60fps)
            profilePulsePosition = (profilePulsePosition + 0.002) % 1;

            // Helper to convert path point to screen coordinates (must match drawProfile exactly)
            function toScreen(wp) {
                const x = padding + wp.t * (width - padding - paddingRight);
                const y = profileBottom - (wp.altitude / maxAltitude) * profileHeight;
                return { x, y };
            }

            // Helper to interpolate between two points
            function interpolatePoint(p1, p2, ratio) {
                return {
                    x: p1.x + (p2.x - p1.x) * ratio,
                    y: p1.y + (p2.y - p1.y) * ratio
                };
            }

            // Helper to draw smooth LED pulse along phase path
            function drawPulseLine(phase, rgbColor) {
                // Get all points for this phase
                const phasePoints = optimizedPath.filter(wp => wp.phase === phase);
                if (phasePoints.length < 2) return;

                // Convert to screen coordinates
                const screenPoints = phasePoints.map(toScreen);

                // Calculate cumulative distances for accurate interpolation
                const distances = [0];
                let totalDist = 0;
                for (let i = 1; i < screenPoints.length; i++) {
                    const dx = screenPoints[i].x - screenPoints[i-1].x;
                    const dy = screenPoints[i].y - screenPoints[i-1].y;
                    totalDist += Math.sqrt(dx * dx + dy * dy);
                    distances.push(totalDist);
                }

                // Pulse parameters
                const pulseHead = profilePulsePosition;
                const tailLength = 0.25; // Smoother, longer tail
                const pulseStart = Math.max(0, pulseHead - tailLength);

                // Find the segment and position for pulse head and tail
                function getPointAtProgress(progress) {
                    const targetDist = progress * totalDist;
                    for (let i = 1; i < distances.length; i++) {
                        if (targetDist <= distances[i]) {
                            const segmentStart = distances[i-1];
                            const segmentEnd = distances[i];
                            const segmentRatio = (targetDist - segmentStart) / (segmentEnd - segmentStart);
                            return interpolatePoint(screenPoints[i-1], screenPoints[i], segmentRatio);
                        }
                    }
                    return screenPoints[screenPoints.length - 1];
                }

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw the pulse as multiple smooth gradient segments
                const numSegments = 30; // Smooth segments for the pulse
                for (let layer = 0; layer < 3; layer++) {
                    const layerWidth = (2.5 + layer * 0.8) / zoom;

                    ctx.beginPath();
                    let started = false;

                    for (let i = 0; i <= numSegments; i++) {
                        const segProgress = pulseStart + (pulseHead - pulseStart) * (i / numSegments);
                        if (segProgress < 0 || segProgress > 1) continue;

                        const pt = getPointAtProgress(segProgress);

                        if (!started) {
                            ctx.moveTo(pt.x, pt.y);
                            started = true;
                        } else {
                            ctx.lineTo(pt.x, pt.y);
                        }
                    }

                    // Calculate opacity based on layer (inner = brighter)
                    const baseOpacity = 0.4 - layer * 0.12;

                    // Create gradient along the path
                    if (started && pulseHead > pulseStart) {
                        const startPt = getPointAtProgress(pulseStart);
                        const endPt = getPointAtProgress(pulseHead);
                        const gradient = ctx.createLinearGradient(startPt.x, startPt.y, endPt.x, endPt.y);
                        gradient.addColorStop(0, `rgba(${rgbColor}, 0)`);
                        gradient.addColorStop(0.7, `rgba(${rgbColor}, ${baseOpacity * 0.6})`);
                        gradient.addColorStop(1, `rgba(${rgbColor}, ${baseOpacity})`);

                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = layerWidth;
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }

            // Draw climb pulse (green LED)
            drawPulseLine('climb', '34, 197, 94');

            // Draw cruise pulse (white/grey LED)
            drawPulseLine('cruise', '180, 180, 180');

            // Draw descent pulse (amber LED)
            drawPulseLine('descent', '245, 158, 11');

            // Restore the main transform context
            ctx.restore();

            profilePulseAnimationId = requestAnimationFrame(animateProfilePulse);
        }

        function startProfilePulseAnimation() {
            if (!profilePulseAnimationId) {
                profilePulsePosition = 0;
                animateProfilePulse();
            }
        }

        function stopProfilePulseAnimation() {
            if (profilePulseAnimationId) {
                cancelAnimationFrame(profilePulseAnimationId);
                profilePulseAnimationId = null;
            }
        }

        // Profile hover functionality
        function setupProfileHover() {
            const canvas = document.getElementById('profileCanvas');
            const container = document.getElementById('profileContainer');
            const tooltip = document.getElementById('profileTooltip');
            const crosshair = document.getElementById('profileCrosshair');
            const journeyMarker = document.getElementById('journeyMarker');

            canvas.addEventListener('mousemove', (e) => {
                if (!profileHoverData || !currentRoute.dep || profileView.isDragging) return;

                // If pinned, don't update hover display - keep showing pinned data
                if (profilePinnedPoint) return;

                const rect = canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;

                const { width, height, padding, paddingRight, paddingBottom, distance, depStation, destStation, depMetar, destMetar, optimizedPath, terrainProfile, maxAltitude } = profileHoverData;
                const profileHeight = height - padding - paddingBottom;
                const profileBottom = height - paddingBottom;

                // Transform screen coordinates back to canvas coordinates (accounting for zoom/pan)
                const zoom = profileView.zoom;
                const centerX = width / 2;
                const centerY = height / 2;

                // Reverse the transform: screen = (canvas - center) * zoom + center + pan
                // So: canvas = (screen - center - pan) / zoom + center
                const x = (screenX - centerX - profileView.panX) / zoom + centerX;
                const y = (screenY - centerY - profileView.panY) / zoom + centerY;

                // Check if within profile area (in canvas coordinates)
                if (x < padding || x > width - paddingRight || y < padding || y > height - paddingBottom) {
                    tooltip.classList.remove('visible');
                    crosshair.classList.remove('visible');
                    journeyMarker.classList.remove('visible');
                    return;
                }

                // Calculate progress along route (0 to 1)
                const progress = Math.max(0, Math.min(1, (x - padding) / (width - padding - paddingRight)));
                const distanceAlong = Math.round(progress * distance);

                // Calculate current position
                const lat = depStation.lat + progress * (destStation.lat - depStation.lat);
                const lon = depStation.lon + progress * (destStation.lon - depStation.lon);

                // Calculate altitude at cursor position
                const altitudeRatio = Math.max(0, Math.min(1, (profileBottom - y) / profileHeight));
                const cursorAltitude = Math.round(altitudeRatio * maxAltitude);

                // Find closest point on the journey line
                let isNearJourney = false;
                let journeyWaypoint = null;
                let journeyScreenX = screenX;
                let journeyScreenY = screenY;
                let journeyProgress = progress;

                if (optimizedPath && optimizedPath.length > 0) {
                    // Find the waypoint closest to cursor's X position (progress)
                    let closestIdx = 0;
                    let closestDist = Infinity;

                    for (let i = 0; i < optimizedPath.length; i++) {
                        const wp = optimizedPath[i];
                        const wpProgress = wp.t;
                        const dist = Math.abs(wpProgress - progress);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestIdx = i;
                        }
                    }

                    journeyWaypoint = optimizedPath[closestIdx];
                    journeyProgress = journeyWaypoint.t;

                    // Calculate journey line Y position at this progress
                    const journeyCanvasY = profileBottom - (journeyWaypoint.altitude / maxAltitude) * profileHeight;

                    // Convert journey canvas position to screen position
                    journeyScreenX = (padding + journeyProgress * (width - padding - paddingRight) - centerX) * zoom + centerX + profileView.panX;
                    journeyScreenY = (journeyCanvasY - centerY) * zoom + centerY + profileView.panY;

                    // Check if cursor is near the journey line (within 30 pixels vertically)
                    const verticalDistance = Math.abs(screenY - journeyScreenY);
                    isNearJourney = verticalDistance < 30;
                }

                // Update crosshair
                crosshair.style.left = `${screenX}px`;
                crosshair.style.top = `${Math.max(0, screenY - 50)}px`;
                crosshair.style.height = `${Math.min(height, 100)}px`;
                crosshair.classList.add('visible');

                // Show/hide journey marker based on proximity
                if (isNearJourney && journeyWaypoint) {
                    journeyMarker.style.left = `${journeyScreenX}px`;
                    journeyMarker.style.top = `${journeyScreenY}px`;
                    journeyMarker.classList.add('visible');

                    // Set phase-based color
                    journeyMarker.classList.remove('climb', 'cruise', 'descent');
                    if (journeyWaypoint.phase) {
                        journeyMarker.classList.add(journeyWaypoint.phase);
                    }
                } else {
                    journeyMarker.classList.remove('visible');
                }

                // Determine which altitude to display
                const displayAltitude = isNearJourney && journeyWaypoint ? journeyWaypoint.altitude : cursorAltitude;
                const displayDistance = isNearJourney && journeyWaypoint ? Math.round(journeyWaypoint.distNM) : distanceAlong;

                // Build tooltip content
                let content = '';

                // Journey-specific info when hovering on the flight path
                if (isNearJourney && journeyWaypoint) {
                    const phaseLabel = journeyWaypoint.phase === 'climb' ? ' Climbing' :
                                      journeyWaypoint.phase === 'descent' ? ' Descending' : ' Cruise';
                    const phaseColor = journeyWaypoint.phase === 'climb' ? '#22c55e' :
                                      journeyWaypoint.phase === 'descent' ? '#f59e0b' : '#6b7280';

                    content += `<div class="profile-tooltip-row" style="border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 6px; margin-bottom: 6px;">
                        <span class="label" style="color:${phaseColor}; font-weight: 600;">${phaseLabel}</span>
                        <span class="value" style="color:${phaseColor}">FL${Math.round(journeyWaypoint.altitude / 100)}</span>
                    </div>`;

                    // Show terrain clearance only when terrain overlay is active
                    if (overlayState.terrain && terrainProfile && terrainProfile.length > 0) {
                        const terrainIdx = Math.floor(journeyWaypoint.t * (terrainProfile.length - 1));
                        const terrainAlt = terrainProfile[terrainIdx] || 0;
                        const clearance = journeyWaypoint.altitude - terrainAlt;
                        content += `<div class="profile-tooltip-row terrain"><span class="label">Terrain Clearance</span><span class="value">${Math.round(clearance).toLocaleString()} ft AGL</span></div>`;
                        content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7"><span class="label">Ground Elev</span><span class="value">${Math.round(terrainAlt).toLocaleString()} ft MSL</span></div>`;
                    }

                    // Show temperature info when temperature overlay is active
                    if (overlayState.temperature) {
                        const depTemp = (depMetar && depMetar.temperature != null) ? depMetar.temperature : 15;
                        const destTemp = (destMetar && destMetar.temperature != null) ? destMetar.temperature : 15;
                        const surfaceTemp = depTemp + progress * (destTemp - depTemp);
                        // Temperature lapse rate: ~2C per 1000ft
                        const tempAtAlt = surfaceTemp - (journeyWaypoint.altitude / 1000) * 2;
                        const tempAtAltF = Math.round(tempAtAlt * 9/5 + 32);
                        const surfaceTempF = Math.round(surfaceTemp * 9/5 + 32);
                        content += `<div class="profile-tooltip-row temperature"><span class="label">OAT</span><span class="value">${tempAtAltF}F</span></div>`;
                        content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7"><span class="label">Surface</span><span class="value">${surfaceTempF}F</span></div>`;
                    }

                    // Show route position
                    const routeLat = journeyWaypoint.lat.toFixed(3);
                    const routeLon = journeyWaypoint.lon.toFixed(3);
                    content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7"><span class="label">Position</span><span class="value">${routeLat}, ${routeLon}</span></div>`;
                } else {
                    // Generic cursor position info
                    content += `<div class="profile-tooltip-row" style="opacity:0.6; font-size:10px; margin-bottom:4px">
                        <span class="label">Cursor Position</span>
                        <span class="value">(hover near path for details)</span>
                    </div>`;
                }

                // Terrain info
                if (overlayState.terrain) {
                    let seed = profileHoverData.terrainSeed;
                    for (let i = 0; i < Math.floor(progress * 50); i++) {
                        seed = (seed * 9301 + 49297) % 233280;
                    }
                    const terrainHeight = Math.round(Math.sin(progress * 50 / 5) * 2000 + (seed / 233280) * 1000 + 500);
                    content += `<div class="profile-tooltip-row terrain"><span class="label">Terrain</span><span class="value">${terrainHeight.toLocaleString()} ft</span></div>`;
                }

                // Flight Conditions info (combined ceiling + visibility)
                if (overlayState.conditions) {
                    const depCeiling = depMetar?.ceiling || 12500;
                    const destCeiling = destMetar?.ceiling || 12500;
                    const currentCeiling = Math.round(depCeiling + progress * (destCeiling - depCeiling));
                    const depVis = (depMetar?.visibility != null && !isNaN(depMetar.visibility)) ? depMetar.visibility : 10;
                    const destVis = (destMetar?.visibility != null && !isNaN(destMetar.visibility)) ? destMetar.visibility : 10;
                    const currentVis = (depVis + progress * (destVis - depVis));

                    // Determine flight rules based on ceiling and visibility
                    const depFR = depMetar?.flight_rules || 'VFR';
                    const destFR = destMetar?.flight_rules || 'VFR';
                    const fr = progress < 0.5 ? depFR : destFR;
                    const frColors = { 'VFR': '#22c55e', 'MVFR': '#3b82f6', 'IFR': '#ef4444', 'LIFR': '#a855f7' };
                    const frColor = frColors[fr] || '#22c55e';

                    const ceilingText = currentCeiling >= 12500 ? 'CLR' : currentCeiling.toLocaleString() + ' ft';
                    const visDisplay = isNaN(currentVis) ? '10+' : currentVis.toFixed(1);

                    content += `<div class="profile-tooltip-row conditions"><span class="label">Conditions</span><span class="value" style="color:${frColor}">${fr}</span></div>`;
                    content += `<div class="profile-tooltip-row ceiling"><span class="label">Ceiling</span><span class="value">${ceilingText}</span></div>`;
                    content += `<div class="profile-tooltip-row visibility"><span class="label">Visibility</span><span class="value">${visDisplay} SM</span></div>`;
                }

                // Use the appropriate altitude for airspace checks
                const altitude = displayAltitude;

                // Airspace info - comprehensive detection
                if (overlayState.airspace) {
                  try {
                    // Simplified airspace detection based on altitude
                    const routeLat = depStation?.lat + progress * ((destStation?.lat || 0) - (depStation?.lat || 0));
                    const routeLon = depStation?.lon + progress * ((destStation?.lon || 0) - (depStation?.lon || 0));

                    // Simple point-in-polygon test
                    const pointInPolygon = (lat, lon, polygon) => {
                        if (!polygon || !Array.isArray(polygon)) return false;
                        let inside = false;
                        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                            const xi = polygon[i][0], yi = polygon[i][1];
                            const xj = polygon[j][0], yj = polygon[j][1];
                            if (((yi > lon) !== (yj > lon)) && (lat < (xj - xi) * (lon - yi) / (yj - yi) + xi)) {
                                inside = !inside;
                            }
                        }
                        return inside;
                    };

                    // Point-in-circle test for TFRs
                    const pointInCircle = (lat, lon, center, radius) => {
                        if (!center) return false;
                        const dlat = lat - center[0];
                        const dlon = lon - center[1];
                        const dist = Math.sqrt(dlat * dlat + dlon * dlon);
                        return dist <= radius;
                    };

                    let foundAirspaces = [];

                    // Check Class B airspaces
                    airspaceData.classB.forEach(airspace => {
                        airspace.tiers.forEach((tier, idx) => {
                            if (pointInPolygon(routeLat, routeLon, tier.polygon)) {
                                if (altitude >= tier.floor && altitude <= tier.ceiling) {
                                    foundAirspaces.push({
                                        type: 'Class B',
                                        name: airspace.name,
                                        floor: tier.floor,
                                        ceiling: tier.ceiling,
                                        color: '#3b82f6',
                                        priority: 1,
                                        requirements: 'ATC clearance required'
                                    });
                                }
                            }
                        });
                    });

                    // Check Class C airspaces
                    airspaceData.classC.forEach(airspace => {
                        airspace.tiers.forEach((tier, idx) => {
                            if (pointInPolygon(routeLat, routeLon, tier.polygon)) {
                                if (altitude >= tier.floor && altitude <= tier.ceiling) {
                                    foundAirspaces.push({
                                        type: 'Class C',
                                        name: airspace.name,
                                        floor: tier.floor,
                                        ceiling: tier.ceiling,
                                        color: '#ec4899',
                                        priority: 2,
                                        requirements: 'Radio contact required'
                                    });
                                }
                            }
                        });
                    });

                    // Check Class D airspaces (use polygon, not circle)
                    airspaceData.classD.forEach(zone => {
                        if (zone.polygon && pointInPolygon(routeLat, routeLon, zone.polygon)) {
                            if (altitude <= zone.ceiling) {
                                foundAirspaces.push({
                                    type: 'Class D',
                                    name: zone.name,
                                    floor: 0,
                                    ceiling: zone.ceiling,
                                    color: '#60a5fa',
                                    priority: 3,
                                    requirements: 'Two-way radio'
                                });
                            }
                        }
                    });

                    // Check MOAs
                    airspaceData.moa.forEach(zone => {
                        if (pointInPolygon(routeLat, routeLon, zone.polygon)) {
                            if (altitude >= zone.floor && altitude <= zone.ceiling) {
                                foundAirspaces.push({
                                    type: 'MOA',
                                    name: zone.name,
                                    floor: zone.floor,
                                    ceiling: zone.ceiling,
                                    color: '#d97706',
                                    priority: 4,
                                    requirements: 'Exercise caution'
                                });
                            }
                        }
                    });

                    // Check Restricted areas
                    airspaceData.restricted.forEach(zone => {
                        if (pointInPolygon(routeLat, routeLon, zone.polygon)) {
                            if (altitude <= zone.ceiling) {
                                foundAirspaces.push({
                                    type: 'Restricted',
                                    name: zone.name,
                                    floor: 0,
                                    ceiling: zone.ceiling,
                                    color: '#ef4444',
                                    priority: 0,
                                    requirements: 'Authorization required'
                                });
                            }
                        }
                    });

                    // Check Prohibited areas
                    airspaceData.prohibited.forEach(zone => {
                        if (pointInPolygon(routeLat, routeLon, zone.polygon)) {
                            if (altitude <= zone.ceiling) {
                                foundAirspaces.push({
                                    type: 'Prohibited',
                                    name: zone.name,
                                    floor: 0,
                                    ceiling: zone.ceiling,
                                    color: '#dc2626',
                                    priority: -1,
                                    requirements: 'NO ENTRY'
                                });
                            }
                        }
                    });

                    // Check TFRs
                    airspaceData.tfr.forEach(zone => {
                        if (zone.active && pointInCircle(routeLat, routeLon, zone.center, zone.radius)) {
                            if (altitude <= zone.ceiling) {
                                foundAirspaces.push({
                                    type: 'TFR',
                                    name: zone.name,
                                    floor: 0,
                                    ceiling: zone.ceiling,
                                    color: '#ff0000',
                                    priority: -2,
                                    requirements: 'ACTIVE - Check NOTAMs'
                                });
                            }
                        }
                    });

                    // Sort by priority and build display
                    foundAirspaces.sort((a, b) => a.priority - b.priority);

                    if (foundAirspaces.length > 0) {
                        const primary = foundAirspaces[0];
                        const floorStr = primary.floor === 0 ? 'SFC' : primary.floor.toLocaleString() + ' ft';
                        const ceilStr = primary.ceiling >= 99999 ? 'UNL' : primary.ceiling.toLocaleString() + ' ft';
                        content += `<div class="profile-tooltip-row airspace">
                            <span class="label">Airspace</span>
                            <span class="value" style="color:${primary.color}">${primary.type}</span>
                        </div>`;
                        content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.9">
                            <span class="label">${primary.name.replace(' Class B', '').replace(' Class C', '')}</span>
                            <span class="value">${floorStr} - ${ceilStr}</span>
                        </div>`;
                        content += `<div class="profile-tooltip-row" style="font-size:9px;opacity:0.7">
                            <span class="label">Entry</span>
                            <span class="value">${primary.requirements}</span>
                        </div>`;
                    } else {
                        // Default to Class E or G based on altitude
                        const classType = altitude >= 1200 ? 'Class E' : 'Class G';
                        content += `<div class="profile-tooltip-row airspace">
                            <span class="label">Airspace</span>
                            <span class="value">${classType}</span>
                        </div>`;
                        content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7">
                            <span class="label">Uncontrolled</span>
                            <span class="value">No ATC required</span>
                        </div>`;
                    }
                  } catch (err) {
                    console.error('Airspace detection error:', err);
                    // Airspace detection failed, show default
                    content += `<div class="profile-tooltip-row airspace">
                        <span class="label">Airspace</span>
                        <span class="value">--</span>
                    </div>`;
                  }
                }

                // Icing info - check actual icing zones at this position
                if (overlayState.icing) {
                    let icingLevel = 'None';
                    let icingZoneName = '';
                    for (const zone of flightHazards.icingZones) {
                        if (pointInPolygon(routeLat, routeLon, zone.polygon)) {
                            if (altitude >= zone.base && altitude <= zone.top) {
                                icingLevel = zone.intensity;
                                icingZoneName = zone.name;
                                break;
                            }
                        }
                    }
                    content += `<div class="profile-tooltip-row icing"><span class="label">Icing</span><span class="value">${icingLevel}</span></div>`;
                    if (icingZoneName) {
                        content += `<div class="profile-tooltip-row" style="font-size:9px;opacity:0.7"><span class="label"></span><span class="value" style="color:#06b6d4">${icingZoneName}</span></div>`;
                    }
                }

                // Turbulence info - check actual turbulence zones at this position
                if (overlayState.turbulence) {
                    let turbLevel = 'Smooth';
                    let turbZoneName = '';
                    for (const zone of flightHazards.turbulenceZones) {
                        if (pointInPolygon(routeLat, routeLon, zone.polygon)) {
                            if (altitude >= zone.base && altitude <= zone.top) {
                                turbLevel = zone.intensity;
                                turbZoneName = zone.name;
                                break;
                            }
                        }
                    }
                    content += `<div class="profile-tooltip-row turbulence"><span class="label">Turbulence</span><span class="value">${turbLevel}</span></div>`;
                    if (turbZoneName) {
                        content += `<div class="profile-tooltip-row" style="font-size:9px;opacity:0.7"><span class="label"></span><span class="value" style="color:#f97316">${turbZoneName}</span></div>`;
                    }
                }

                // Winds info - find wind band for current altitude
                if (overlayState.winds) {
                    const windBands = [
                        { base: 0, top: 6000, speed: 15, dir: 270 },
                        { base: 6000, top: 12000, speed: 35, dir: 280 },
                        { base: 10000, top: 12500, speed: 45, dir: 280 }
                    ];
                    // Find wind band for current altitude
                    const currentBand = windBands.find(b => altitude >= b.base && altitude < b.top) || windBands[windBands.length - 1];
                    content += `<div class="profile-tooltip-row winds"><span class="label">Wind</span><span class="value">${currentBand.dir} @ ${currentBand.speed}kt</span></div>`;
                    content += `<div class="profile-tooltip-row" style="font-size:9px;opacity:0.7"><span class="label"></span><span class="value" style="color:#22c55e">${(currentBand.base/1000).toFixed(0)}K-${(currentBand.top/1000).toFixed(0)}K band</span></div>`;
                }

                // Clouds info
                if (overlayState.clouds) {
                    let cloudInfo = 'Clear';
                    if (altitude >= 8000 && altitude <= 12000) cloudInfo = 'SCT 080-120';
                    else if (altitude >= 18000 && altitude <= 22000) cloudInfo = 'BKN 180-220';
                    else if (altitude >= 28000 && altitude <= 32000) cloudInfo = 'FEW 280-320';
                    content += `<div class="profile-tooltip-row clouds"><span class="label">Clouds</span><span class="value">${cloudInfo}</span></div>`;
                }

                // Precipitation/Dewpoint info
                if (overlayState.dewpoint) {
                    const depTemp = (depMetar && depMetar.temperature != null) ? depMetar.temperature : 15;
                    const destTemp = (destMetar && destMetar.temperature != null) ? destMetar.temperature : 15;
                    const depDew = (depMetar && depMetar.dewpoint != null) ? depMetar.dewpoint : 10;
                    const destDew = (destMetar && destMetar.dewpoint != null) ? destMetar.dewpoint : 10;
                    const currentTemp = depTemp + progress * (destTemp - depTemp);
                    const currentDew = depDew + progress * (destDew - depDew);
                    const spread = currentTemp - currentDew;

                    let precipRisk = 'None';
                    let precipColor = '#94a3b8';
                    if (spread <= 1) { precipRisk = 'Fog Likely'; precipColor = '#94a3b8'; }
                    else if (spread <= 3) { precipRisk = 'Fog Risk'; precipColor = '#94a3b8'; }
                    else if (spread <= 5 && currentTemp < 5) { precipRisk = 'Precip Possible'; precipColor = '#0ea5e9'; }

                    const spreadF = Math.round(spread * 9/5);
                    content += `<div class="profile-tooltip-row precip"><span class="label">Precip Risk</span><span class="value" style="color:${precipColor}">${precipRisk}</span></div>`;
                    content += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7"><span class="label">T/Td Spread</span><span class="value">${spreadF}F</span></div>`;
                }

                // Update tooltip content
                document.getElementById('tooltipPosition').textContent = `${displayAltitude.toLocaleString()} ft`;
                document.getElementById('tooltipDistance').textContent = `${displayDistance} NM`;
                document.getElementById('tooltipContent').innerHTML = content;

                // Position tooltip (use screen coordinates)
                let tooltipX = screenX + 15;
                let tooltipY = screenY - 10;

                // Keep tooltip in bounds
                const containerRect = canvas.parentElement.getBoundingClientRect();
                if (tooltipX + 200 > containerRect.width) tooltipX = screenX - 200;
                if (tooltipY < 0) tooltipY = 10;

                tooltip.style.left = `${tooltipX}px`;
                tooltip.style.top = `${tooltipY}px`;
                tooltip.classList.add('visible');
            });

            canvas.addEventListener('mouseleave', () => {
                // Only hide if not pinned
                if (!profilePinnedPoint) {
                    tooltip.classList.remove('visible');
                    crosshair.classList.remove('visible');
                    journeyMarker.classList.remove('visible');
                }
            });

            // Click to pin tooltip (for touch/tap interaction)
            canvas.addEventListener('click', (e) => {
                if (!profileHoverData || !currentRoute.dep || profileView.isDragging) return;

                const rect = canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;

                const { width, height, padding, paddingRight, paddingBottom, distance, depStation, destStation, optimizedPath, maxAltitude } = profileHoverData;
                const profileHeight = height - padding - paddingBottom;
                const profileBottom = height - paddingBottom;

                // Transform screen coordinates back to canvas coordinates
                const zoom = profileView.zoom;
                const centerX = width / 2;
                const centerY = height / 2;
                const x = (screenX - centerX - profileView.panX) / zoom + centerX;
                const y = (screenY - centerY - profileView.panY) / zoom + centerY;

                // Check if within profile area
                if (x < padding || x > width - paddingRight || y < padding || y > height - paddingBottom) {
                    return; // Ignore clicks outside profile area
                }

                // Calculate progress along route
                const progress = Math.max(0, Math.min(1, (x - padding) / (width - padding - paddingRight)));

                // Check if clicking on existing pin (within 3% progress tolerance)
                if (profilePinnedPoint) {
                    const pinProgress = profilePinnedPoint.progress;
                    const progressDiff = Math.abs(progress - pinProgress);

                    if (progressDiff < 0.03) {
                        // Clicking on same pin - remove it
                        profilePinnedPoint = null;
                        tooltip.classList.remove('visible', 'pinned');
                        journeyMarker.classList.remove('visible', 'pinned');
                        crosshair.classList.remove('visible');
                        return;
                    }
                }

                // Find closest point on journey line
                let journeyWaypoint = null;
                let journeyScreenX = screenX;
                let journeyScreenY = screenY;

                if (optimizedPath && optimizedPath.length > 0) {
                    let closestIdx = 0;
                    let closestDist = Infinity;

                    for (let i = 0; i < optimizedPath.length; i++) {
                        const wp = optimizedPath[i];
                        const dist = Math.abs(wp.t - progress);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestIdx = i;
                        }
                    }

                    journeyWaypoint = optimizedPath[closestIdx];
                    const journeyCanvasY = profileBottom - (journeyWaypoint.altitude / maxAltitude) * profileHeight;
                    journeyScreenX = (padding + journeyWaypoint.t * (width - padding - paddingRight) - centerX) * zoom + centerX + profileView.panX;
                    journeyScreenY = (journeyCanvasY - centerY) * zoom + centerY + profileView.panY;
                }

                // Set new pin (replaces any existing pin)
                profilePinnedPoint = {
                    progress: journeyWaypoint ? journeyWaypoint.t : progress,
                    screenX: journeyScreenX,
                    screenY: journeyScreenY,
                    waypoint: journeyWaypoint
                };

                // Update marker position to journey line
                journeyMarker.style.left = `${journeyScreenX}px`;
                journeyMarker.style.top = `${journeyScreenY}px`;
                journeyMarker.classList.add('visible', 'pinned');

                // Position tooltip near pinned point
                let tooltipX = journeyScreenX + 15;
                let tooltipY = journeyScreenY - 20;

                // Keep tooltip within bounds
                const tooltipWidth = 200;
                const tooltipHeight = 250;
                if (tooltipX + tooltipWidth > width) {
                    tooltipX = journeyScreenX - tooltipWidth - 15;
                }
                if (tooltipY + tooltipHeight > height - paddingBottom) {
                    tooltipY = height - paddingBottom - tooltipHeight - 10;
                }
                if (tooltipY < padding) {
                    tooltipY = padding + 10;
                }

                tooltip.style.left = `${tooltipX}px`;
                tooltip.style.top = `${tooltipY}px`;
                tooltip.classList.add('visible', 'pinned');

                // Populate tooltip content for pinned point directly
                // (instead of synthetic mousemove which uses wrong coordinates)
                const pinnedProgress = journeyWaypoint ? journeyWaypoint.t : progress;
                const pinnedDistance = journeyWaypoint ? Math.round(journeyWaypoint.distNM) : Math.round(progress * distance);
                const pinnedAltitude = journeyWaypoint ? journeyWaypoint.altitude : 0;

                // Update tooltip header values
                document.getElementById('tooltipPosition').textContent = `${pinnedAltitude.toLocaleString()} ft`;
                document.getElementById('tooltipDistance').textContent = `${pinnedDistance} NM`;

                // Build tooltip content for pinned point
                let pinnedContent = '';
                const { depMetar, destMetar, terrainProfile } = profileHoverData;

                if (journeyWaypoint) {
                    const phaseLabel = journeyWaypoint.phase === 'climb' ? ' Climbing' :
                                      journeyWaypoint.phase === 'descent' ? ' Descending' : ' Cruise';
                    const phaseColor = journeyWaypoint.phase === 'climb' ? '#22c55e' :
                                      journeyWaypoint.phase === 'descent' ? '#f59e0b' : '#6b7280';

                    pinnedContent += `<div class="profile-tooltip-row" style="border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 6px; margin-bottom: 6px;">
                        <span class="label" style="color:${phaseColor}; font-weight: 600;">${phaseLabel}</span>
                        <span class="value" style="color:${phaseColor}">FL${Math.round(journeyWaypoint.altitude / 100)}</span>
                    </div>`;

                    // Terrain clearance if terrain overlay active
                    if (overlayState.terrain && terrainProfile && terrainProfile.length > 0) {
                        const terrainIdx = Math.floor(journeyWaypoint.t * (terrainProfile.length - 1));
                        const terrainAlt = terrainProfile[terrainIdx] || 0;
                        const clearance = journeyWaypoint.altitude - terrainAlt;
                        pinnedContent += `<div class="profile-tooltip-row terrain"><span class="label">Terrain Clearance</span><span class="value">${Math.round(clearance).toLocaleString()} ft AGL</span></div>`;
                    }

                    // Temperature if overlay active
                    if (overlayState.temperature) {
                        const depTemp = (depMetar && depMetar.temperature != null) ? depMetar.temperature : 15;
                        const destTemp = (destMetar && destMetar.temperature != null) ? destMetar.temperature : 15;
                        const surfaceTemp = depTemp + pinnedProgress * (destTemp - depTemp);
                        const tempAtAlt = surfaceTemp - (journeyWaypoint.altitude / 1000) * 2;
                        const tempAtAltF = Math.round(tempAtAlt * 9/5 + 32);
                        pinnedContent += `<div class="profile-tooltip-row temperature"><span class="label">OAT</span><span class="value">${tempAtAltF}F</span></div>`;
                    }

                    // Flight conditions if overlay active
                    if (overlayState.conditions) {
                        const depFR = depMetar?.flight_rules || 'VFR';
                        const destFR = destMetar?.flight_rules || 'VFR';
                        const fr = pinnedProgress < 0.5 ? depFR : destFR;
                        const frColors = { 'VFR': '#22c55e', 'MVFR': '#3b82f6', 'IFR': '#ef4444', 'LIFR': '#a855f7' };
                        const frColor = frColors[fr] || '#22c55e';
                        pinnedContent += `<div class="profile-tooltip-row conditions"><span class="label">Conditions</span><span class="value" style="color:${frColor}">${fr}</span></div>`;
                    }

                    // Winds info if overlay active
                    if (overlayState.winds) {
                        const windBands = [
                            { base: 0, top: 6000, speed: 15, dir: 270 },
                            { base: 6000, top: 12000, speed: 35, dir: 280 },
                            { base: 10000, top: 12500, speed: 45, dir: 280 }
                        ];
                        const currentBand = windBands.find(b => journeyWaypoint.altitude >= b.base && journeyWaypoint.altitude < b.top) || windBands[windBands.length - 1];
                        pinnedContent += `<div class="profile-tooltip-row winds"><span class="label">Wind</span><span class="value">${currentBand.dir} @ ${currentBand.speed}kt</span></div>`;
                    }

                    // Position
                    pinnedContent += `<div class="profile-tooltip-row" style="font-size:10px;opacity:0.7"><span class="label">Position</span><span class="value">${journeyWaypoint.lat.toFixed(3)}, ${journeyWaypoint.lon.toFixed(3)}</span></div>`;
                }

                document.getElementById('tooltipContent').innerHTML = pinnedContent;
            });

            // Touch support for tap-to-pin
            canvas.addEventListener('touchend', (e) => {
                if (e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    const clickEvent = new MouseEvent('click', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    canvas.dispatchEvent(clickEvent);
                }
            });
        }

        // Pinned point storage for click-to-pin feature
        let profilePinnedPoint = null;

        // Initialize profile hover and zoom/pan
        setupProfileHover();
        setupProfileZoomPan();

        // Setup resize divider functionality
        function setupResizeDivider() {
            const divider = document.getElementById('resizeDivider');
            const mapContainer = document.querySelector('.map-container');
            const profileSection = document.getElementById('profileSection');

            let isResizing = false;
            let startY = 0;
            let startMapHeight = 0;
            let startProfileHeight = 0;

            divider.addEventListener('mousedown', (e) => {
                isResizing = true;
                startY = e.clientY;
                startMapHeight = mapContainer.offsetHeight;
                startProfileHeight = profileSection.offsetHeight;
                divider.classList.add('dragging');
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaY = e.clientY - startY;
                // Calculate available height (viewport minus header/toolbar)
                const headerHeight = document.querySelector('.app-header')?.offsetHeight || 60;
                const toolbarHeight = document.querySelector('.overlay-toolbar')?.offsetHeight || 50;
                const availableHeight = window.innerHeight - headerHeight - toolbarHeight - 20;
                const maxProfileHeight = availableHeight - 150; // Keep minimum 150px for map

                const newMapHeight = Math.max(150, startMapHeight + deltaY);
                const newProfileHeight = Math.min(maxProfileHeight, Math.max(200, startProfileHeight - deltaY)); // Min 200px to keep canvas legible

                mapContainer.style.height = `${newMapHeight}px`;
                profileSection.style.height = `${newProfileHeight}px`;

                // Invalidate map size after resize
                if (typeof map !== 'undefined') {
                    map.invalidateSize();
                }

                // Redraw profile canvas
                const canvas = document.getElementById('profileCanvas');
                if (canvas && canvas.offsetParent !== null) {
                    canvas.width = canvas.parentElement.clientWidth;
                    canvas.height = canvas.parentElement.clientHeight;
                    if (currentRoute.dep && currentRoute.dest) {
                        drawProfile(currentRoute.dep, currentRoute.dest);
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    divider.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';

                    // Final invalidate
                    if (typeof map !== 'undefined') {
                        map.invalidateSize();
                    }
                }
            });

            // Touch support
            divider.addEventListener('touchstart', (e) => {
                isResizing = true;
                startY = e.touches[0].clientY;
                startMapHeight = mapContainer.offsetHeight;
                startProfileHeight = profileSection.offsetHeight;
                divider.classList.add('dragging');
                e.preventDefault();
            });

            document.addEventListener('touchmove', (e) => {
                if (!isResizing) return;

                const deltaY = e.touches[0].clientY - startY;
                // Calculate available height (viewport minus header/toolbar)
                const headerHeight = document.querySelector('.app-header')?.offsetHeight || 60;
                const toolbarHeight = document.querySelector('.overlay-toolbar')?.offsetHeight || 50;
                const availableHeight = window.innerHeight - headerHeight - toolbarHeight - 20;
                const maxProfileHeight = availableHeight - 150; // Keep minimum 150px for map

                const newMapHeight = Math.max(150, startMapHeight + deltaY);
                const newProfileHeight = Math.min(maxProfileHeight, Math.max(200, startProfileHeight - deltaY)); // Min 200px to keep canvas legible

                mapContainer.style.height = `${newMapHeight}px`;
                profileSection.style.height = `${newProfileHeight}px`;

                if (typeof map !== 'undefined') {
                    map.invalidateSize();
                }
            });

            document.addEventListener('touchend', () => {
                if (isResizing) {
                    isResizing = false;
                    divider.classList.remove('dragging');

                    if (typeof map !== 'undefined') {
                        map.invalidateSize();
                    }

                    // Redraw profile
                    const canvas = document.getElementById('profileCanvas');
                    if (canvas && canvas.offsetParent !== null) {
                        canvas.width = canvas.parentElement.clientWidth;
                        canvas.height = canvas.parentElement.clientHeight;
                        if (currentRoute.dep && currentRoute.dest) {
                            drawProfile(currentRoute.dep, currentRoute.dest);
                        }
                    }
                }
            });
        }

        setupResizeDivider();

        // Initialize (METAR stations loaded on-demand when toggle is enabled)
        loadRadarLayer();
        loadCloudsLayer();

        // Apply initial overlay states
        if (overlayState.terrain) {
            terrainLayer.addTo(map);
        }

        // Refresh radar every 5 minutes
        setInterval(loadRadarLayer, 5 * 60 * 1000);

        // Refresh clouds every 10 minutes
        setInterval(loadCloudsLayer, 10 * 60 * 1000);

        // Refresh METAR every 10 minutes (only if stations overlay is enabled)
        setInterval(() => {
            if (overlayState.stations && stationsDataLoaded) {
                loadMetarStations();
            }
        }, 10 * 60 * 1000);

        // Handle window resize for profile
        window.addEventListener('resize', () => {
            if (!profileView.minimized) {
                const dep = document.getElementById('departure').value.toUpperCase();
                const dest = document.getElementById('destination').value.toUpperCase();
                if (dep && dest) {
                    loadRoute();
                }
            }
        });
    </script>
</body>
</html>
