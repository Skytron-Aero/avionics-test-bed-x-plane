<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aviation Weather</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-card: rgba(255, 255, 255, 0.03);
            --bg-card-hover: rgba(255, 255, 255, 0.06);
            --border-color: rgba(255, 255, 255, 0.08);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --text-tertiary: rgba(255, 255, 255, 0.4);
            --accent: #6b7280;
            --accent-glow: rgba(107, 114, 128, 0.3);
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --vfr: #10b981;
            --mvfr: #3b82f6;
            --ifr: #ef4444;
            --lifr: #a855f7;
        }

        /* Light Mode */
        :root.light-mode {
            --bg-primary: #f5f5f5;
            --bg-secondary: #e8e8e8;
            --bg-card: rgba(0, 0, 0, 0.04);
            --bg-card-hover: rgba(0, 0, 0, 0.08);
            --text-primary: #1a1a1a;
            --text-secondary: rgba(0, 0, 0, 0.65);
            --text-tertiary: rgba(0, 0, 0, 0.45);
            --border-color: rgba(0, 0, 0, 0.12);
        }

        .light-mode .top-navbar {
            background: rgba(245, 245, 245, 0.95);
        }

        .light-mode .nav-brand svg.orca-logo {
            color: #1a1a1a;
        }

        .light-mode .leaflet-tile-pane {
            filter: invert(1) hue-rotate(180deg) saturate(0.3) brightness(1.1);
        }

        .light-mode .leaflet-overlay-pane,
        .light-mode .leaflet-marker-pane {
            filter: none;
        }

        /* Light mode - hide background gradient */
        .light-mode .bg-gradient {
            opacity: 0;
        }

        /* Light mode dashboard cards and panels */
        .light-mode .card {
            background: var(--bg-card);
            border-color: var(--border-color);
        }

        .light-mode .card h3 {
            color: var(--text-primary);
        }

        .light-mode .search-input {
            background: rgba(0, 0, 0, 0.05);
            color: var(--text-primary);
            border-color: var(--border-color);
        }

        .light-mode .search-input::placeholder {
            color: var(--text-tertiary);
        }

        .light-mode .nav-link:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .light-mode .nav-link.active {
            background: rgba(107, 114, 128, 0.15);
        }

        /* Light mode text fixes for better contrast */
        .light-mode .stat-value,
        .light-mode .stat-label,
        .light-mode .card-title,
        .light-mode .section-title,
        .light-mode .form-group label,
        .light-mode .regulation-form label,
        .light-mode .legend-title,
        .light-mode .legend-label,
        .light-mode .map-legend span,
        .light-mode .health-text,
        .light-mode .empty-state p,
        .light-mode h1, .light-mode h2, .light-mode h3 {
            color: var(--text-primary);
        }

        .light-mode .data-value,
        .light-mode .metar-raw,
        .light-mode .taf-raw,
        .light-mode input,
        .light-mode select {
            color: var(--text-primary);
        }

        .light-mode .data-label,
        .light-mode .quick-action {
            color: var(--text-secondary);
        }

        .light-mode input::placeholder {
            color: var(--text-tertiary);
        }

        .light-mode .map-stat-card {
            background: rgba(255, 255, 255, 0.85);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .light-mode .map-stat-value {
            color: var(--text-primary);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Prevent browser zoom and scaling */
        html {
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            touch-action: pan-x pan-y;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .bg-gradient {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                radial-gradient(ellipse 80% 50% at 20% -20%, rgba(107, 114, 128, 0.08), transparent),
                radial-gradient(ellipse 60% 40% at 80% 100%, rgba(107, 114, 128, 0.05), transparent);
            pointer-events: none;
            z-index: 0;
        }

        /* Dashboard Layout - 3:2 Landscape */
        .dashboard {
            display: grid;
            grid-template-columns: minmax(280px, 340px) 1fr minmax(260px, 320px);
            grid-template-rows: 1fr;
            gap: 10px;
            height: calc(100vh - 49px);
            max-height: calc(100vh - 49px);
            padding: 8px;
            position: fixed;
            top: 49px;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1;
            overflow: hidden;
            box-sizing: border-box;
        }

        /* Left Panel - Search & Station Info */
        .panel-left {
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 6px;
            min-height: 0;
        }

        /* Center Panel - Main Content */
        .panel-center {
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 0 6px;
            min-height: 0;
        }

        /* Right Panel - Weather Details */
        .panel-right {
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-left: 6px;
            min-height: 0;
        }

        /* Scrollbar styling */
        .panel-left::-webkit-scrollbar,
        .panel-center::-webkit-scrollbar,
        .panel-right::-webkit-scrollbar {
            width: 4px;
        }

        .panel-left::-webkit-scrollbar-track,
        .panel-center::-webkit-scrollbar-track,
        .panel-right::-webkit-scrollbar-track {
            background: transparent;
        }

        .panel-left::-webkit-scrollbar-thumb,
        .panel-center::-webkit-scrollbar-thumb,
        .panel-right::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        /* Legacy container hidden */
        .container {
            display: none;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #4a4a4a, #6b7280);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo-icon svg {
            width: 28px;
            height: 28px;
            fill: white;
        }

        h1 {
            font-size: 28px;
            font-weight: 600;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, #fff, rgba(255,255,255,0.7));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .health-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 100px;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
        }

        .health-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-tertiary);
            transition: all 0.3s ease;
        }

        .health-dot.healthy {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .health-text {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .search-section {
            margin-bottom: 40px;
        }

        .search-container {
            position: relative;
            max-width: 480px;
        }

        .search-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-icon {
            position: absolute;
            left: 14px;
            width: 16px;
            height: 16px;
            color: var(--text-tertiary);
            pointer-events: none;
            transition: color 0.3s ease;
        }

        input, select {
            font-family: inherit;
            font-size: 14px;
            padding: 10px 14px 10px 38px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-card);
            color: var(--text-primary);
            width: 100%;
            transition: all 0.3s ease;
            backdrop-filter: blur(20px);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 4px var(--accent-glow), 0 8px 32px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.05);
        }

        input:focus + .search-icon,
        .search-wrapper:focus-within .search-icon {
            color: var(--accent);
        }

        input::placeholder {
            color: var(--text-tertiary);
        }

        .search-results {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 100;
            overflow: hidden;
            backdrop-filter: blur(40px);
        }

        .search-results.active {
            display: block;
            animation: slideDown 0.2s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .search-result-item {
            padding: 10px 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 1px solid var(--border-color);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .search-result-item .icao {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 1px;
        }

        .search-result-item .name {
            font-size: 11px;
            color: var(--text-tertiary);
        }

        .grid {
            display: grid;
            gap: 12px;
        }

        .grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        @media (max-width: 768px) {
            .grid-2 { grid-template-columns: 1fr; }
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(40px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            max-width: 100%;
            box-sizing: border-box;
        }

        .card.compact {
            padding: 8px;
        }

        .card.compact .card-header {
            margin-bottom: 8px;
        }

        .card.compact .regulation-form {
            gap: 8px;
            margin-bottom: 8px;
        }

        .card.compact .form-group {
            gap: 4px;
        }

        .card.compact .form-group label {
            font-size: 10px;
        }

        .card.compact .form-group input,
        .card.compact .form-group select {
            padding: 10px 12px;
            font-size: 13px;
            border-radius: 10px;
        }

        .card.flex-grow {
            flex: 1;
            min-height: 0;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
        }

        .card:hover {
            background: var(--bg-card-hover);
            border-color: rgba(255, 255, 255, 0.12);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .card-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-tertiary);
        }

        .flight-rules {
            font-size: 10px;
            font-weight: 700;
            padding: 4px 10px;
            border-radius: 100px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .flight-rules.vfr {
            background: rgba(16, 185, 129, 0.15);
            color: var(--vfr);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.2);
        }
        .flight-rules.mvfr {
            background: rgba(59, 130, 246, 0.15);
            color: var(--mvfr);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.2);
        }
        .flight-rules.ifr {
            background: rgba(239, 68, 68, 0.15);
            color: var(--ifr);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.2);
        }
        .flight-rules.lifr {
            background: rgba(168, 85, 247, 0.15);
            color: var(--lifr);
            box-shadow: 0 0 20px rgba(168, 85, 247, 0.2);
        }

        .station-name {
            font-size: 20px;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 2px;
            background: linear-gradient(135deg, #fff, rgba(255,255,255,0.8));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .observation-time {
            font-size: 10px;
            color: var(--text-tertiary);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .observation-time::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .data-item {
            display: flex;
            flex-direction: column;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.04);
            transition: all 0.3s ease;
            min-width: 0;
            overflow: hidden;
        }

        .data-item:hover {
            background: rgba(255, 255, 255, 0.04);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .data-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: 4px;
        }

        .data-value {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: -0.2px;
            word-break: break-word;
        }

        .data-value.large {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: -0.3px;
            background: linear-gradient(135deg, #fff, rgba(255,255,255,0.7));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .data-unit {
            font-size: 12px;
            font-weight: 400;
            color: var(--text-tertiary);
            margin-left: 3px;
        }

        .raw-text {
            font-family: 'SF Mono', 'Fira Code', ui-monospace, monospace;
            font-size: 9px;
            background: rgba(0, 0, 0, 0.3);
            padding: 6px 8px;
            border-radius: 6px;
            word-break: break-word;
            overflow-wrap: anywhere;
            margin-top: 10px;
            word-break: break-all;
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.05);
            line-height: 1.6;
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0 0 8px;
        }

        .section-title {
            font-size: 13px;
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        .section-line {
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, var(--border-color), transparent);
        }

        /* Chart styles */
        .chart-container {
            position: relative;
            height: 300px;
            margin-bottom: 12px;
        }

        /* Weather Map Styles */
        .weather-map {
            width: 100%;
            height: 100%;
            min-height: 400px;
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            flex-grow: 1;
        }

        #weatherMapCard {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .weather-map-container {
            position: relative;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .map-stats-overlay {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            z-index: 1000;
            pointer-events: none;
        }

        .map-stat-card {
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 6px 10px;
            text-align: center;
            pointer-events: auto;
        }

        .map-stat-value {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.2;
        }

        .map-stat-label {
            font-size: 0.55rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
        }

        .map-layer-toggles {
            display: flex;
            gap: 6px;
        }

        .map-layer-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 11px;
            font-weight: 500;
        }

        .map-layer-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .map-layer-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .map-layer-btn svg {
            flex-shrink: 0;
        }

        .map-legend {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            font-size: 10px;
        }

        .map-legend .legend-title {
            color: var(--text-tertiary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .legend-gradient {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            min-width: 120px;
        }

        .legend-gradient.radar {
            background: linear-gradient(to right,
                transparent 0%,
                #00ff00 20%,
                #ffff00 40%,
                #ff8800 60%,
                #ff0000 80%,
                #ff00ff 100%);
        }

        .legend-gradient.satellite {
            background: linear-gradient(to right,
                transparent 0%,
                rgba(100,100,100,0.3) 25%,
                rgba(150,150,150,0.5) 50%,
                rgba(200,200,200,0.7) 75%,
                rgba(255,255,255,0.9) 100%);
        }

        .legend-gradient.precipitation {
            background: linear-gradient(to right,
                transparent 0%,
                #00ff00 20%,
                #ffff00 40%,
                #ff8800 60%,
                #ff0000 80%,
                #ff00ff 100%);
        }

        .legend-gradient.clouds {
            background: linear-gradient(to right,
                transparent 0%,
                rgba(255,255,255,0.2) 25%,
                rgba(255,255,255,0.5) 50%,
                rgba(255,255,255,0.8) 75%,
                rgba(255,255,255,1) 100%);
        }

        .legend-gradient.temp {
            background: linear-gradient(to right,
                #0000ff 0%,
                #00ffff 25%,
                #00ff00 50%,
                #ffff00 75%,
                #ff0000 100%);
        }

        .legend-gradient.wind {
            background: linear-gradient(to right,
                #00ff00 0%,
                #ffff00 33%,
                #ff8800 66%,
                #ff0000 100%);
        }

        .legend-gradient.pressure {
            background: linear-gradient(to right,
                #0000ff 0%,
                #00ffff 25%,
                #00ff00 50%,
                #ffff00 75%,
                #ff8800 100%);
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            flex: 1;
            color: var(--text-tertiary);
            font-size: 10px;
        }

        /* Dark theme for Leaflet */
        .leaflet-container {
            background: #1a1a1a;
            font-family: inherit;
        }

        .leaflet-control-zoom {
            border: none !important;
            box-shadow: none !important;
        }

        .leaflet-control-zoom a {
            background: var(--bg-card) !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color) !important;
            transition: background 0.2s ease !important;
        }

        .leaflet-control-zoom a:hover {
            background: var(--bg-secondary) !important;
        }

        .leaflet-control-zoom-in {
            border-radius: 8px 8px 0 0 !important;
        }

        .leaflet-control-zoom-out {
            border-radius: 0 0 8px 8px !important;
        }

        /* Hide map attribution/watermarks */
        .leaflet-control-attribution {
            display: none !important;
        }

        /* Route line on map */
        .route-marker {
            background: var(--accent);
            border: 2px solid white;
            border-radius: 50%;
            width: 12px;
            height: 12px;
        }

        .route-marker.departure {
            background: var(--success);
        }

        .route-marker.arrival {
            background: var(--danger);
        }

        .chart-tabs {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .chart-tab {
            padding: 6px 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 100px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chart-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .chart-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .forecast-scroll {
            overflow-x: auto;
            margin: -8px;
            padding: 8px;
        }

        .forecast-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            min-width: 600px;
        }

        .forecast-table th {
            text-align: left;
            font-weight: 600;
            color: var(--text-tertiary);
            padding: 10px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-color);
        }

        .forecast-table td {
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            transition: all 0.2s ease;
        }

        .forecast-table tr:hover td {
            background: rgba(255, 255, 255, 0.02);
        }

        .regulation-form {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .form-group label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
        }

        .form-group input,
        .form-group select {
            padding: 8px 10px;
            padding-left: 10px;
        }

        select {
            padding-left: 10px;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='rgba(255,255,255,0.4)' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
        }

        button {
            font-family: inherit;
            font-size: 12px;
            font-weight: 600;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #4a4a4a, #6b7280);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        button:hover {
            opacity: 0.9;
        }

        button:active {
            opacity: 0.8;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            font-weight: 600;
            padding: 8px 12px;
            border-radius: 8px;
            margin-top: 8px;
        }

        .status-badge.compliant {
            background: rgba(16, 185, 129, 0.15);
            color: var(--success);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-badge.non-compliant {
            background: rgba(239, 68, 68, 0.15);
            color: var(--danger);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .status-icon {
            width: 18px;
            height: 18px;
        }

        .empty-state {
            text-align: center;
            padding: 32px 16px;
            color: var(--text-tertiary);
        }

        .empty-state-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 12px;
            opacity: 0.3;
        }

        .empty-state p {
            font-size: 15px;
            max-width: 280px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .taf-period {
            padding: 12px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.04);
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }

        .taf-period:last-child {
            margin-bottom: 0;
        }

        .taf-period:hover {
            background: rgba(255, 255, 255, 0.04);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .taf-period-header {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--accent);
        }

        .taf-period-details {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .taf-detail {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .taf-detail-icon {
            width: 16px;
            height: 16px;
            color: var(--text-tertiary);
        }

        .valid-period {
            font-size: 12px;
            color: var(--text-tertiary);
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            display: inline-block;
        }

        .loading {
            opacity: 0.5;
            pointer-events: none;
            position: relative;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 32px;
            height: 32px;
            margin: -16px 0 0 -16px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
            padding: 10px 14px;
            border-radius: 10px;
            font-size: 13px;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        /* Loading retry state styles */
        .loading-retry-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            gap: 12px;
            min-height: 100px;
        }

        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .retry-text {
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
        }

        .error-minimized {
            font-size: 11px;
            color: var(--text-tertiary);
            cursor: pointer;
            text-align: center;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
            transition: all 0.2s ease;
        }

        .error-minimized:hover {
            background: rgba(255, 255, 255, 0.06);
        }

        .error-minimized .error-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .error-minimized .error-details {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .error-minimized.expanded .error-details {
            display: block;
        }

        /* Final error state (after max retries) */
        .error-state-final {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .error-message-minimized {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: rgba(239, 68, 68, 0.08);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .error-message-minimized .error-icon {
            width: 16px;
            height: 16px;
            color: var(--danger);
            flex-shrink: 0;
        }

        .error-message-minimized span {
            flex: 1;
        }

        .retry-btn {
            padding: 4px 10px;
            font-size: 11px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .retry-btn:hover {
            opacity: 0.85;
        }

        .error-details-expandable {
            font-size: 11px;
            color: var(--text-tertiary);
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.02);
        }

        .error-details-expandable .expand-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .error-details-expandable .expand-toggle::before {
            content: 'â–¶';
            font-size: 8px;
            transition: transform 0.2s;
        }

        .error-details-expandable.expanded .expand-toggle::before {
            transform: rotate(90deg);
        }

        .error-details-expandable .error-full-details {
            display: none;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 11px;
            line-height: 1.4;
        }

        .error-details-expandable.expanded .error-full-details {
            display: block;
        }

        /* Light mode adjustments */
        .light-mode .error-minimized {
            background: rgba(0, 0, 0, 0.03);
        }

        .light-mode .error-minimized:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        .light-mode .error-details-expandable {
            background: rgba(0, 0, 0, 0.02);
        }

        .light-mode .error-details-expandable .error-full-details {
            background: rgba(0, 0, 0, 0.05);
        }

        .result-notes {
            font-size: 13px;
            color: var(--text-tertiary);
            margin-top: 12px;
            line-height: 1.6;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .fade-in {
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .hero-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        @media (max-width: 768px) {
            .hero-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 10px 14px;
            text-align: center;
            backdrop-filter: blur(40px);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            background: var(--bg-card-hover);
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 2px;
            background: linear-gradient(135deg, #fff, rgba(255,255,255,0.7));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 10px;
            font-weight: 500;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .quick-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .quick-action {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 100px;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .quick-action:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .view-toggle {
            display: flex;
            gap: 6px;
        }

        .view-btn {
            padding: 5px 10px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 10px;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .view-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .view-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        /* Journey Profile Styles */
        .flight-plan-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .waypoint-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.04);
        }

        .waypoint-marker {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.5px;
            flex-shrink: 0;
        }

        .waypoint-marker.departure {
            background: linear-gradient(135deg, #4a4a4a, #6b7280);
            color: white;
        }

        .waypoint-marker.arrival {
            background: linear-gradient(135deg, var(--success), #059669);
            color: white;
        }

        .waypoint-marker.midpoint {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            border: 1px dashed rgba(255, 255, 255, 0.2);
        }

        .waypoint-fields {
            display: flex;
            gap: 8px;
            flex: 1;
            flex-wrap: wrap;
        }

        .waypoint-fields input {
            padding: 8px 12px;
            padding-left: 12px;
            flex: 1;
            min-width: 100px;
        }

        .waypoint-fields .waypoint-name {
            flex: 2;
            min-width: 180px;
        }

        .waypoint-fields .waypoint-alt {
            flex: 1;
            max-width: 120px;
        }

        .waypoint-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .add-waypoint-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px dashed rgba(255, 255, 255, 0.2);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
        }

        .add-waypoint-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            color: var(--text-primary);
            transform: none;
            box-shadow: none;
        }

        .remove-waypoint-btn {
            width: 36px;
            height: 36px;
            padding: 0;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 8px;
            color: var(--danger);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .remove-waypoint-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: none;
            box-shadow: none;
        }

        /* Profile Chart */
        .profile-header {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .profile-stats {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .profile-stat {
            display: flex;
            flex-direction: column;
        }

        .profile-stat-value {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, #fff, rgba(255,255,255,0.7));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .profile-stat-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-tertiary);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .legend-color.vfr { background: var(--vfr); }
        .legend-color.mvfr { background: var(--mvfr); }
        .legend-color.ifr { background: var(--ifr); }
        .legend-color.lifr { background: var(--lifr); }

        #waypointDetails {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
        }

        .waypoint-detail-card {
            padding: 10px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.04);
        }

        .waypoint-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .waypoint-detail-name {
            font-weight: 600;
            font-size: 13px;
        }

        .waypoint-detail-conditions {
            font-size: 10px;
            font-weight: 700;
            padding: 4px 10px;
            border-radius: 100px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .waypoint-detail-conditions.vfr {
            background: rgba(16, 185, 129, 0.15);
            color: var(--vfr);
        }
        .waypoint-detail-conditions.mvfr {
            background: rgba(59, 130, 246, 0.15);
            color: var(--mvfr);
        }
        .waypoint-detail-conditions.ifr {
            background: rgba(239, 68, 68, 0.15);
            color: var(--ifr);
        }
        .waypoint-detail-conditions.lifr {
            background: rgba(168, 85, 247, 0.15);
            color: var(--lifr);
        }

        .waypoint-detail-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 12px;
        }

        .waypoint-detail-info span {
            color: var(--text-tertiary);
        }

        .waypoint-detail-info strong {
            color: var(--text-primary);
        }

        /* Overlay Controls */
        .overlay-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.04);
        }

        .overlay-label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-tertiary);
            margin-right: 8px;
        }

        .overlay-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .overlay-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            transform: none;
            box-shadow: none;
        }

        .overlay-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .overlay-btn svg {
            opacity: 0.7;
        }

        .overlay-btn.active svg {
            opacity: 1;
        }

        /* Profile Chart Wrapper */
        .profile-chart-wrapper {
            position: relative;
            display: flex;
            gap: 12px;
        }

        .profile-chart-container {
            position: relative;
            height: 300px;
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 16px;
            overflow: hidden;
        }

        .altitude-scale {
            width: 60px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 12px 0;
            font-size: 11px;
            color: var(--text-tertiary);
            text-align: right;
        }

        /* Hover Indicator */
        .hover-indicator {
            position: absolute;
            top: 12px;
            left: 0;
            bottom: 12px;
            width: 2px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            z-index: 10;
        }

        .hover-indicator.active {
            opacity: 1;
        }

        .hover-line {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            width: 2px;
            background: linear-gradient(180deg, var(--accent), rgba(59, 130, 246, 0.3));
            box-shadow: 0 0 10px var(--accent);
        }

        .hover-line::before {
            content: '';
            position: absolute;
            top: var(--dot-top, 50%);
            left: -5px;
            width: 12px;
            height: 12px;
            background: var(--accent);
            border-radius: 50%;
            box-shadow: 0 0 12px var(--accent);
            transform: translateY(-50%);
        }

        .hover-tooltip {
            position: absolute;
            top: 10px;
            left: 16px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 10px;
            min-width: 160px;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .hover-tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .hover-location {
            font-weight: 600;
            font-size: 14px;
        }

        .hover-conditions {
            font-size: 10px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 100px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .hover-conditions.vfr { background: rgba(16, 185, 129, 0.2); color: var(--vfr); }
        .hover-conditions.mvfr { background: rgba(59, 130, 246, 0.2); color: var(--mvfr); }
        .hover-conditions.ifr { background: rgba(239, 68, 68, 0.2); color: var(--ifr); }
        .hover-conditions.lifr { background: rgba(168, 85, 247, 0.2); color: var(--lifr); }

        .hover-tooltip-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            font-size: 11px;
        }

        .hover-tooltip-grid div {
            display: flex;
            justify-content: space-between;
        }

        .hover-tooltip-grid span {
            color: var(--text-tertiary);
        }

        .hover-tooltip-grid strong {
            color: var(--text-primary);
        }

        /* Legend Sections */
        .profile-legend {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
        }

        .legend-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .legend-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-tertiary);
        }

        .legend-color.terrain-safe { background: #22c55e; }
        .legend-color.terrain-caution { background: #eab308; }
        .legend-color.terrain-warning { background: #ef4444; }

        /* Simplify Button & View */
        .simplify-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .simplify-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            transform: none;
            box-shadow: none;
        }

        .simplify-btn.active {
            background: linear-gradient(135deg, #4a4a4a, #6b7280);
            border-color: #6b7280;
            color: white;
        }

        .simplify-btn svg {
            width: 14px;
            height: 14px;
        }

        .simplified-view {
            display: none;
            padding: 12px;
            background: linear-gradient(135deg, rgba(107, 114, 128, 0.1), rgba(107, 114, 128, 0.05));
            border: 1px solid rgba(107, 114, 128, 0.2);
            border-radius: 12px;
            margin-top: 12px;
        }

        .simplified-view.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .simplified-summary {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .simplified-details {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .simplified-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
        }

        .simplified-icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 14px;
        }

        .simplified-icon.temp { background: rgba(239, 68, 68, 0.2); }
        .simplified-icon.wind { background: rgba(59, 130, 246, 0.2); }
        .simplified-icon.vis { background: rgba(16, 185, 129, 0.2); }
        .simplified-icon.sky { background: rgba(156, 163, 175, 0.2); }
        .simplified-icon.pressure { background: rgba(168, 85, 247, 0.2); }
        .simplified-icon.precip { background: rgba(6, 182, 212, 0.2); }

        .simplified-text {
            flex: 1;
        }

        .simplified-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: 2px;
        }

        .simplified-value {
            font-size: 12px;
            color: var(--text-primary);
            line-height: 1.3;
        }

        .taf-simplified-period {
            padding: 12px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
            margin-bottom: 8px;
            border-left: 3px solid var(--accent);
        }

        .taf-simplified-period:last-child {
            margin-bottom: 0;
        }

        .taf-simplified-time {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 6px;
        }

        .taf-simplified-summary {
            font-size: 12px;
            color: var(--text-primary);
            line-height: 1.4;
        }

        /* TAF Summary Banner */
        .taf-summary-banner {
            padding: 12px 16px;
            border-radius: 10px;
            margin-bottom: 12px;
            font-size: 13px;
            font-weight: 500;
            line-height: 1.4;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .taf-summary-banner.good {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(16, 185, 129, 0.1));
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: #86efac;
        }

        .taf-summary-banner.caution {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.1));
            border: 1px solid rgba(251, 191, 36, 0.3);
            color: #fde047;
        }

        .taf-summary-banner.bad {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.1));
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
        }

        /* TAF Periods List */
        .taf-periods-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .taf-period-card {
            padding: 14px 16px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border-left: 4px solid var(--accent);
            transition: all 0.2s ease;
        }

        .taf-period-card:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .taf-period-card.sun {
            border-left-color: #fbbf24;
        }

        .taf-period-card.cloud {
            border-left-color: #9ca3af;
        }

        .taf-period-card.rain {
            border-left-color: #6b7280;
        }

        .taf-period-card.storm {
            border-left-color: #ef4444;
        }

        .taf-period-card.fog {
            border-left-color: #a78bfa;
        }

        .taf-period-card.initial {
            border-left-color: #22d3ee;
        }

        .taf-period-card.from {
            border-left-color: #6b7280;
        }

        .taf-period-card.tempo {
            border-left-color: #f59e0b;
        }

        .taf-period-card.becmg {
            border-left-color: #6b7280;
        }

        .taf-period-card.prob {
            border-left-color: #ec4899;
        }

        .taf-period-header-simple {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--accent);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .taf-period-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .taf-line {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .taf-line:first-child {
            color: var(--text-primary);
            font-weight: 500;
        }

        /* 3D Terrain Visualizer */
        .terrain-3d-section {
            margin-top: 30px;
        }

        .terrain-3d-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(180deg, #0a0a0a 0%, #1a1a1a 50%, #2a2a2a 100%);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        #terrain3D {
            width: 100%;
            height: 100%;
        }

        .terrain-3d-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        .terrain-3d-btn {
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .terrain-3d-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .terrain-3d-btn.active {
            background: rgba(107, 114, 128, 0.3);
            border-color: rgba(107, 114, 128, 0.5);
        }

        .terrain-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
        }

        .terrain-legend-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: 10px;
        }

        .terrain-legend-items {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .terrain-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .terrain-legend-color {
            width: 20px;
            height: 12px;
            border-radius: 3px;
        }

        .terrain-info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
            min-width: 200px;
        }

        .terrain-info-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .terrain-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .terrain-info-label {
            color: var(--text-tertiary);
        }

        .terrain-info-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .flight-path-line {
            stroke: #00ff88;
            stroke-width: 3;
            filter: drop-shadow(0 0 8px rgba(0, 255, 136, 0.6));
        }

        .terrain-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            color: var(--text-secondary);
        }

        .terrain-loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Top Navigation Bar */
        .top-navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 24px;
            z-index: 9999;
        }

        .nav-content {
            display: flex;
            align-items: center;
            width: 100%;
            justify-content: center;
            position: relative;
        }

        .nav-brand {
            position: absolute;
            left: 0;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            text-decoration: none;
        }

        .nav-brand svg.orca-logo {
            width: auto;
            height: 20px;
            color: #ffffff;
        }

        .health-status {
            position: absolute;
            right: 48px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .theme-toggle {
            position: absolute;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-primary);
            flex-shrink: 0;
        }

        .theme-toggle:hover {
            background: var(--bg-card-hover);
            border-color: var(--text-tertiary);
        }

        .theme-toggle .sun-icon {
            display: none;
        }

        .theme-toggle .moon-icon {
            display: inline;
        }

        .light-mode .theme-toggle .sun-icon {
            display: inline;
        }

        .light-mode .theme-toggle .moon-icon {
            display: none;
        }

        .nav-links {
            display: flex;
            gap: 4px;
        }

        .nav-link {
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            text-decoration: none;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .nav-link.active {
            background: rgba(107, 114, 128, 0.15);
            color: var(--accent);
        }

        .nav-link svg {
            width: 16px;
            height: 16px;
        }

        /* Adjust dashboard for navbar */
        .dashboard {
            padding-top: 48px;
        }
    </style>
</head>
<body>
    <!-- Top Navigation Bar -->
    <nav class="top-navbar">
        <div class="nav-content">
            <a href="/" class="nav-brand">
                <svg class="orca-logo" viewBox="0 0 798 257" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path d="M67.8809 234.41C186.564 258.373 307.51 270.119 360.879 234.41C414.248 198.702 779.734 36.4014 796.092 14.7603C812.45 -6.88083 723.078 -6.93654 548.57 29.5108C375.251 65.7097 321.828 80.6187 159.348 125.963L155.986 126.901C-9.12734 172.979 -50.8019 210.448 67.8809 234.41Z"/>
                </svg>
                SkyEye
            </a>
            <div class="nav-links">
                <a href="/" class="nav-link active">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                        <polyline points="9 22 9 12 15 12 15 22"/>
                    </svg>
                    Weather
                </a>
            <a href="/live-map" class="nav-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                </svg>
                Live Map
            </a>
            <a href="/health-dashboard" class="nav-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 12h-4l-3 9L9 3l-3 9H2"/>
                </svg>
                Health
            </a>
            <a href="/compliance-dashboard" class="nav-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 11l3 3L22 4"/>
                    <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
                </svg>
                Compliance
            </a>
            <a href="/benchmarks-dashboard" class="nav-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 20V10"/>
                    <path d="M18 20V4"/>
                    <path d="M6 20v-4"/>
                </svg>
                Benchmarks
            </a>
            <a href="/competitive-analysis-dashboard" class="nav-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                </svg>
                Analysis
                </a>
            </div>
            <div class="health-status">
                <div class="health-dot" id="healthDot"></div>
                <span class="health-text" id="healthText">Connecting...</span>
            </div>
            <div class="theme-toggle" onclick="toggleTheme()" title="Toggle Light/Dark Mode" role="button" tabindex="0">
                    <svg class="moon-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg class="sun-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </div>
        </div>
    </nav>
    <div class="bg-gradient"></div>

    <!-- Dashboard Layout -->
    <div class="dashboard">
        <!-- Left Panel - Search & METAR/TAF -->
        <div class="panel-left">
            <div class="card compact">
                <div class="search-container" style="margin-bottom: 0;">
                    <div class="search-wrapper">
                        <input type="text" id="stationSearch" placeholder="Search ICAO..." style="padding: 10px 14px 10px 38px; font-size: 0.85rem;">
                        <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; left: 12px;">
                            <circle cx="11" cy="11" r="8"/>
                            <path d="M21 21l-4.35-4.35"/>
                        </svg>
                    </div>
                    <div class="search-results" id="searchResults"></div>
                </div>
                <div class="quick-actions" style="margin-top: 8px; gap: 4px;">
                    <div class="quick-action" data-station="KLAX" data-lat="33.94" data-lon="-118.41" style="padding: 4px 8px; font-size: 0.7rem;">KLAX</div>
                    <div class="quick-action" data-station="KJFK" data-lat="40.64" data-lon="-73.78" style="padding: 4px 8px; font-size: 0.7rem;">KJFK</div>
                    <div class="quick-action" data-station="KORD" data-lat="41.98" data-lon="-87.90" style="padding: 4px 8px; font-size: 0.7rem;">KORD</div>
                    <div class="quick-action" data-station="KATL" data-lat="33.64" data-lon="-84.43" style="padding: 4px 8px; font-size: 0.7rem;">KATL</div>
                </div>
            </div>

            <div class="card compact flex-grow" id="metarCard" style="overflow-y: auto;">
                <div class="empty-state" style="padding: 12px 8px;">
                    <svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width: 24px; height: 24px;">
                        <path d="M12 2v2m0 16v2M4 12H2m20 0h-2m-2.05-6.95l-1.41 1.41m-9.9 9.9l-1.41 1.41m0-12.72l1.41 1.41m9.9 9.9l1.41 1.41"/>
                        <circle cx="12" cy="12" r="4"/>
                    </svg>
                    <p style="font-size: 0.7rem;">Search for METAR</p>
                </div>
            </div>

            <div class="card compact flex-grow" id="tafCard" style="overflow-y: auto;">
                <div class="empty-state" style="padding: 12px 8px;">
                    <svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width: 24px; height: 24px;">
                        <path d="M3 15h4l3-9 4 18 3-9h4"/>
                    </svg>
                    <p style="font-size: 0.7rem;">Search for TAF</p>
                </div>
            </div>
        </div>

        <!-- Center Panel - Journey Profile & Forecast -->
        <div class="panel-center">

        <!-- Weather Map -->
        <div class="card" id="weatherMapCard">
            <div class="card-header">
                <span class="card-title">Weather Map</span>
                <div class="map-layer-toggles">
                    <button class="map-layer-btn active" data-layer="radar" title="Live Radar">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 2v10l7 7"/>
                        </svg>
                        <span>Radar</span>
                    </button>
                    <button class="map-layer-btn" data-layer="satellite" title="Satellite IR">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="3"/>
                            <path d="M12 1v4m0 14v4M4.22 4.22l2.83 2.83m9.9 9.9l2.83 2.83M1 12h4m14 0h4M4.22 19.78l2.83-2.83m9.9-9.9l2.83-2.83"/>
                        </svg>
                        <span>Satellite</span>
                    </button>
                    <button class="map-layer-btn" data-layer="temp" title="Temperature">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"/>
                        </svg>
                        <span>Temp</span>
                    </button>
                    <button class="map-layer-btn" data-layer="wind" title="Wind Speed">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"/>
                        </svg>
                        <span>Wind</span>
                    </button>
                    <button class="map-layer-btn" data-layer="clouds" title="Clouds">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"/>
                        </svg>
                        <span>Clouds</span>
                    </button>
                </div>
            </div>
            <div class="weather-map-container">
                <div id="weatherMap" class="weather-map"></div>
                <div class="map-stats-overlay" id="heroStats">
                    <div class="map-stat-card">
                        <div class="map-stat-value" id="statTemp">--</div>
                        <div class="map-stat-label">TEMP</div>
                    </div>
                    <div class="map-stat-card">
                        <div class="map-stat-value" id="statWind">--</div>
                        <div class="map-stat-label">WIND</div>
                    </div>
                    <div class="map-stat-card">
                        <div class="map-stat-value" id="statVis">--</div>
                        <div class="map-stat-label">VIS</div>
                    </div>
                    <div class="map-stat-card">
                        <div class="map-stat-value" id="statAlt">--</div>
                        <div class="map-stat-label">ALT</div>
                    </div>
                </div>
            </div>
            <div class="map-legend" id="mapLegend">
                <span class="legend-title">Precipitation (mm/h)</span>
                <div class="legend-gradient precipitation"></div>
                <div class="legend-labels">
                    <span>0</span>
                    <span>Light</span>
                    <span>Moderate</span>
                    <span>Heavy</span>
                </div>
            </div>
        </div>
        </div>

        <!-- Right Panel - Regulations & Details -->
        <div class="panel-right">
            <div class="card compact">
                <div class="card-header">
                    <span class="card-title">VFR Minimums</span>
                </div>
                <form class="regulation-form" id="vfrForm">
                    <div class="form-group">
                        <label>Station</label>
                        <input type="text" id="vfrStation" placeholder="KLAX" maxlength="4">
                    </div>
                    <div class="form-group">
                        <label>Altitude AGL</label>
                        <input type="number" id="vfrAltitude" placeholder="3000" value="3000">
                    </div>
                    <div class="form-group">
                        <label>Airspace Class</label>
                        <select id="vfrAirspace">
                            <option value="B">Class B</option>
                            <option value="C">Class C</option>
                            <option value="D">Class D</option>
                            <option value="E" selected>Class E</option>
                            <option value="G">Class G</option>
                        </select>
                    </div>
                    <button type="submit" style="width: 100%; margin-top: 8px;">Check VFR</button>
                </form>
                <div id="vfrResult"></div>
            </div>

            <div class="card compact">
                <div class="card-header">
                    <span class="card-title">Fuel Requirements</span>
                </div>
                <form class="regulation-form" id="fuelForm">
                    <div class="form-group">
                        <label>Flight Type</label>
                        <select id="fuelFlightType">
                            <option value="VFR">VFR</option>
                            <option value="IFR">IFR</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Flight Time (hrs)</label>
                        <input type="number" id="fuelFlightTime" step="0.1" placeholder="2.0" value="2.0">
                    </div>
                    <div class="form-group">
                        <label>Reserve (hrs)</label>
                        <input type="number" id="fuelReserve" step="0.1" placeholder="0.5" value="0.5">
                    </div>
                    <button type="submit" style="width: 100%; margin-top: 8px;">Check Fuel</button>
                </form>
                <div id="fuelResult"></div>
            </div>

            <div class="card compact" id="forecastCard">
                <div class="card-header">
                    <span class="card-title">Hourly Forecast</span>
                    <div class="chart-toggles" style="gap: 4px;">
                        <button class="chart-toggle active" data-chart="temperature" style="padding: 4px 8px; font-size: 0.7rem;">Temp</button>
                        <button class="chart-toggle" data-chart="wind" style="padding: 4px 8px; font-size: 0.7rem;">Wind</button>
                        <button class="chart-toggle" data-chart="precipitation" style="padding: 4px 8px; font-size: 0.7rem;">Precip</button>
                    </div>
                </div>
                <div class="chart-container" style="height: 180px;">
                    <canvas id="forecastChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = '/api';
        let currentStation = null;
        let forecastChart = null;
        let forecastData = null;
        let currentChartType = 'temperature';

        // Comprehensive list of US airports for geolocation
        const US_AIRPORTS = [
            // Major hubs
            {"icao": "KLAX", "name": "Los Angeles International", "lat": 33.94, "lon": -118.41},
            {"icao": "KJFK", "name": "John F Kennedy International", "lat": 40.64, "lon": -73.78},
            {"icao": "KORD", "name": "Chicago O'Hare International", "lat": 41.98, "lon": -87.90},
            {"icao": "KATL", "name": "Hartsfield-Jackson Atlanta", "lat": 33.64, "lon": -84.43},
            {"icao": "KDFW", "name": "Dallas/Fort Worth International", "lat": 32.90, "lon": -97.04},
            {"icao": "KDEN", "name": "Denver International", "lat": 39.86, "lon": -104.67},
            {"icao": "KSFO", "name": "San Francisco International", "lat": 37.62, "lon": -122.38},
            {"icao": "KLAS", "name": "Las Vegas McCarran", "lat": 36.08, "lon": -115.15},
            {"icao": "KSEA", "name": "Seattle-Tacoma International", "lat": 47.45, "lon": -122.31},
            {"icao": "KMCO", "name": "Orlando International", "lat": 28.43, "lon": -81.31},
            {"icao": "KPHX", "name": "Phoenix Sky Harbor", "lat": 33.43, "lon": -112.01},
            {"icao": "KIAH", "name": "Houston Intercontinental", "lat": 29.98, "lon": -95.34},
            {"icao": "KMIA", "name": "Miami International", "lat": 25.79, "lon": -80.29},
            {"icao": "KEWR", "name": "Newark Liberty International", "lat": 40.69, "lon": -74.17},
            {"icao": "KBOS", "name": "Boston Logan International", "lat": 42.36, "lon": -71.01},
            {"icao": "KMSP", "name": "Minneapolis-St Paul", "lat": 44.88, "lon": -93.22},
            {"icao": "KDTW", "name": "Detroit Metro Wayne County", "lat": 42.21, "lon": -83.35},
            {"icao": "KPHL", "name": "Philadelphia International", "lat": 39.87, "lon": -75.24},
            {"icao": "KLGA", "name": "LaGuardia", "lat": 40.78, "lon": -73.87},
            {"icao": "KFLL", "name": "Fort Lauderdale Hollywood", "lat": 26.07, "lon": -80.15},
            {"icao": "KBWI", "name": "Baltimore/Washington", "lat": 39.18, "lon": -76.67},
            {"icao": "KSLC", "name": "Salt Lake City International", "lat": 40.79, "lon": -111.98},
            {"icao": "KDCA", "name": "Ronald Reagan Washington", "lat": 38.85, "lon": -77.04},
            {"icao": "KIAD", "name": "Washington Dulles", "lat": 38.94, "lon": -77.46},
            {"icao": "KSAN", "name": "San Diego International", "lat": 32.73, "lon": -117.19},
            {"icao": "KTPA", "name": "Tampa International", "lat": 27.98, "lon": -82.53},
            {"icao": "KPDX", "name": "Portland International", "lat": 45.59, "lon": -122.60},
            {"icao": "KSTL", "name": "St Louis Lambert", "lat": 38.75, "lon": -90.37},
            {"icao": "KBNA", "name": "Nashville International", "lat": 36.12, "lon": -86.68},
            {"icao": "KAUS", "name": "Austin-Bergstrom", "lat": 30.19, "lon": -97.67},
            {"icao": "KSAT", "name": "San Antonio International", "lat": 29.53, "lon": -98.47},
            {"icao": "KSMF", "name": "Sacramento International", "lat": 38.70, "lon": -121.59},
            {"icao": "KCLT", "name": "Charlotte Douglas", "lat": 35.21, "lon": -80.94},
            {"icao": "KRDU", "name": "Raleigh-Durham", "lat": 35.88, "lon": -78.79},
            {"icao": "KMCI", "name": "Kansas City International", "lat": 39.30, "lon": -94.71},
            {"icao": "KCLE", "name": "Cleveland Hopkins", "lat": 41.41, "lon": -81.85},
            {"icao": "KIND", "name": "Indianapolis International", "lat": 39.72, "lon": -86.29},
            {"icao": "KCMH", "name": "Columbus John Glenn", "lat": 39.99, "lon": -82.89},
            {"icao": "KPIT", "name": "Pittsburgh International", "lat": 40.49, "lon": -80.23},
            {"icao": "KOAK", "name": "Oakland International", "lat": 37.72, "lon": -122.22},
            {"icao": "KSJC", "name": "San Jose Norman Mineta", "lat": 37.36, "lon": -121.93},
            {"icao": "KABQ", "name": "Albuquerque International", "lat": 35.04, "lon": -106.61},
            {"icao": "KOMA", "name": "Omaha Eppley Airfield", "lat": 41.30, "lon": -95.89},
            {"icao": "KMKE", "name": "Milwaukee Mitchell", "lat": 42.95, "lon": -87.90},
            {"icao": "KBUF", "name": "Buffalo Niagara", "lat": 42.94, "lon": -78.73},
            {"icao": "KPVD", "name": "Providence TF Green", "lat": 41.72, "lon": -71.43},
            {"icao": "KRNO", "name": "Reno-Tahoe International", "lat": 39.50, "lon": -119.77},
            {"icao": "KBOI", "name": "Boise Air Terminal", "lat": 43.56, "lon": -116.22},
            {"icao": "KHOU", "name": "Houston Hobby", "lat": 29.65, "lon": -95.28},
            {"icao": "KMDW", "name": "Chicago Midway", "lat": 41.79, "lon": -87.75},
            {"icao": "KDAL", "name": "Dallas Love Field", "lat": 32.85, "lon": -96.85},
            {"icao": "KBUR", "name": "Hollywood Burbank", "lat": 34.20, "lon": -118.36},
            {"icao": "KSNA", "name": "John Wayne Orange County", "lat": 33.68, "lon": -117.87},
            {"icao": "KONT", "name": "Ontario International", "lat": 34.06, "lon": -117.60},
            {"icao": "KANC", "name": "Anchorage Ted Stevens", "lat": 61.17, "lon": -150.00},
            {"icao": "PHNL", "name": "Honolulu Daniel K Inouye", "lat": 21.32, "lon": -157.92}
        ];

        // Calculate distance between two points (haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3440.065; // Earth radius in nautical miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Find nearest airport to given coordinates
        function findNearestAirport(lat, lon) {
            let nearest = null;
            let minDistance = Infinity;

            for (const airport of US_AIRPORTS) {
                const distance = calculateDistance(lat, lon, airport.lat, airport.lon);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = { ...airport, distance: Math.round(distance) };
                }
            }
            return nearest;
        }

        // Get user location and load nearest airport data
        async function loadNearestAirport() {
            if (!navigator.geolocation) {
                console.log('Geolocation not supported');
                return;
            }

            try {
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: false,
                        timeout: 5000,
                        maximumAge: 300000 // Cache for 5 minutes
                    });
                });

                const { latitude, longitude } = position.coords;
                const nearest = findNearestAirport(latitude, longitude);

                if (nearest) {
                    console.log(`Found nearest airport: ${nearest.icao} (${nearest.distance} nm away)`);
                    loadStationData(nearest.icao, nearest.lat, nearest.lon);
                }
            } catch (error) {
                console.log('Geolocation error or denied:', error.message);
                // Default to a major hub if geolocation fails
            }
        }

        // Chart.js global config for dark theme
        Chart.defaults.color = 'rgba(255, 255, 255, 0.6)';
        Chart.defaults.borderColor = 'rgba(255, 255, 255, 0.08)';

        // ==================== WEATHER MAP ====================
        let weatherMap = null;
        let currentWeatherLayer = null;
        let routeLayerGroup = null;
        let radarLayer = null;
        let satelliteLayer = null;
        let radarTimestamp = null;
        let windParticleSystem = null;
        const OWM_API_KEY = ''; // OpenWeatherMap API key (free tier works without key for tiles)

        // Wind Particle Animation System
        class WindParticleSystem {
            constructor(map, canvasId) {
                this.map = map;
                this.canvas = null;
                this.ctx = null;
                this.particles = [];
                this.animationId = null;
                this.isActive = false;
                this.particleCount = 500;
                this.fadeAmount = 0.97;

                this.createCanvas(canvasId);
                this.updateParticleCount();
                this.initParticles();
                this.bindMapEvents();
            }

            createCanvas(canvasId) {
                // Create canvas overlay
                this.canvas = document.createElement('canvas');
                this.canvas.id = canvasId;
                this.canvas.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 450;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;

                const mapContainer = this.map.getContainer();
                mapContainer.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
            }

            resizeCanvas() {
                const rect = this.map.getContainer().getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.updateParticleCount();
                this.initParticles();
            }

            updateParticleCount() {
                // Reduce particle density when zoomed in
                const zoom = this.map.getZoom();
                const baseCount = 500;

                // At zoom 4 (default), use full count
                // Reduce significantly as zoom increases
                if (zoom <= 4) {
                    this.particleCount = baseCount;
                } else if (zoom <= 6) {
                    this.particleCount = Math.floor(baseCount * 0.5);
                } else if (zoom <= 8) {
                    this.particleCount = Math.floor(baseCount * 0.25);
                } else if (zoom <= 10) {
                    this.particleCount = Math.floor(baseCount * 0.12);
                } else {
                    this.particleCount = Math.floor(baseCount * 0.06);
                }
            }

            bindMapEvents() {
                this.map.on('move', () => this.onMapMove());
                this.map.on('zoomend', () => this.onZoomEnd());
                this.map.on('resize', () => this.resizeCanvas());
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            onMapMove() {
                // Reset particles on map movement for smoother experience
                if (this.isActive) {
                    this.initParticles();
                }
            }

            onZoomEnd() {
                // Update particle count based on new zoom level
                if (this.isActive) {
                    this.updateParticleCount();
                    this.initParticles();
                }
            }

            initParticles() {
                this.particles = [];
                for (let i = 0; i < this.particleCount; i++) {
                    this.particles.push(this.createParticle());
                }
            }

            createParticle() {
                return {
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    age: Math.random() * 10,
                    maxAge: 10 + Math.random() * 8
                };
            }

            // Generate wind vector based on position (simulated global wind patterns)
            getWindVector(x, y) {
                const bounds = this.map.getBounds();
                const lat = bounds.getSouth() + (1 - y / this.canvas.height) * (bounds.getNorth() - bounds.getSouth());
                const lon = bounds.getWest() + (x / this.canvas.width) * (bounds.getEast() - bounds.getWest());

                // Simulate realistic wind patterns
                // Trade winds near equator (east to west)
                // Westerlies in mid-latitudes (west to east)
                // Polar easterlies near poles

                const time = Date.now() / 50000; // Slow time factor for variation

                let u, v; // Wind components (u = east-west, v = north-south)

                if (Math.abs(lat) < 30) {
                    // Trade winds - blow east to west with slight poleward component
                    u = -2 - Math.sin(lon * 0.1 + time) * 0.5;
                    v = lat > 0 ? 0.3 : -0.3;
                } else if (Math.abs(lat) < 60) {
                    // Westerlies - blow west to east, stronger at 45 degrees
                    const strength = 1 + Math.cos((Math.abs(lat) - 45) * Math.PI / 30);
                    u = 2 * strength + Math.sin(lon * 0.05 + lat * 0.1 + time) * 0.8;
                    v = Math.sin(lon * 0.1 + time * 2) * 0.5;
                } else {
                    // Polar easterlies
                    u = -1.5 + Math.cos(lon * 0.08 + time) * 0.4;
                    v = lat > 0 ? -0.2 : 0.2;
                }

                // Add some turbulence/variation
                const turbulence = 0.3;
                u += (Math.sin(x * 0.01 + y * 0.02 + time * 3) * turbulence);
                v += (Math.cos(x * 0.02 + y * 0.01 + time * 2.5) * turbulence);

                // Scale based on zoom level
                const zoom = this.map.getZoom();
                const scale = Math.pow(2, zoom - 4) * 0.08;

                return { u: u * scale, v: v * scale };
            }

            updateParticles() {
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    const wind = this.getWindVector(p.x, p.y);

                    // Store previous position for trail
                    p.prevX = p.x;
                    p.prevY = p.y;

                    // Update position
                    p.x += wind.u;
                    p.y -= wind.v; // Negative because canvas y is inverted
                    p.age++;

                    // Reset particle if it's too old or out of bounds
                    if (p.age > p.maxAge ||
                        p.x < 0 || p.x > this.canvas.width ||
                        p.y < 0 || p.y > this.canvas.height) {

                        // Respawn at random edge or position
                        if (Math.random() > 0.5) {
                            // Spawn at edge opposite to wind direction
                            const wind = this.getWindVector(this.canvas.width / 2, this.canvas.height / 2);
                            if (Math.abs(wind.u) > Math.abs(wind.v)) {
                                p.x = wind.u > 0 ? 0 : this.canvas.width;
                                p.y = Math.random() * this.canvas.height;
                            } else {
                                p.x = Math.random() * this.canvas.width;
                                p.y = wind.v > 0 ? this.canvas.height : 0;
                            }
                        } else {
                            p.x = Math.random() * this.canvas.width;
                            p.y = Math.random() * this.canvas.height;
                        }
                        p.age = 0;
                        p.maxAge = 80 + Math.random() * 40;
                        p.prevX = p.x;
                        p.prevY = p.y;
                    }
                }
            }

            draw() {
                // Fade existing trails
                this.ctx.fillStyle = `rgba(0, 0, 0, ${1 - this.fadeAmount})`;
                this.ctx.globalCompositeOperation = 'destination-out';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.globalCompositeOperation = 'source-over';

                // Draw particles - thinner lines when zoomed in
                const zoom = this.map.getZoom();
                const lineWidth = zoom <= 4 ? 1 : zoom <= 6 ? 0.8 : 0.5;
                this.ctx.lineWidth = lineWidth;

                for (const p of this.particles) {
                    if (p.prevX === undefined) continue;

                    // Fade based on age
                    const ageFactor = 1 - (p.age / p.maxAge);
                    const alpha = Math.min(0.8, ageFactor * 0.8);

                    if (alpha > 0.05) {
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                        this.ctx.moveTo(p.prevX, p.prevY);
                        this.ctx.lineTo(p.x, p.y);
                        this.ctx.stroke();
                    }
                }
            }

            animate() {
                if (!this.isActive) return;

                this.updateParticles();
                this.draw();
                this.animationId = requestAnimationFrame(() => this.animate());
            }

            start() {
                if (this.isActive) return;
                this.isActive = true;
                this.canvas.style.opacity = '1';
                this.initParticles();
                this.animate();
            }

            stop() {
                this.isActive = false;
                this.canvas.style.opacity = '0';
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                // Clear canvas
                setTimeout(() => {
                    if (!this.isActive) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                }, 300);
            }

            destroy() {
                this.stop();
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
            }
        }

        function initWeatherMap() {
            // Initialize map centered on US
            weatherMap = L.map('weatherMap', {
                center: [39.8283, -98.5795],
                zoom: 4,
                zoomControl: true,
                attributionControl: true
            });

            // Dark base map tiles (CartoDB Dark Matter)
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(weatherMap);

            // Initialize route layer group
            routeLayerGroup = L.layerGroup().addTo(weatherMap);

            // Initialize wind particle system
            windParticleSystem = new WindParticleSystem(weatherMap, 'windParticleCanvas');

            // Load RainViewer layers
            loadRainViewerLayers();

            // Add default weather layer (radar)
            setWeatherLayer('radar');

            // Setup layer toggle buttons
            document.querySelectorAll('.map-layer-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.map-layer-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    setWeatherLayer(btn.dataset.layer);
                });
            });
        }

        // Load RainViewer radar and satellite layers
        async function loadRainViewerLayers() {
            try {
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                const data = await response.json();

                // Load radar layer
                if (data.radar && data.radar.past && data.radar.past.length > 0) {
                    const latestRadar = data.radar.past[data.radar.past.length - 1];
                    radarTimestamp = new Date(latestRadar.time * 1000);

                    if (radarLayer) {
                        weatherMap.removeLayer(radarLayer);
                    }

                    radarLayer = L.tileLayer(`https://tilecache.rainviewer.com${latestRadar.path}/256/{z}/{x}/{y}/4/1_1.png`, {
                        opacity: 0.7,
                        zIndex: 100
                    });
                }

                // Load satellite/clouds layer
                if (data.satellite && data.satellite.infrared && data.satellite.infrared.length > 0) {
                    const latestSat = data.satellite.infrared[data.satellite.infrared.length - 1];

                    if (satelliteLayer) {
                        weatherMap.removeLayer(satelliteLayer);
                    }

                    satelliteLayer = L.tileLayer(`https://tilecache.rainviewer.com${latestSat.path}/256/{z}/{x}/{y}/0/0_0.png`, {
                        opacity: 0.5,
                        zIndex: 90
                    });
                }
            } catch (error) {
                console.error('Failed to load RainViewer layers:', error);
            }
        }

        function setWeatherLayer(layerType) {
            // Remove current layer
            if (currentWeatherLayer) {
                weatherMap.removeLayer(currentWeatherLayer);
                currentWeatherLayer = null;
            }

            // Also remove radar/satellite if switching away
            if (radarLayer) weatherMap.removeLayer(radarLayer);
            if (satelliteLayer) weatherMap.removeLayer(satelliteLayer);

            // Control wind particle animation
            if (windParticleSystem) {
                if (layerType === 'wind') {
                    windParticleSystem.start();
                } else {
                    windParticleSystem.stop();
                }
            }

            // Legend info for each layer
            const legendInfo = {
                radar: { title: 'Precipitation Radar', labels: ['None', 'Light', 'Moderate', 'Heavy'] },
                satellite: { title: 'Cloud Cover (IR)', labels: ['Clear', 'Thin', 'Medium', 'Thick'] },
                precipitation: { title: 'Precipitation (mm/h)', labels: ['0', 'Light', 'Moderate', 'Heavy'] },
                clouds: { title: 'Cloud Cover (%)', labels: ['0%', '25%', '50%', '100%'] },
                temp: { title: 'Temperature', labels: ['-40Â°', '0Â°', '20Â°', '40Â°C'] },
                wind: { title: 'Wind Speed', labels: ['0', '25', '50', '100+ kt'] },
                pressure: { title: 'Pressure (hPa)', labels: ['950', '1000', '1025', '1050'] }
            };

            // Handle RainViewer layers
            if (layerType === 'radar') {
                if (radarLayer) {
                    radarLayer.addTo(weatherMap);
                } else {
                    // Fallback to OWM precipitation if radar not loaded
                    currentWeatherLayer = L.tileLayer(
                        `https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=9de243494c0b295cca9337e1e96b00e2`,
                        { opacity: 0.7, maxZoom: 19 }
                    ).addTo(weatherMap);
                }
            } else if (layerType === 'satellite') {
                if (satelliteLayer) {
                    satelliteLayer.addTo(weatherMap);
                } else {
                    // Fallback to OWM clouds if satellite not loaded
                    currentWeatherLayer = L.tileLayer(
                        `https://tile.openweathermap.org/map/clouds_new/{z}/{x}/{y}.png?appid=9de243494c0b295cca9337e1e96b00e2`,
                        { opacity: 0.7, maxZoom: 19 }
                    ).addTo(weatherMap);
                }
            } else {
                // OpenWeatherMap layer codes
                const layerCodes = {
                    precipitation: 'precipitation_new',
                    clouds: 'clouds_new',
                    temp: 'temp_new',
                    wind: 'wind_new',
                    pressure: 'pressure_new'
                };

                const layerCode = layerCodes[layerType];
                if (layerCode) {
                    currentWeatherLayer = L.tileLayer(
                        `https://tile.openweathermap.org/map/${layerCode}/{z}/{x}/{y}.png?appid=9de243494c0b295cca9337e1e96b00e2`,
                        { opacity: 0.7, maxZoom: 19 }
                    ).addTo(weatherMap);
                }
            }

            // Update legend
            if (legendInfo[layerType]) {
                updateMapLegend(layerType, legendInfo[layerType]);
            }
        }

        function updateMapLegend(layerType, info) {
            const legend = document.getElementById('mapLegend');
            const gradient = legend.querySelector('.legend-gradient');
            const title = legend.querySelector('.legend-title');
            const labels = legend.querySelector('.legend-labels');

            // Update title
            title.textContent = info.title;

            // Update gradient class
            gradient.className = 'legend-gradient ' + layerType;

            // Update labels
            labels.innerHTML = info.labels.map(l => `<span>${l}</span>`).join('');
        }

        function updateMapWithRoute(waypoints) {
            if (!weatherMap || !routeLayerGroup) return;

            // Clear existing route
            routeLayerGroup.clearLayers();

            if (waypoints.length < 2) return;

            // Create route line (handle both lat/lon and latitude/longitude formats)
            const routeCoords = waypoints.map(wp => [
                wp.latitude || wp.lat,
                wp.longitude || wp.lon
            ]);
            const routeLine = L.polyline(routeCoords, {
                color: '#6b7280',
                weight: 3,
                opacity: 0.8,
                dashArray: '10, 10'
            }).addTo(routeLayerGroup);

            // Add markers for each waypoint
            waypoints.forEach((wp, index) => {
                const isFirst = index === 0;
                const isLast = index === waypoints.length - 1;
                const lat = wp.latitude || wp.lat;
                const lon = wp.longitude || wp.lon;
                const alt = wp.altitude_ft || wp.alt || 0;

                const markerColor = isFirst ? '#10b981' : (isLast ? '#ef4444' : '#6b7280');
                const markerSize = (isFirst || isLast) ? 10 : 6;

                const marker = L.circleMarker([lat, lon], {
                    radius: markerSize,
                    fillColor: markerColor,
                    color: '#ffffff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 1
                }).addTo(routeLayerGroup);

                // Add popup with waypoint info
                if (wp.name) {
                    marker.bindPopup(`<b>${wp.name}</b><br>Alt: ${alt} ft`);
                }
            });

            // Fit map to show entire route
            weatherMap.fitBounds(routeLine.getBounds(), { padding: [30, 30] });
        }

        function centerMapOnStation(lat, lon, name) {
            if (!weatherMap) return;

            weatherMap.setView([lat, lon], 8);

            // Add station marker
            routeLayerGroup.clearLayers();
            L.circleMarker([lat, lon], {
                radius: 8,
                fillColor: '#6b7280',
                color: '#ffffff',
                weight: 2,
                opacity: 1,
                fillOpacity: 1
            }).addTo(routeLayerGroup).bindPopup(`<b>${name}</b>`).openPopup();
        }

        // Initialize map when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initWeatherMap, 100);
        });

        async function checkHealth() {
            try {
                const res = await fetch('/health');
                const data = await res.json();
                const dot = document.getElementById('healthDot');
                const text = document.getElementById('healthText');
                if (data.status === 'healthy') {
                    dot.classList.add('healthy');
                    text.textContent = 'All Systems Operational';
                } else {
                    text.textContent = 'Degraded';
                }
            } catch (e) {
                document.getElementById('healthText').textContent = 'Offline';
            }
        }

        const searchInput = document.getElementById('stationSearch');
        const searchResults = document.getElementById('searchResults');
        let searchTimeout;

        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            const query = e.target.value.trim();
            if (query.length < 2) {
                searchResults.classList.remove('active');
                return;
            }
            searchTimeout = setTimeout(() => searchStations(query), 200);
        });

        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const query = e.target.value.trim().toUpperCase();
                if (query.length >= 3) {
                    searchResults.classList.remove('active');
                    loadStationData(query);
                }
            }
        });

        async function searchStations(query) {
            try {
                const res = await fetch(`${API_BASE}/stations/search?query=${encodeURIComponent(query)}`);
                const stations = await res.json();
                if (stations.length > 0) {
                    searchResults.innerHTML = stations.map(s => `
                        <div class="search-result-item" data-icao="${s.icao}" data-lat="${s.lat}" data-lon="${s.lon}">
                            <div class="icao">${s.icao}</div>
                            <div class="name">${s.name}</div>
                        </div>
                    `).join('');
                    searchResults.classList.add('active');
                } else {
                    searchResults.classList.remove('active');
                }
            } catch (e) {
                console.error('Search error:', e);
            }
        }

        searchResults.addEventListener('click', (e) => {
            const item = e.target.closest('.search-result-item');
            if (item) {
                const icao = item.dataset.icao;
                const lat = parseFloat(item.dataset.lat);
                const lon = parseFloat(item.dataset.lon);
                searchInput.value = icao;
                searchResults.classList.remove('active');
                loadStationData(icao, lat, lon);
            }
        });

        document.querySelectorAll('.quick-action').forEach(btn => {
            btn.addEventListener('click', () => {
                const station = btn.dataset.station;
                const lat = parseFloat(btn.dataset.lat);
                const lon = parseFloat(btn.dataset.lon);
                searchInput.value = station;
                loadStationData(station, lat, lon);
            });
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                searchResults.classList.remove('active');
            }
        });

        async function loadStationData(icao, lat, lon) {
            currentStation = icao;
            document.getElementById('vfrStation').value = icao;

            // Center map on station if coordinates available
            if (lat && lon) {
                centerMapOnStation(lat, lon, icao);
            }

            Promise.all([
                loadMetar(icao),
                loadTaf(icao),
                lat && lon ? loadForecast(lat, lon) : Promise.resolve()
            ]);
        }

        // Retry state tracking
        const retryState = {
            metar: { attempts: 0, maxAttempts: 5, retryDelay: 3000, timer: null },
            taf: { attempts: 0, maxAttempts: 5, retryDelay: 3000, timer: null }
        };

        async function loadMetar(station, isRetry = false) {
            const card = document.getElementById('metarCard');
            const state = retryState.metar;

            // Clear any existing retry timer
            if (state.timer) {
                clearTimeout(state.timer);
                state.timer = null;
            }

            // Reset attempts if this is a new station (not a retry)
            if (!isRetry) {
                state.attempts = 0;
            }

            state.attempts++;

            // Show loading state with retry info
            if (state.attempts > 1) {
                card.innerHTML = `
                    <div class="loading-retry-state">
                        <div class="loading-spinner"></div>
                        <div class="retry-text">Retrying METAR... (${state.attempts}/${state.maxAttempts})</div>
                        <div class="error-minimized" onclick="this.classList.toggle('expanded')">
                            <span class="error-toggle">â“˜ Previous attempt failed</span>
                            <div class="error-details">Connection issue - retrying automatically</div>
                        </div>
                    </div>
                `;
            } else {
                card.classList.add('loading');
            }

            try {
                const res = await fetch(`${API_BASE}/aviation/metar/${station}`);
                if (!res.ok) throw new Error('Station not found');
                const data = await res.json();
                state.attempts = 0; // Reset on success

                document.getElementById('statTemp').textContent = data.temperature !== null ? `${data.temperature}Â°` : '--';
                document.getElementById('statWind').textContent = data.wind_speed !== null ? `${data.wind_speed}kt` : '--';
                document.getElementById('statVis').textContent = data.visibility !== null ? `${data.visibility}SM` : '--';
                document.getElementById('statAlt').textContent = data.altimeter !== null ? data.altimeter.toFixed(2) : '--';

                const obsTime = new Date(data.observation_time).toLocaleString();
                const windStr = data.wind_direction !== null
                    ? `${String(data.wind_direction).padStart(3, '0')}Â° @ ${data.wind_speed}kt${data.wind_gust ? ` G${data.wind_gust}` : ''}`
                    : 'Calm';

                const simplifiedMetar = generateSimplifiedMetar(data);

                card.innerHTML = `
                    <div class="card-header">
                        <span class="card-title">Current METAR</span>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button class="simplify-btn active" onclick="toggleSimplify('metar', this)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"/>
                                </svg>
                                <span class="toggle-label">Raw</span>
                            </button>
                            <span class="flight-rules ${data.flight_rules.toLowerCase()}">${data.flight_rules}</span>
                        </div>
                    </div>
                    <div class="station-name">${data.station}</div>
                    <div class="observation-time">${obsTime}</div>
                    <div id="metarTechnical" style="display: none;">
                        <div class="data-grid">
                            <div class="data-item">
                                <span class="data-label">Temperature</span>
                                <span class="data-value large">${data.temperature !== null ? data.temperature : '--'}<span class="data-unit">Â°C</span></span>
                            </div>
                            <div class="data-item">
                                <span class="data-label">Dewpoint</span>
                                <span class="data-value large">${data.dewpoint !== null ? data.dewpoint : '--'}<span class="data-unit">Â°C</span></span>
                            </div>
                            <div class="data-item">
                                <span class="data-label">Wind</span>
                                <span class="data-value">${windStr}</span>
                            </div>
                            <div class="data-item">
                                <span class="data-label">Visibility</span>
                                <span class="data-value">${data.visibility !== null ? data.visibility : '--'}<span class="data-unit">SM</span></span>
                            </div>
                            <div class="data-item">
                                <span class="data-label">Altimeter</span>
                                <span class="data-value">${data.altimeter !== null ? data.altimeter.toFixed(2) : '--'}<span class="data-unit">inHg</span></span>
                            </div>
                            <div class="data-item">
                                <span class="data-label">Sky Condition</span>
                                <span class="data-value">${data.sky_conditions.map(c => c.cover + (c.base ? ` ${c.base}'` : '')).join(', ') || 'CLR'}</span>
                            </div>
                        </div>
                        <div class="raw-text">${data.raw_text}</div>
                    </div>
                    <div class="simplified-view active" id="metarSimplified">
                        <div class="simplified-summary">${simplifiedMetar.summary}</div>
                        <div class="simplified-details">
                            ${simplifiedMetar.details.map(d => `
                                <div class="simplified-item">
                                    <div class="simplified-icon ${d.icon}">${d.emoji}</div>
                                    <div class="simplified-text">
                                        <div class="simplified-label">${d.label}</div>
                                        <div class="simplified-value">${d.value}</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                card.classList.add('fade-in');
            } catch (e) {
                // Retry logic for METAR
                if (state.attempts < state.maxAttempts) {
                    card.innerHTML = `
                        <div class="loading-retry-state">
                            <div class="loading-spinner"></div>
                            <div class="retry-text">Retrying METAR in ${state.retryDelay/1000}s... (${state.attempts}/${state.maxAttempts})</div>
                            <div class="error-minimized" onclick="this.classList.toggle('expanded')">
                                <span class="error-toggle">â“˜ Connection issue</span>
                                <div class="error-details">Unable to load METAR for ${station}. Retrying automatically...</div>
                            </div>
                        </div>
                    `;
                    state.timer = setTimeout(() => loadMetar(station, true), state.retryDelay);
                } else {
                    // Max retries reached - show final error with retry button
                    card.innerHTML = `
                        <div class="error-state-final">
                            <div class="error-message-minimized">
                                <svg class="error-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <line x1="12" y1="8" x2="12" y2="12"/>
                                    <line x1="12" y1="16" x2="12.01" y2="16"/>
                                </svg>
                                <span>METAR unavailable</span>
                                <button class="retry-btn" onclick="loadMetar('${station}')">Retry</button>
                            </div>
                            <div class="error-details-expandable" onclick="this.classList.toggle('expanded')">
                                <span class="expand-toggle">Show details</span>
                                <div class="error-full-details">Unable to load METAR for ${station} after ${state.maxAttempts} attempts. The station may be temporarily unavailable.</div>
                            </div>
                        </div>
                    `;
                    state.attempts = 0; // Reset for manual retry
                }
            }
            card.classList.remove('loading');
        }

        async function loadTaf(station, isRetry = false) {
            const card = document.getElementById('tafCard');
            const state = retryState.taf;

            // Clear any existing retry timer
            if (state.timer) {
                clearTimeout(state.timer);
                state.timer = null;
            }

            // Reset attempts if this is a new station (not a retry)
            if (!isRetry) {
                state.attempts = 0;
            }

            state.attempts++;

            // Show loading state with retry info
            if (state.attempts > 1) {
                card.innerHTML = `
                    <div class="loading-retry-state">
                        <div class="loading-spinner"></div>
                        <div class="retry-text">Retrying TAF... (${state.attempts}/${state.maxAttempts})</div>
                        <div class="error-minimized" onclick="this.classList.toggle('expanded')">
                            <span class="error-toggle">â“˜ Previous attempt failed</span>
                            <div class="error-details">Connection issue - retrying automatically</div>
                        </div>
                    </div>
                `;
            } else {
                card.classList.add('loading');
            }

            try {
                const res = await fetch(`${API_BASE}/aviation/taf/${station}`);
                if (!res.ok) throw new Error('TAF not found');
                const data = await res.json();
                state.attempts = 0; // Reset on success

                const validFrom = new Date(data.valid_period_start).toLocaleString();
                const validTo = new Date(data.valid_period_end).toLocaleString();

                const periodsHtml = data.forecast_periods.map(p => {
                    const windStr = p.wind_direction !== null
                        ? `${p.wind_direction}Â° @ ${p.wind_speed}kt${p.wind_gust ? ` G${p.wind_gust}` : ''}`
                        : 'Calm';
                    return `
                        <div class="taf-period">
                            <div class="taf-period-header">${p.change_indicator || 'FROM'}</div>
                            <div class="taf-period-details">
                                <div class="taf-detail">
                                    <svg class="taf-detail-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"/>
                                    </svg>
                                    <span>${windStr}</span>
                                </div>
                                <div class="taf-detail">
                                    <svg class="taf-detail-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="10"/>
                                        <circle cx="12" cy="12" r="3"/>
                                    </svg>
                                    <span>${p.visibility !== null ? p.visibility + ' SM' : '--'}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                const simplifiedTaf = generateSimplifiedTaf(data);

                card.innerHTML = `
                    <div class="card-header">
                        <span class="card-title">Terminal Forecast</span>
                        <button class="simplify-btn active" onclick="toggleSimplify('taf', this)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"/>
                            </svg>
                            <span class="toggle-label">Raw</span>
                        </button>
                    </div>
                    <div class="station-name">${data.station}</div>
                    <div class="valid-period">Valid: ${validFrom} â€” ${validTo}</div>
                    <div id="tafTechnical" style="display: none;">
                        ${periodsHtml}
                        <div class="raw-text">${data.raw_text}</div>
                    </div>
                    <div class="simplified-view active" id="tafSimplified">
                        <div class="taf-summary-banner ${simplifiedTaf.summary.includes('âœ…') ? 'good' : simplifiedTaf.summary.includes('â›ˆï¸') || simplifiedTaf.summary.includes('â„ï¸') ? 'bad' : 'caution'}">
                            ${simplifiedTaf.summary}
                        </div>
                        <div class="taf-periods-list">
                            ${simplifiedTaf.periods.map(p => `
                                <div class="taf-period-card ${p.icon}">
                                    <div class="taf-period-header-simple">${p.time}</div>
                                    <div class="taf-period-content">${p.description.split('\n').map(line => `<div class="taf-line">${line}</div>`).join('')}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                card.classList.add('fade-in');
            } catch (e) {
                // Retry logic for TAF
                if (state.attempts < state.maxAttempts) {
                    card.innerHTML = `
                        <div class="loading-retry-state">
                            <div class="loading-spinner"></div>
                            <div class="retry-text">Retrying TAF in ${state.retryDelay/1000}s... (${state.attempts}/${state.maxAttempts})</div>
                            <div class="error-minimized" onclick="this.classList.toggle('expanded')">
                                <span class="error-toggle">â“˜ Connection issue</span>
                                <div class="error-details">Unable to load TAF for ${station}. Retrying automatically...</div>
                            </div>
                        </div>
                    `;
                    state.timer = setTimeout(() => loadTaf(station, true), state.retryDelay);
                } else {
                    // Max retries reached - show final error with retry button
                    card.innerHTML = `
                        <div class="error-state-final">
                            <div class="error-message-minimized">
                                <svg class="error-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <line x1="12" y1="8" x2="12" y2="12"/>
                                    <line x1="12" y1="16" x2="12.01" y2="16"/>
                                </svg>
                                <span>TAF unavailable</span>
                                <button class="retry-btn" onclick="loadTaf('${station}')">Retry</button>
                            </div>
                            <div class="error-details-expandable" onclick="this.classList.toggle('expanded')">
                                <span class="expand-toggle">Show details</span>
                                <div class="error-full-details">Unable to load TAF for ${station} after ${state.maxAttempts} attempts. TAF may not be available for this station.</div>
                            </div>
                        </div>
                    `;
                    state.attempts = 0; // Reset for manual retry
                }
            }
            card.classList.remove('loading');
        }

        function createChart(data, type) {
            const ctx = document.getElementById('forecastChart').getContext('2d');

            if (forecastChart) {
                forecastChart.destroy();
            }

            const labels = data.map(f => {
                const date = new Date(f.timestamp);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            });

            let chartData, label, color, unit;

            switch(type) {
                case 'temperature':
                    chartData = data.map(f => f.temperature_2m);
                    label = 'Temperature';
                    color = '#ef4444';
                    unit = 'Â°F';
                    break;
                case 'wind':
                    chartData = data.map(f => f.wind_speed_10m);
                    label = 'Wind Speed';
                    color = '#6b7280';
                    unit = ' kt';
                    break;
                case 'clouds':
                    chartData = data.map(f => f.cloud_cover);
                    label = 'Cloud Cover';
                    color = '#9ca3af';
                    unit = '%';
                    break;
                case 'pressure':
                    chartData = data.map(f => f.pressure_msl);
                    label = 'Pressure';
                    color = '#10b981';
                    unit = ' hPa';
                    break;
            }

            forecastChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: chartData,
                        borderColor: color,
                        backgroundColor: color + '20',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: color,
                        pointBorderColor: '#000',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: 'rgba(255, 255, 255, 0.1)',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    return `${label}: ${context.raw.toFixed(1)}${unit}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                maxRotation: 0,
                                autoSkip: true,
                                maxTicksLimit: 8
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + (type === 'clouds' ? '%' : type === 'temperature' ? 'Â°' : '');
                                }
                            }
                        }
                    }
                }
            });
        }

        function switchChartType(type) {
            currentChartType = type;
            document.querySelectorAll('.chart-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.type === type);
            });
            if (forecastData) {
                createChart(forecastData, type);
            }
        }

        async function loadForecast(lat, lon) {
            const card = document.getElementById('forecastCard');
            card.classList.add('loading');
            try {
                const res = await fetch(`${API_BASE}/weather/forecast?latitude=${lat}&longitude=${lon}&hours=24`);
                if (!res.ok) throw new Error('Forecast unavailable');
                const data = await res.json();
                forecastData = data;

                const rows = data.slice(0, 12).map(f => {
                    const time = new Date(f.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const date = new Date(f.timestamp).toLocaleDateString([], { month: 'short', day: 'numeric' });
                    return `
                        <tr>
                            <td><strong>${time}</strong><br><span style="color: var(--text-tertiary); font-size: 12px;">${date}</span></td>
                            <td>${f.temperature_2m.toFixed(0)}Â°F</td>
                            <td>${f.wind_direction_10m}Â° @ ${f.wind_speed_10m.toFixed(0)}kt</td>
                            <td>${f.cloud_cover}%</td>
                            <td>${(f.visibility / 1000).toFixed(1)} km</td>
                            <td>${f.pressure_msl.toFixed(0)} hPa</td>
                        </tr>
                    `;
                }).join('');

                card.innerHTML = `
                    <div class="card-header">
                        <span class="card-title">24-Hour Forecast</span>
                        <div class="view-toggle">
                            <button class="view-btn active" id="chartViewBtn">Chart</button>
                            <button class="view-btn" id="tableViewBtn">Table</button>
                        </div>
                    </div>
                    <div id="chartView">
                        <div class="chart-tabs">
                            <div class="chart-tab active" data-type="temperature">Temperature</div>
                            <div class="chart-tab" data-type="wind">Wind Speed</div>
                            <div class="chart-tab" data-type="clouds">Cloud Cover</div>
                            <div class="chart-tab" data-type="pressure">Pressure</div>
                        </div>
                        <div class="chart-container">
                            <canvas id="forecastChart"></canvas>
                        </div>
                    </div>
                    <div id="tableView" style="display: none;">
                        <div class="forecast-scroll">
                            <table class="forecast-table">
                                <thead>
                                    <tr>
                                        <th>Time</th>
                                        <th>Temp</th>
                                        <th>Wind</th>
                                        <th>Clouds</th>
                                        <th>Visibility</th>
                                        <th>Pressure</th>
                                    </tr>
                                </thead>
                                <tbody>${rows}</tbody>
                            </table>
                        </div>
                    </div>
                `;

                // Setup chart tabs
                document.querySelectorAll('.chart-tab').forEach(tab => {
                    tab.addEventListener('click', () => switchChartType(tab.dataset.type));
                });

                // Setup view toggle
                document.getElementById('chartViewBtn').addEventListener('click', () => {
                    document.getElementById('chartView').style.display = 'block';
                    document.getElementById('tableView').style.display = 'none';
                    document.getElementById('chartViewBtn').classList.add('active');
                    document.getElementById('tableViewBtn').classList.remove('active');
                });

                document.getElementById('tableViewBtn').addEventListener('click', () => {
                    document.getElementById('chartView').style.display = 'none';
                    document.getElementById('tableView').style.display = 'block';
                    document.getElementById('tableViewBtn').classList.add('active');
                    document.getElementById('chartViewBtn').classList.remove('active');
                });

                // Create initial chart
                createChart(data, 'temperature');
                card.classList.add('fade-in');
            } catch (e) {
                card.innerHTML = `<div class="error-message">Unable to load forecast data.</div>`;
            }
            card.classList.remove('loading');
        }

        // VFR Minimums check
        document.getElementById('vfrForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const station = document.getElementById('vfrStation').value.trim().toUpperCase();
            const altitude = document.getElementById('vfrAltitude').value;
            const airspace = document.getElementById('vfrAirspace').value;

            if (!station) {
                alert('Please enter a station code');
                return;
            }

            const resultDiv = document.getElementById('vfrResult');
            const submitBtn = e.target.querySelector('button[type="submit"]');

            // Show loading state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Checking...';
            resultDiv.innerHTML = '<div style="color: var(--text-tertiary); padding: 10px;">Loading...</div>';

            try {
                const res = await fetch(`${API_BASE}/regulations/check/vfr?station=${station}&altitude_agl=${altitude}&airspace_class=${airspace}`);
                if (!res.ok) throw new Error('Check failed');
                const data = await res.json();

                resultDiv.innerHTML = `
                    <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 8px;">
                        Checked: ${station} â€¢ ${altitude} ft AGL â€¢ Class ${airspace}
                    </div>
                ` + data.map(check => `
                    <div class="status-badge ${check.compliant ? 'compliant' : 'non-compliant'}">
                        <svg class="status-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            ${check.compliant
                                ? '<path d="M20 6L9 17l-5-5"/>'
                                : '<path d="M18 6L6 18M6 6l12 12"/>'}
                        </svg>
                        ${check.compliant ? 'Compliant' : 'Non-Compliant'}
                    </div>
                    <p class="result-notes">${check.notes}</p>
                `).join('');
            } catch (e) {
                resultDiv.innerHTML = `<div class="error-message">Unable to check VFR minimums</div>`;
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Check VFR';
            }
        });

        // Fuel Requirements check
        document.getElementById('fuelForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const flightType = document.getElementById('fuelFlightType').value;
            const flightTime = document.getElementById('fuelFlightTime').value;
            const reserve = document.getElementById('fuelReserve').value;

            const resultDiv = document.getElementById('fuelResult');
            const submitBtn = e.target.querySelector('button[type="submit"]');

            // Show loading state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Checking...';
            resultDiv.innerHTML = '<div style="color: var(--text-tertiary); padding: 10px;">Loading...</div>';

            try {
                const res = await fetch(`${API_BASE}/regulations/check/fuel?flight_type=${flightType}&flight_time_hours=${flightTime}&reserve_fuel_hours=${reserve}`);
                if (!res.ok) throw new Error('Check failed');
                const data = await res.json();

                resultDiv.innerHTML = `
                    <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 8px;">
                        Checked: ${flightType} â€¢ ${flightTime} hrs flight â€¢ ${reserve} hrs reserve
                    </div>
                    <div class="status-badge ${data.compliant ? 'compliant' : 'non-compliant'}">
                        <svg class="status-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            ${data.compliant
                                ? '<path d="M20 6L9 17l-5-5"/>'
                                : '<path d="M18 6L6 18M6 6l12 12"/>'}
                        </svg>
                        ${data.compliant ? 'Compliant' : 'Non-Compliant'}
                    </div>
                    <p class="result-notes">${data.notes}</p>
                `;
            } catch (e) {
                resultDiv.innerHTML = `<div class="error-message">Unable to check fuel requirements</div>`;
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Check Fuel';
            }
        });

        // ==================== JOURNEY PROFILE ====================

        // Airport database for lookups (expandable via API)
        const airportDB = {
            'KLAX': { name: 'Los Angeles Intl', lat: 33.9425, lon: -118.408 },
            'KJFK': { name: 'JFK International', lat: 40.6413, lon: -73.7781 },
            'KORD': { name: 'Chicago O\'Hare', lat: 41.9742, lon: -87.9073 },
            'KATL': { name: 'Atlanta Hartsfield', lat: 33.6407, lon: -84.4277 },
            'KDFW': { name: 'Dallas/Fort Worth', lat: 32.8998, lon: -97.0403 },
            'KSFO': { name: 'San Francisco Intl', lat: 37.6213, lon: -122.379 },
            'KDEN': { name: 'Denver Intl', lat: 39.8561, lon: -104.6737 },
            'KLAS': { name: 'Las Vegas McCarran', lat: 36.0840, lon: -115.1537 },
            'KPHX': { name: 'Phoenix Sky Harbor', lat: 33.4373, lon: -112.0078 },
            'KSEA': { name: 'Seattle-Tacoma', lat: 47.4502, lon: -122.3088 },
            'KMIA': { name: 'Miami Intl', lat: 25.7959, lon: -80.2870 },
            'KBOS': { name: 'Boston Logan', lat: 42.3656, lon: -71.0096 },
            'KEWR': { name: 'Newark Liberty', lat: 40.6895, lon: -74.1745 },
            'KMSP': { name: 'Minneapolis-St Paul', lat: 44.8848, lon: -93.2223 },
            'KDTW': { name: 'Detroit Metro', lat: 42.2162, lon: -83.3554 },
            'KSAN': { name: 'San Diego Intl', lat: 32.7336, lon: -117.1897 },
            'KTPA': { name: 'Tampa Intl', lat: 27.9755, lon: -82.5332 },
            'KPDX': { name: 'Portland Intl', lat: 45.5898, lon: -122.5951 },
            'KSLC': { name: 'Salt Lake City', lat: 40.7884, lon: -111.9778 },
            'KIAH': { name: 'Houston Bush', lat: 29.9902, lon: -95.3368 },
            'KPSP': { name: 'Palm Springs Intl', lat: 33.8297, lon: -116.5067 },
            'KONT': { name: 'Ontario Intl', lat: 34.056, lon: -117.601 },
            'KBURB': { name: 'Burbank Airport', lat: 34.2007, lon: -118.3585 },
            'KLGB': { name: 'Long Beach', lat: 33.8177, lon: -118.1516 },
            'KSNA': { name: 'John Wayne Orange County', lat: 33.6757, lon: -117.8682 },
            'KOAK': { name: 'Oakland Intl', lat: 37.7213, lon: -122.2208 },
            'KSJC': { name: 'San Jose Intl', lat: 37.3626, lon: -121.9291 },
            'KSMF': { name: 'Sacramento Intl', lat: 38.6954, lon: -121.5908 },
            'KRNO': { name: 'Reno-Tahoe Intl', lat: 39.4991, lon: -119.7681 },
            'KABQ': { name: 'Albuquerque Intl', lat: 35.0402, lon: -106.6094 },
            'KAUS': { name: 'Austin-Bergstrom', lat: 30.1975, lon: -97.6664 },
            'KSAT': { name: 'San Antonio Intl', lat: 29.5337, lon: -98.4698 },
            'KHOU': { name: 'Houston Hobby', lat: 29.6454, lon: -95.2789 },
            'KMSY': { name: 'New Orleans Intl', lat: 29.9934, lon: -90.258 },
            'KMCO': { name: 'Orlando Intl', lat: 28.4294, lon: -81.309 },
            'KFLL': { name: 'Fort Lauderdale', lat: 26.0726, lon: -80.1527 },
            'KPBI': { name: 'Palm Beach Intl', lat: 26.6832, lon: -80.0956 },
            'KRDU': { name: 'Raleigh-Durham', lat: 35.8776, lon: -78.7875 },
            'KCLT': { name: 'Charlotte Douglas', lat: 35.214, lon: -80.9431 },
            'KBWI': { name: 'Baltimore-Washington', lat: 39.1754, lon: -76.6683 },
            'KDCA': { name: 'Reagan National', lat: 38.8521, lon: -77.0377 },
            'KIAD': { name: 'Dulles Intl', lat: 38.9445, lon: -77.4558 },
            'KPHL': { name: 'Philadelphia Intl', lat: 39.8721, lon: -75.2411 },
            'KLGA': { name: 'LaGuardia', lat: 40.7772, lon: -73.8726 },
            'KPIT': { name: 'Pittsburgh Intl', lat: 40.4915, lon: -80.2329 },
            'KCLE': { name: 'Cleveland Hopkins', lat: 41.4117, lon: -81.8498 },
            'KCVG': { name: 'Cincinnati/N Kentucky', lat: 39.0488, lon: -84.6678 },
            'KIND': { name: 'Indianapolis Intl', lat: 39.7173, lon: -86.2944 },
            'KMKE': { name: 'Milwaukee Mitchell', lat: 42.9472, lon: -87.8966 },
            'KSTL': { name: 'St Louis Lambert', lat: 38.7487, lon: -90.37 },
            'KMCI': { name: 'Kansas City Intl', lat: 39.2976, lon: -94.7139 },
            'KOMA': { name: 'Omaha Eppley', lat: 41.3032, lon: -95.8941 },
            'KBNA': { name: 'Nashville Intl', lat: 36.1245, lon: -86.6782 },
            'KMEM': { name: 'Memphis Intl', lat: 35.0424, lon: -89.9767 },
            'KBHM': { name: 'Birmingham-Shuttlesworth', lat: 33.5629, lon: -86.7535 },
            'KJAX': { name: 'Jacksonville Intl', lat: 30.4941, lon: -81.6879 },
            'KRSW': { name: 'Southwest Florida Intl', lat: 26.5362, lon: -81.7552 },
            'KHNL': { name: 'Honolulu Intl', lat: 21.3187, lon: -157.9225 },
            'PANC': { name: 'Anchorage Intl', lat: 61.1743, lon: -149.9962 }
        };

        let waypointCount = 0;
        let profileChart = null;
        let routeWeatherData = null;
        let activeOverlays = { clouds: true, visibility: false, precipitation: false, terrain: false };
        let terrainData = [];

        async function getAirportCoords(code) {
            code = code.toUpperCase().trim();
            if (!code.startsWith('K') && code.length === 3) {
                code = 'K' + code;
            }

            // Check local database first
            if (airportDB[code]) {
                return airportDB[code];
            }

            // Fallback: fetch from station search API
            try {
                const res = await fetch(`${API_BASE}/stations/search?query=${code}`);
                if (res.ok) {
                    const stations = await res.json();
                    const station = stations.find(s => s.icao === code || s.icao === code.substring(1));
                    if (station) {
                        // Cache it for future use
                        airportDB[code] = { name: station.name, lat: station.lat, lon: station.lon };
                        return airportDB[code];
                    }
                }
            } catch (e) {
                console.error('Failed to fetch airport coords:', e);
            }

            return null;
        }

        function addWaypoint() {
            waypointCount++;
            const waypointsList = document.getElementById('waypointsList');
            const waypointHtml = `
                <div class="waypoint-row" data-index="${waypointCount}">
                    <div class="waypoint-marker midpoint">${waypointCount}</div>
                    <div class="waypoint-fields">
                        <input type="text" class="waypoint-name" placeholder="Waypoint (e.g., KDEN)" data-index="${waypointCount}">
                        <input type="number" class="waypoint-alt" placeholder="Alt (ft)" value="7000" data-index="${waypointCount}">
                        <input type="number" class="waypoint-lat" placeholder="Lat" step="0.01" data-index="${waypointCount}" style="display:none;">
                        <input type="number" class="waypoint-lon" placeholder="Lon" step="0.01" data-index="${waypointCount}" style="display:none;">
                    </div>
                    <button class="remove-waypoint-btn" onclick="removeWaypoint(${waypointCount})">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 6L6 18M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
            `;
            waypointsList.insertAdjacentHTML('beforeend', waypointHtml);
        }

        function removeWaypoint(index) {
            const row = document.querySelector(`.waypoint-row[data-index="${index}"]`);
            if (row) row.remove();
        }

        function clearRoute() {
            document.getElementById('waypointsList').innerHTML = '';
            document.querySelectorAll('.waypoint-name').forEach(input => input.value = '');
            document.querySelectorAll('.waypoint-alt[data-index="0"]').forEach(input => input.value = '0');
            document.querySelectorAll('.waypoint-alt[data-index="dest"]').forEach(input => input.value = '0');
            document.getElementById('profileContainer').style.display = 'none';
            waypointCount = 0;
            routeWeatherData = null;
            if (profileChart) {
                profileChart.destroy();
                profileChart = null;
            }
        }

        async function collectWaypoints() {
            const waypoints = [];

            // Departure
            const depName = document.querySelector('.waypoint-name[data-index="0"]').value.trim();
            const depAlt = parseInt(document.querySelector('.waypoint-alt[data-index="0"]').value) || 0;
            if (depName) {
                const coords = await getAirportCoords(depName);
                if (coords) {
                    waypoints.push({
                        name: depName.toUpperCase(),
                        latitude: coords.lat,
                        longitude: coords.lon,
                        altitude_ft: depAlt
                    });
                }
            }

            // Mid waypoints
            const midWaypointRows = document.querySelectorAll('#waypointsList .waypoint-row');
            for (const row of midWaypointRows) {
                const name = row.querySelector('.waypoint-name').value.trim();
                const alt = parseInt(row.querySelector('.waypoint-alt').value) || 7000;
                if (name) {
                    const coords = await getAirportCoords(name);
                    if (coords) {
                        waypoints.push({
                            name: name.toUpperCase(),
                            latitude: coords.lat,
                            longitude: coords.lon,
                            altitude_ft: alt
                        });
                    }
                }
            }

            // Arrival
            const arrName = document.querySelector('.waypoint-name[data-index="dest"]').value.trim();
            const arrAlt = parseInt(document.querySelector('.waypoint-alt[data-index="dest"]').value) || 0;
            if (arrName) {
                const coords = await getAirportCoords(arrName);
                if (coords) {
                    waypoints.push({
                        name: arrName.toUpperCase(),
                        latitude: coords.lat,
                        longitude: coords.lon,
                        altitude_ft: arrAlt
                    });
                }
            }

            return waypoints;
        }

        async function calculateRouteWeather() {
            const waypoints = await collectWaypoints();

            if (waypoints.length < 2) {
                alert('Please enter at least departure and arrival airports');
                return;
            }

            const journeyCard = document.getElementById('journeyCard');
            journeyCard.classList.add('loading');

            try {
                const res = await fetch(`${API_BASE}/route/weather`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ waypoints })
                });

                if (!res.ok) throw new Error('Failed to fetch route weather');

                const data = await res.json();
                routeWeatherData = data;

                // Update stats
                const totalDist = data[data.length - 1].distance_nm;
                const maxAlt = Math.max(...data.map(w => w.altitude_ft));
                const conditions = data.map(w => w.flight_conditions);
                const worstCondition = conditions.includes('LIFR') ? 'LIFR' :
                                      conditions.includes('IFR') ? 'IFR' :
                                      conditions.includes('MVFR') ? 'MVFR' : 'VFR';

                document.getElementById('totalDistance').textContent = totalDist.toFixed(0);
                document.getElementById('maxAltitude').textContent = maxAlt.toLocaleString() + '\'';
                document.getElementById('avgConditions').textContent = worstCondition;

                // Show profile
                document.getElementById('profileContainer').style.display = 'block';

                // Update weather map with route
                updateMapWithRoute(waypoints);

                // Create profile chart
                createProfileChart(data);

                // Create waypoint details
                createWaypointDetails(data);

            } catch (e) {
                console.error('Route weather error:', e);
                alert('Failed to calculate route weather. Please try again.');
            }

            journeyCard.classList.remove('loading');
        }

        function getConditionColor(condition) {
            switch(condition) {
                case 'VFR': return '#10b981';
                case 'MVFR': return '#3b82f6';
                case 'IFR': return '#ef4444';
                case 'LIFR': return '#a855f7';
                default: return '#6b7280';
            }
        }

        // Generate simulated terrain based on route
        function generateTerrainData(waypoints) {
            terrainData = [];
            const terrainProfiles = {
                'KLAX': 126, 'KJFK': 13, 'KORD': 680, 'KATL': 1026,
                'KDFW': 607, 'KSFO': 13, 'KDEN': 5434, 'KLAS': 2181,
                'KPHX': 1135, 'KSEA': 433, 'KMIA': 8, 'KBOS': 20,
                'KEWR': 18, 'KMSP': 841, 'KDTW': 645, 'KSAN': 17,
                'KTPA': 26, 'KPDX': 31, 'KSLC': 4227, 'KIAH': 97
            };

            waypoints.forEach((wp, idx) => {
                let baseTerrain = terrainProfiles[wp.name] || 1000;
                // Add some variation for mid-route terrain
                if (idx > 0 && idx < waypoints.length - 1) {
                    const prevTerrain = terrainProfiles[waypoints[idx-1].name] || 1000;
                    const nextTerrain = terrainProfiles[waypoints[idx+1]?.name] || baseTerrain;
                    baseTerrain = Math.max(baseTerrain, (prevTerrain + nextTerrain) / 2 * 0.8);
                }
                terrainData.push({
                    name: wp.name,
                    elevation: baseTerrain,
                    clearance: wp.altitude_ft - baseTerrain
                });
            });
            return terrainData;
        }

        // Toggle overlay
        function toggleOverlay(overlay) {
            activeOverlays[overlay] = !activeOverlays[overlay];
            document.querySelectorAll('.overlay-btn').forEach(btn => {
                btn.classList.toggle('active', activeOverlays[btn.dataset.overlay]);
            });
            // Show/hide terrain legend
            document.getElementById('terrainLegend').style.display = activeOverlays.terrain ? 'flex' : 'none';
            if (profileChart && routeWeatherData) {
                profileChart.update();
            }
        }

        function createProfileChart(data) {
            const ctx = document.getElementById('profileChart').getContext('2d');

            if (profileChart) {
                profileChart.destroy();
            }

            // Generate terrain data
            generateTerrainData(data);

            const labels = data.map(w => w.name);
            const altitudes = data.map(w => w.altitude_ft);
            const conditions = data.map(w => w.flight_conditions);
            const colors = conditions.map(c => getConditionColor(c));

            const gradient = ctx.createLinearGradient(0, 0, 0, 350);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.02)');

            const maxAlt = Math.max(...altitudes, ...terrainData.map(t => t.elevation)) * 1.3;

            profileChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Flight Path',
                        data: altitudes,
                        borderColor: '#ffffff',
                        backgroundColor: gradient,
                        fill: true,
                        tension: 0.3,
                        pointRadius: 10,
                        pointHoverRadius: 14,
                        pointBackgroundColor: colors,
                        pointBorderColor: '#000',
                        pointBorderWidth: 3,
                        borderWidth: 3,
                        order: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.05)', drawBorder: false },
                            ticks: { color: 'rgba(255, 255, 255, 0.6)', font: { weight: 600, size: 11 } }
                        },
                        y: {
                            position: 'left',
                            min: 0,
                            max: maxAlt,
                            grid: { color: 'rgba(255, 255, 255, 0.05)', drawBorder: false },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.6)',
                                callback: v => (v/1000).toFixed(0) + 'k\''
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'overlays',
                    beforeDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0);
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        const chartArea = chart.chartArea;

                        // Draw terrain overlay
                        if (activeOverlays.terrain && terrainData.length > 0) {
                            ctx.save();
                            ctx.beginPath();
                            ctx.moveTo(chartArea.left, chartArea.bottom);

                            meta.data.forEach((point, idx) => {
                                const terrainY = yAxis.getPixelForValue(terrainData[idx]?.elevation || 0);
                                ctx.lineTo(point.x, terrainY);
                            });

                            ctx.lineTo(chartArea.right, chartArea.bottom);
                            ctx.closePath();

                            const terrainGradient = ctx.createLinearGradient(0, chartArea.bottom - 100, 0, chartArea.bottom);
                            terrainGradient.addColorStop(0, 'rgba(139, 69, 19, 0.6)');
                            terrainGradient.addColorStop(1, 'rgba(34, 139, 34, 0.4)');
                            ctx.fillStyle = terrainGradient;
                            ctx.fill();

                            // Draw terrain warning zones
                            meta.data.forEach((point, idx) => {
                                if (terrainData[idx]) {
                                    const clearance = terrainData[idx].clearance;
                                    const terrainY = yAxis.getPixelForValue(terrainData[idx].elevation);
                                    const altY = yAxis.getPixelForValue(data[idx].altitude_ft);

                                    if (clearance < 500) {
                                        ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
                                    } else if (clearance < 1000) {
                                        ctx.fillStyle = 'rgba(234, 179, 8, 0.3)';
                                    } else {
                                        ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                                    }
                                    ctx.fillRect(point.x - 25, altY, 50, terrainY - altY);
                                }
                            });
                            ctx.restore();
                        }

                        // Draw visibility blocks (IFR/VFR conditions)
                        if (activeOverlays.visibility) {
                            meta.data.forEach((point, idx) => {
                                const wp = data[idx];
                                const conditions = wp.flight_conditions;
                                const color = getConditionColor(conditions);
                                const altY = yAxis.getPixelForValue(wp.altitude_ft);

                                ctx.save();
                                ctx.fillStyle = color + '30';
                                ctx.strokeStyle = color + '60';
                                ctx.lineWidth = 2;

                                const blockWidth = 60;
                                const blockHeight = 80;
                                const blockY = altY - blockHeight - 20;

                                ctx.fillRect(point.x - blockWidth/2, blockY, blockWidth, blockHeight);
                                ctx.strokeRect(point.x - blockWidth/2, blockY, blockWidth, blockHeight);

                                // Label
                                ctx.fillStyle = color;
                                ctx.font = 'bold 10px Inter';
                                ctx.textAlign = 'center';
                                ctx.fillText(conditions, point.x, blockY + blockHeight/2 + 4);
                                ctx.restore();
                            });
                        }

                        // Draw cloud layers
                        if (activeOverlays.clouds) {
                            meta.data.forEach((point, idx) => {
                                const wp = data[idx];
                                if (wp.cloud_cover !== null && wp.cloud_cover > 20) {
                                    const cloudOpacity = Math.min(wp.cloud_cover / 100, 0.7);
                                    const layers = Math.ceil(wp.cloud_cover / 30);

                                    for (let l = 0; l < layers; l++) {
                                        const layerAlt = wp.altitude_ft * (0.5 + l * 0.2);
                                        const layerY = yAxis.getPixelForValue(layerAlt);
                                        const layerHeight = 30 + Math.random() * 20;

                                        ctx.save();
                                        ctx.fillStyle = `rgba(156, 163, 175, ${cloudOpacity * 0.5})`;
                                        ctx.beginPath();

                                        // Cloud shape
                                        const cloudWidth = 40 + wp.cloud_cover * 0.3;
                                        ctx.ellipse(point.x, layerY, cloudWidth, layerHeight/2, 0, 0, Math.PI * 2);
                                        ctx.fill();
                                        ctx.restore();
                                    }
                                }
                            });
                        }

                        // Draw precipitation overlay
                        if (activeOverlays.precipitation) {
                            meta.data.forEach((point, idx) => {
                                const wp = data[idx];
                                const precip = wp.precipitation || 0;
                                const humidity = wp.temperature_c !== null ? Math.max(0, 100 - Math.abs(wp.temperature_c - (wp.dewpoint || wp.temperature_c - 5)) * 5) : 50;

                                if (precip > 0 || humidity > 70) {
                                    const intensity = Math.max(precip * 20, (humidity - 70) / 30);
                                    const altY = yAxis.getPixelForValue(wp.altitude_ft);

                                    ctx.save();
                                    // Rain/precipitation streaks
                                    const numDrops = Math.floor(intensity * 10);
                                    ctx.strokeStyle = `rgba(59, 130, 246, ${0.3 + intensity * 0.3})`;
                                    ctx.lineWidth = 1;

                                    for (let d = 0; d < numDrops; d++) {
                                        const dropX = point.x - 30 + Math.random() * 60;
                                        const dropY = altY + Math.random() * 100;
                                        ctx.beginPath();
                                        ctx.moveTo(dropX, dropY);
                                        ctx.lineTo(dropX - 2, dropY + 10 + Math.random() * 10);
                                        ctx.stroke();
                                    }

                                    // Humidity indicator bar
                                    const barWidth = 8;
                                    const barHeight = humidity * 0.8;
                                    const barX = point.x + 35;
                                    const barY = chartArea.bottom - barHeight - 10;

                                    const humidGradient = ctx.createLinearGradient(barX, barY + barHeight, barX, barY);
                                    humidGradient.addColorStop(0, 'rgba(59, 130, 246, 0.3)');
                                    humidGradient.addColorStop(1, 'rgba(59, 130, 246, 0.8)');
                                    ctx.fillStyle = humidGradient;
                                    ctx.fillRect(barX, barY, barWidth, barHeight);

                                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                                    ctx.font = '9px Inter';
                                    ctx.fillText(Math.round(humidity) + '%', barX, barY - 4);
                                    ctx.restore();
                                }
                            });
                        }
                    },
                    afterDatasetsDraw: function(chart) {
                        // Draw airplane icon on flight path
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0);

                        if (meta.data.length > 1) {
                            const firstPoint = meta.data[0];
                            ctx.save();
                            ctx.fillStyle = '#ffffff';
                            ctx.font = '16px Arial';
                            ctx.fillText('âœˆ', firstPoint.x - 8, firstPoint.y - 20);
                            ctx.restore();
                        }
                    }
                }]
            });

            // Setup hover interaction
            setupHoverInteraction();
        }

        function setupHoverInteraction() {
            const chartContainer = document.querySelector('.profile-chart-container');
            const hoverIndicator = document.getElementById('hoverIndicator');
            const canvas = document.getElementById('profileChart');

            canvas.addEventListener('mousemove', (e) => {
                if (!profileChart || !routeWeatherData) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const chartArea = profileChart.chartArea;

                if (x < chartArea.left || x > chartArea.right) {
                    hoverIndicator.classList.remove('active');
                    return;
                }

                hoverIndicator.classList.add('active');
                hoverIndicator.style.left = x + 'px';

                // Find interpolated position along route
                const progress = (x - chartArea.left) / (chartArea.right - chartArea.left);
                const dataIndex = progress * (routeWeatherData.length - 1);
                const lowerIdx = Math.floor(dataIndex);
                const upperIdx = Math.min(lowerIdx + 1, routeWeatherData.length - 1);
                const fraction = dataIndex - lowerIdx;

                const wp1 = routeWeatherData[lowerIdx];
                const wp2 = routeWeatherData[upperIdx];

                // Interpolate values
                const interpAlt = wp1.altitude_ft + (wp2.altitude_ft - wp1.altitude_ft) * fraction;
                const interpDist = wp1.distance_nm + (wp2.distance_nm - wp1.distance_nm) * fraction;
                const interpTemp = interpolate(wp1.temperature_c, wp2.temperature_c, fraction);
                const interpWind = interpolate(wp1.wind_speed_kt, wp2.wind_speed_kt, fraction);
                const interpClouds = interpolate(wp1.cloud_cover, wp2.cloud_cover, fraction);
                const interpVis = interpolate(wp1.visibility_km, wp2.visibility_km, fraction);
                const interpPrecip = interpolate(wp1.precipitation, wp2.precipitation, fraction);

                // Get terrain clearance
                const terrainElev = terrainData[lowerIdx] ?
                    terrainData[lowerIdx].elevation + (terrainData[upperIdx]?.elevation - terrainData[lowerIdx].elevation || 0) * fraction : 0;
                const terrainClearance = interpAlt - terrainElev;

                // Determine location name
                const locationName = fraction < 0.5 ? wp1.name : wp2.name;
                const conditions = fraction < 0.5 ? wp1.flight_conditions : wp2.flight_conditions;

                // Update tooltip
                document.getElementById('hoverLocation').textContent = locationName;
                const condEl = document.getElementById('hoverConditions');
                condEl.textContent = conditions;
                condEl.className = 'hover-conditions ' + conditions.toLowerCase();

                document.getElementById('hoverAlt').textContent = Math.round(interpAlt).toLocaleString() + '\'';
                document.getElementById('hoverDist').textContent = interpDist.toFixed(1) + ' NM';
                document.getElementById('hoverTemp').textContent = interpTemp !== null ? interpTemp.toFixed(1) + 'Â°C' : '--';
                document.getElementById('hoverWind').textContent = interpWind !== null ? Math.round(interpWind) + ' kt' : '--';
                document.getElementById('hoverClouds').textContent = interpClouds !== null ? Math.round(interpClouds) + '%' : '--';
                document.getElementById('hoverVis').textContent = interpVis !== null ? interpVis.toFixed(1) + ' km' : '--';
                document.getElementById('hoverPrecip').textContent = interpPrecip !== null ? interpPrecip.toFixed(2) + ' mm' : '--';
                document.getElementById('hoverTerrain').textContent = terrainClearance > 0 ?
                    Math.round(terrainClearance).toLocaleString() + '\' AGL' : 'TERRAIN';

                // Position tooltip to avoid edge overflow
                const tooltip = document.getElementById('hoverTooltip');
                if (x > chartArea.right - 200) {
                    tooltip.style.left = 'auto';
                    tooltip.style.right = '16px';
                } else {
                    tooltip.style.left = '16px';
                    tooltip.style.right = 'auto';
                }

                // Move hover line dot to correct Y position
                const yAxis = profileChart.scales.y;
                const dotY = yAxis.getPixelForValue(interpAlt) - chartArea.top;
                const hoverLine = hoverIndicator.querySelector('.hover-line');
                hoverLine.style.setProperty('--dot-top', dotY + 'px');
            });

            canvas.addEventListener('mouseleave', () => {
                hoverIndicator.classList.remove('active');
            });
        }

        function interpolate(v1, v2, fraction) {
            if (v1 === null || v2 === null) return v1 || v2;
            return v1 + (v2 - v1) * fraction;
        }

        function createWaypointDetails(data) {
            const container = document.getElementById('waypointDetails');
            container.innerHTML = data.map((wp, idx) => `
                <div class="waypoint-detail-card">
                    <div class="waypoint-detail-header">
                        <span class="waypoint-detail-name">${wp.name}</span>
                        <span class="waypoint-detail-conditions ${wp.flight_conditions.toLowerCase()}">${wp.flight_conditions}</span>
                    </div>
                    <div class="waypoint-detail-info">
                        <div><span>Distance:</span> <strong>${wp.distance_nm.toFixed(0)} NM</strong></div>
                        <div><span>Altitude:</span> <strong>${wp.altitude_ft.toLocaleString()}'</strong></div>
                        <div><span>Temp:</span> <strong>${wp.temperature_c !== null ? wp.temperature_c + 'Â°C' : '--'}</strong></div>
                        <div><span>Wind:</span> <strong>${wp.wind_speed_kt !== null ? Math.round(wp.wind_speed_kt) + 'kt' : '--'}</strong></div>
                        <div><span>Clouds:</span> <strong>${wp.cloud_cover !== null ? wp.cloud_cover + '%' : '--'}</strong></div>
                        <div><span>Vis:</span> <strong>${wp.visibility_km !== null ? wp.visibility_km + 'km' : '--'}</strong></div>
                    </div>
                </div>
            `).join('');
        }

        // ==================== SIMPLIFY FUNCTIONS ====================

        function toggleSimplify(type, btn) {
            const technical = document.getElementById(`${type}Technical`);
            const simplified = document.getElementById(`${type}Simplified`);
            const label = btn.querySelector('.toggle-label');

            btn.classList.toggle('active');

            if (btn.classList.contains('active')) {
                // Showing simplified view
                technical.style.display = 'none';
                simplified.classList.add('active');
                if (label) label.textContent = 'Raw';
            } else {
                // Showing raw/technical view
                technical.style.display = 'block';
                simplified.classList.remove('active');
                if (label) label.textContent = 'Simplified';
            }
        }

        function generateSimplifiedMetar(data) {
            const details = [];

            // Flight rules summary
            const rulesText = {
                'VFR': 'Great flying weather! Clear skies and good visibility.',
                'MVFR': 'Marginal conditions. Be cautious - reduced visibility or low clouds.',
                'IFR': 'Instrument conditions only. Poor visibility and/or low ceilings.',
                'LIFR': 'Very poor conditions. Extremely low visibility and ceilings.'
            };

            // Temperature
            if (data.temperature !== null) {
                const tempF = Math.round(data.temperature * 9/5 + 32);
                let tempDesc = '';
                if (data.temperature < 0) tempDesc = 'Freezing conditions - watch for ice';
                else if (data.temperature < 10) tempDesc = 'Cold - dress warmly';
                else if (data.temperature < 20) tempDesc = 'Cool and comfortable';
                else if (data.temperature < 30) tempDesc = 'Warm conditions';
                else tempDesc = 'Hot - stay hydrated';

                details.push({
                    icon: 'temp',
                    emoji: 'ðŸŒ¡ï¸',
                    label: 'Temperature',
                    value: `${data.temperature}Â°C (${tempF}Â°F) â€” ${tempDesc}`
                });
            }

            // Wind
            if (data.wind_speed !== null) {
                let windDesc = '';
                if (data.wind_speed === 0) windDesc = 'Calm winds - perfect for takeoff and landing';
                else if (data.wind_speed < 10) windDesc = 'Light winds - minimal impact on flight';
                else if (data.wind_speed < 20) windDesc = 'Moderate winds - may affect smaller aircraft';
                else if (data.wind_speed < 30) windDesc = 'Strong winds - use caution, check crosswind limits';
                else windDesc = 'Very strong winds - consider delaying flight';

                if (data.wind_gust) windDesc += `. Gusting to ${data.wind_gust}kt - expect bumpy conditions`;

                const dirName = getWindDirectionName(data.wind_direction);
                details.push({
                    icon: 'wind',
                    emoji: 'ðŸ’¨',
                    label: 'Wind',
                    value: `${data.wind_speed}kt from the ${dirName} â€” ${windDesc}`
                });
            }

            // Visibility
            if (data.visibility !== null) {
                let visDesc = '';
                if (data.visibility >= 10) visDesc = 'Excellent visibility - you can see for miles';
                else if (data.visibility >= 5) visDesc = 'Good visibility';
                else if (data.visibility >= 3) visDesc = 'Reduced visibility - use extra caution';
                else if (data.visibility >= 1) visDesc = 'Poor visibility - IFR conditions likely';
                else visDesc = 'Very poor visibility - fog or heavy precipitation';

                details.push({
                    icon: 'vis',
                    emoji: 'ðŸ‘ï¸',
                    label: 'Visibility',
                    value: `${data.visibility} statute miles â€” ${visDesc}`
                });
            }

            // Sky conditions
            if (data.sky_conditions && data.sky_conditions.length > 0) {
                const skyDesc = data.sky_conditions.map(c => {
                    const coverNames = {
                        'CLR': 'Clear skies',
                        'SKC': 'Clear skies',
                        'FEW': 'A few clouds',
                        'SCT': 'Scattered clouds',
                        'BKN': 'Mostly cloudy',
                        'OVC': 'Overcast (full cloud cover)'
                    };
                    const name = coverNames[c.cover] || c.cover;
                    return c.base ? `${name} at ${c.base.toLocaleString()} feet` : name;
                }).join(', ');

                details.push({
                    icon: 'sky',
                    emoji: 'â˜ï¸',
                    label: 'Sky',
                    value: skyDesc
                });
            } else {
                details.push({
                    icon: 'sky',
                    emoji: 'â˜€ï¸',
                    label: 'Sky',
                    value: 'Clear skies - no clouds reported'
                });
            }

            // Pressure
            if (data.altimeter !== null) {
                let pressureDesc = '';
                if (data.altimeter > 30.2) pressureDesc = 'High pressure - typically fair weather';
                else if (data.altimeter > 29.8) pressureDesc = 'Normal pressure';
                else pressureDesc = 'Low pressure - possible weather changes';

                details.push({
                    icon: 'pressure',
                    emoji: 'ðŸ“Š',
                    label: 'Pressure',
                    value: `${data.altimeter.toFixed(2)} inHg â€” ${pressureDesc}`
                });
            }

            return {
                summary: rulesText[data.flight_rules] || 'Weather conditions available.',
                details
            };
        }

        function generateSimplifiedTaf(data) {
            // Parse the raw TAF text to extract meaningful information
            const rawText = data.raw_text || '';
            const periods = [];
            let overallSummary = '';
            let flightCategory = 'VFR';

            // Helper to parse wind from TAF
            function parseWind(windStr) {
                if (!windStr) return null;
                const match = windStr.match(/(\d{3}|VRB)(\d{2,3})(G(\d{2,3}))?KT/);
                if (match) {
                    const dir = match[1] === 'VRB' ? 'Variable' : getWindDirectionName(parseInt(match[1]));
                    const speed = parseInt(match[2]);
                    const gust = match[4] ? parseInt(match[4]) : null;
                    let desc = `${dir} at ${speed} knots`;
                    if (gust) desc += `, gusting to ${gust} knots`;
                    return { dir, speed, gust, desc };
                }
                return null;
            }

            // Helper to parse visibility
            function parseVisibility(text) {
                // Match P6SM, 6SM, 3SM, 1/2SM, etc.
                const match = text.match(/\b(P)?(\d+\/?\d*)SM\b/);
                if (match) {
                    const isPlus = match[1] === 'P';
                    let vis = match[2];
                    if (vis.includes('/')) {
                        const parts = vis.split('/');
                        vis = parseInt(parts[0]) / parseInt(parts[1]);
                    } else {
                        vis = parseInt(vis);
                    }
                    if (isPlus) return { value: vis, desc: `Greater than ${vis} miles (excellent)` };
                    if (vis >= 6) return { value: vis, desc: `${vis} miles (good)` };
                    if (vis >= 3) return { value: vis, desc: `${vis} miles (marginal)` };
                    if (vis >= 1) return { value: vis, desc: `${vis} mile${vis > 1 ? 's' : ''} (reduced)` };
                    return { value: vis, desc: `${match[2]} miles (poor)` };
                }
                return null;
            }

            // Helper to parse clouds
            function parseClouds(text) {
                const cloudTypes = {
                    'SKC': 'Clear skies',
                    'CLR': 'Clear skies',
                    'FEW': 'Few clouds',
                    'SCT': 'Scattered clouds',
                    'BKN': 'Broken clouds (mostly cloudy)',
                    'OVC': 'Overcast (complete cloud cover)'
                };
                const clouds = [];
                const regex = /(SKC|CLR|FEW|SCT|BKN|OVC)(\d{3})?/g;
                let match;
                while ((match = regex.exec(text)) !== null) {
                    const type = cloudTypes[match[1]] || match[1];
                    const alt = match[2] ? parseInt(match[2]) * 100 : null;
                    if (alt) {
                        clouds.push(`${type} at ${alt.toLocaleString()} ft`);
                    } else {
                        clouds.push(type);
                    }
                }
                return clouds.length > 0 ? clouds.join(', ') : null;
            }

            // Helper to parse weather phenomena
            function parseWeather(text) {
                const phenomena = {
                    'RA': 'Rain', '-RA': 'Light rain', '+RA': 'Heavy rain',
                    'SN': 'Snow', '-SN': 'Light snow', '+SN': 'Heavy snow',
                    'TS': 'Thunderstorms', 'TSRA': 'Thunderstorms with rain',
                    'BR': 'Mist', 'FG': 'Fog', 'HZ': 'Haze',
                    'DZ': 'Drizzle', '-DZ': 'Light drizzle',
                    'SH': 'Showers', 'SHRA': 'Rain showers',
                    'FZ': 'Freezing', 'FZRA': 'Freezing rain',
                    'GR': 'Hail', 'PL': 'Ice pellets',
                    'NSW': 'No significant weather'
                };
                const found = [];
                for (const [code, desc] of Object.entries(phenomena)) {
                    if (text.includes(code) && !found.some(f => f.includes(desc.split(' ')[0]))) {
                        found.push(desc);
                    }
                }
                return found.length > 0 ? found.join(', ') : null;
            }

            // Split TAF into segments (FM, TEMPO, BECMG, PROB)
            const segments = rawText.split(/\s+(FM\d{6}|TEMPO|BECMG|PROB\d{2})\s*/);

            // Parse initial conditions (first segment)
            if (segments.length > 0) {
                const initial = segments[0];
                const wind = parseWind(initial);
                const vis = parseVisibility(initial);
                const clouds = parseClouds(initial);
                const wx = parseWeather(initial);

                let desc = [];
                if (wind) desc.push(`ðŸŒ¬ï¸ ${wind.desc}`);
                if (vis) desc.push(`ðŸ‘ï¸ Visibility: ${vis.desc}`);
                if (clouds) desc.push(`â˜ï¸ ${clouds}`);
                if (wx) desc.push(`ðŸŒ§ï¸ ${wx}`);

                if (desc.length > 0) {
                    periods.push({
                        time: 'ðŸ“ Current/Initial',
                        description: desc.join('\n'),
                        icon: 'initial'
                    });
                }

                // Determine flight category
                if (vis && vis.value < 1) flightCategory = 'LIFR';
                else if (vis && vis.value < 3) flightCategory = 'IFR';
                else if (vis && vis.value < 5) flightCategory = 'MVFR';
            }

            // Parse change segments
            for (let i = 1; i < segments.length; i += 2) {
                if (i + 1 >= segments.length) break;
                const changeType = segments[i];
                const content = segments[i + 1];

                let timeLabel = '';
                let icon = 'change';
                if (changeType.startsWith('FM')) {
                    const time = changeType.substring(2);
                    const day = time.substring(0, 2);
                    const hour = time.substring(2, 4);
                    timeLabel = `ðŸ• From Day ${day}, ${hour}:00Z`;
                    icon = 'from';
                } else if (changeType === 'TEMPO') {
                    timeLabel = 'âš¡ Temporary';
                    icon = 'tempo';
                } else if (changeType === 'BECMG') {
                    timeLabel = 'ðŸ“ˆ Becoming';
                    icon = 'becmg';
                } else if (changeType.startsWith('PROB')) {
                    const prob = changeType.substring(4);
                    timeLabel = `ðŸŽ² ${prob}% Probability`;
                    icon = 'prob';
                }

                const wind = parseWind(content);
                const vis = parseVisibility(content);
                const clouds = parseClouds(content);
                const wx = parseWeather(content);

                let desc = [];
                if (wind) desc.push(`ðŸŒ¬ï¸ ${wind.desc}`);
                if (vis) desc.push(`ðŸ‘ï¸ Visibility: ${vis.desc}`);
                if (clouds) desc.push(`â˜ï¸ ${clouds}`);
                if (wx) desc.push(`ðŸŒ§ï¸ ${wx}`);

                if (desc.length > 0 && timeLabel) {
                    periods.push({
                        time: timeLabel,
                        description: desc.join('\n'),
                        icon: icon
                    });
                }
            }

            // If no periods parsed, create a basic one
            if (periods.length === 0) {
                const wind = parseWind(rawText);
                const vis = parseVisibility(rawText);
                const clouds = parseClouds(rawText);
                const wx = parseWeather(rawText);

                let desc = [];
                if (wind) desc.push(`ðŸŒ¬ï¸ ${wind.desc}`);
                if (vis) desc.push(`ðŸ‘ï¸ Visibility: ${vis.desc}`);
                if (clouds) desc.push(`â˜ï¸ ${clouds}`);
                if (wx) desc.push(`ðŸŒ§ï¸ ${wx}`);

                periods.push({
                    time: 'ðŸ“ Forecast Period',
                    description: desc.length > 0 ? desc.join('\n') : 'Standard conditions expected',
                    icon: 'initial'
                });
            }

            // Generate summary
            const hasRain = rawText.includes('RA') || rawText.includes('SH');
            const hasSnow = rawText.includes('SN');
            const hasThunder = rawText.includes('TS');
            const hasLowVis = rawText.match(/\b[0-3]SM\b/) || rawText.includes('FG') || rawText.includes('BR');
            const hasStrongWind = rawText.match(/(\d{2})(G\d{2,3})?KT/) && parseInt(RegExp.$1) > 20;

            if (hasThunder) {
                overallSummary = 'â›ˆï¸ Thunderstorms expected â€” check for updates before flight';
            } else if (hasSnow) {
                overallSummary = 'â„ï¸ Snow expected â€” possible icing and reduced visibility';
            } else if (hasRain && hasLowVis) {
                overallSummary = 'ðŸŒ§ï¸ Rain with reduced visibility â€” IFR conditions possible';
            } else if (hasRain) {
                overallSummary = 'ðŸŒ§ï¸ Rain expected during forecast period';
            } else if (hasLowVis) {
                overallSummary = 'ðŸŒ«ï¸ Reduced visibility â€” check minimums before departure';
            } else if (hasStrongWind) {
                overallSummary = 'ðŸ’¨ Strong winds expected â€” check crosswind limits';
            } else {
                overallSummary = 'âœ… Generally favorable conditions expected';
            }

            return {
                summary: overallSummary,
                flightCategory: flightCategory,
                validFrom: data.valid_period_start,
                validTo: data.valid_period_end,
                periods: periods
            };
        }

        function generateSimplifiedTafOld(data) {
            // Keep the old function as backup
            if (!data.forecast_periods || data.forecast_periods.length === 0) {
                return generateSimplifiedTaf(data);
            }

            const periods = data.forecast_periods.map(p => {
                let description = '';

                // Wind description
                if (p.wind_speed !== null && p.wind_speed > 0) {
                    const dirName = getWindDirectionName(p.wind_direction);
                    description += `Winds from ${dirName} at ${p.wind_speed}kt`;
                    if (p.wind_gust) description += ` gusting to ${p.wind_gust}kt`;
                    description += '. ';
                } else {
                    description += 'Calm winds. ';
                }

                // Visibility
                if (p.visibility !== null) {
                    if (p.visibility >= 6) description += 'Good visibility. ';
                    else if (p.visibility >= 3) description += `Visibility ${p.visibility} miles - marginal. `;
                    else description += `Low visibility at ${p.visibility} miles. `;
                }

                // Change indicator
                const changeDesc = {
                    'FM': 'From this time:',
                    'TEMPO': 'Temporarily:',
                    'BECMG': 'Becoming:',
                    'PROB30': '30% chance:',
                    'PROB40': '40% chance:'
                };

                return {
                    time: changeDesc[p.change_indicator] || 'Expected:',
                    description: description || 'No significant changes expected.'
                };
            });

            // Generate overall summary
            let summary = 'Forecast overview: ';
            const hasStrongWinds = data.forecast_periods.some(p => p.wind_speed > 20);
            const hasLowVis = data.forecast_periods.some(p => p.visibility !== null && p.visibility < 3);
            const hasGusts = data.forecast_periods.some(p => p.wind_gust);

            if (!hasStrongWinds && !hasLowVis && !hasGusts) {
                summary += 'Generally favorable conditions expected throughout the forecast period.';
            } else {
                const issues = [];
                if (hasStrongWinds) issues.push('strong winds');
                if (hasLowVis) issues.push('reduced visibility');
                if (hasGusts) issues.push('gusty conditions');
                summary += `Watch for ${issues.join(', ')} during parts of the forecast.`;
            }

            return { summary, periods };
        }

        function getWindDirectionName(degrees) {
            if (degrees === null || degrees === undefined) return 'variable';
            const directions = ['North', 'NNE', 'NE', 'ENE', 'East', 'ESE', 'SE', 'SSE',
                               'South', 'SSW', 'SW', 'WSW', 'West', 'WNW', 'NW', 'NNW'];
            const index = Math.round(degrees / 22.5) % 16;
            return directions[index];
        }

        // Overlay button event listeners
        document.querySelectorAll('.overlay-btn').forEach(btn => {
            btn.addEventListener('click', () => toggleOverlay(btn.dataset.overlay));
        });

        // Initialize
        checkHealth();
        loadNearestAirport();

        // Theme toggle - must be global for onclick handler
        let isLightMode = localStorage.getItem('theme') === 'light';

        function updateThemeIcons() {
            const moonIcon = document.querySelector('.theme-toggle .moon-icon');
            const sunIcon = document.querySelector('.theme-toggle .sun-icon');
            if (moonIcon && sunIcon) {
                moonIcon.style.display = isLightMode ? 'none' : 'block';
                sunIcon.style.display = isLightMode ? 'block' : 'none';
            }
        }

        if (isLightMode) {
            document.documentElement.classList.add('light-mode');
        }
        // Update icons after DOM is ready
        setTimeout(updateThemeIcons, 0);

        window.toggleTheme = function() {
            isLightMode = !isLightMode;
            document.documentElement.classList.toggle('light-mode', isLightMode);
            localStorage.setItem('theme', isLightMode ? 'light' : 'dark');
            updateThemeIcons();
        };
    </script>
</body>
</html>
